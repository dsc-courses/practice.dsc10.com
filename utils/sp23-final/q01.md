# BEGIN PROB

\[(17 pts)\]

# BEGIN SUBPROB

Complete the implementation of the function `most_sunshine`, which takes
in `country`, the name of a country, and `month`, the name of a month
(e.g. `"Apr"`), and returns the name of the city (as a string) in
`country` with the most sunshine hours in `month`, among the cities in
`sun`. Assume there are no ties.

    def most_sunshine(country, month):
        country_only = __(a)__
        return country_only.__(b)__

What goes in blank (a)?

::: responsebox
0.5in
:::

What goes in blank (b)?

::: responsebox
1in
:::

# END SUBPROB

# BEGIN SUBPROB

In this part only, assume that all `"City"` names in `sun` are unique.

Consider the DataFrame `cities` defined below.

    cities = sun.groupby("City").mean().reset_index()

Fill in the blanks so that the DataFrame that results from the sequence
of steps described below is identical to `cities`.

::: center
"Sort `sun` by \_\_(c)\_\_ in \_\_(d)\_\_ order \_\_(e)\_\_.\"
:::

What goes in blank (c)?

( ) `"Country"` ( ) `"City"` ( ) `"Jan"` ( ) `"Year"`

What goes in blank (d)?

( ) ascending ( ) descending

What goes in blank (e)?

( ) and drop the `"Country"` column

( ) and drop the `"Country"` and `"City"` columns

( ) and reset the index

( ) , drop the `"Country"` column, and reset the index

( ) , drop the `"Country"` and `"City"` columns, and reset the index

( ) Nothing, leave blank (e) empty

# END SUBPROB

# BEGIN SUBPROB

True or False: In the code below, `Z` is guaranteed to evaluate to
`True`.

    x = sun.groupby(["Country", "Year"]).mean().shape[0]
    y = sun.groupby("Country").mean().shape[0]
    z = (x >= y)

( ) True ( ) False

# END SUBPROB

In the next few parts, consider the following answer choices.

1.  The name of the country with the most cities.

2.  The name of the country with the fewest cities.

3.  The number of cities in the country with the most cities.

4.  The number of cities in the country with the fewest cities.

5.  The last city, alphabetically, in the first country, alphabetically.

6.  The first city, alphabetically, in the first country,
    alphabetically.

7.  Nothing, because it errors.

# BEGIN SUBPROB

(1.5 pts) What does the following expression evaluate to?

    sun.groupby("Country").max().get("City").iloc[0]

( ) A ( ) B ( ) C ( ) D ( ) E ( ) F ( ) G

# END SUBPROB

# BEGIN SUBPROB

(1.5 pts) What does the following expression evaluate to?

    sun.groupby("Country").sum().get("City").iloc[0]

( ) A ( ) B ( ) C ( ) D ( ) E ( ) F ( ) G

# END SUBPROB

# BEGIN SUBPROB

(1.5 pts) What does the following expression evaluate to?

    sun.groupby("Country").count().sort_values("Jan").index[-1]

( ) A ( ) B ( ) C ( ) D ( ) E ( ) F ( ) G

# END SUBPROB

# BEGIN SUBPROB

(1.5 pts) What does the following expression evaluate to?

    sun.groupby("Country").count().sort_values("City").get("City").iloc[-1]

( ) A ( ) B ( ) C ( ) D ( ) E ( ) F ( ) G

# END SUBPROB

# END PROB