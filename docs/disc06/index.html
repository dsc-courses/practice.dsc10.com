<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Discussion 6: Sampling, Bootstrapping, and Confidence Intervals</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    /* CSS for syntax highlighting */
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { color: #008000; } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { color: #008000; font-weight: bold; } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="../assets/theme.css" />
  <script defer=""
  src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <link rel="stylesheet"
  href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css" />
</head>
<body>
<header id="title-block-header">
<h1 class="title">Discussion 6: Sampling, Bootstrapping, and Confidence
Intervals</h1>
</header>
<p><link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-EVSTQN3/azprG1Anm3QDgpJLIm9Nao0Yz1ztcQTwFspd3yD65VohhpuuCOmLASjC" crossorigin="anonymous">
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/js/bootstrap.bundle.min.js" integrity="sha384-MrcW6ZMFYlzcLA8Nl+NtUVF0sA7MsXsP1UyJoMp4YLEuNSfAP+JcXn/tWtIaxVXM" crossorigin="anonymous"></script>
<!-- add after bootstrap.min.css -->
<link rel="stylesheet" href="https://cdn.rawgit.com/afeld/bootstrap-toc/v1.0.1/dist/bootstrap-toc.min.css"/>
<!-- add after bootstrap.min.js or bootstrap.bundle.min.js -->
<script src="https://cdn.rawgit.com/afeld/bootstrap-toc/v1.0.1/dist/bootstrap-toc.min.js"></script></p>
<!-- for difficulty gauges-->
<script src="https://cdn.plot.ly/plotly-2.16.1.min.js"></script>
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-B947E6J6H4"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-B947E6J6H4');
</script>
<p><a href="../index.html">‚Üê return to practice.dsc10.com</a></p>
<hr />
<p>The problems in this worksheet are taken from past exams. Work on
them <strong>on paper</strong>, since the exams you take in this course
will also be on paper. <br><br>We encourage you to complete this
worksheet in a live discussion section. Solutions will be made available
after all discussion sections have concluded. You don‚Äôt need to submit
your answers anywhere.<br><br><b>Note: We do not plan to cover all
problems here in the live discussion section</b>; the problems we don‚Äôt
cover can be used for extra practice.</p>
<hr />
<h2 id="problem-1">Problem 1</h2>
<p>Given below is the <code>season</code> DataFrame, which contains
statistics on all players in the WNBA in the 2021 season. The first few
rows of <code>season</code> are shown below:</p>
<center><img src='../assets/images/wi22-final/seasons.png' width=40%></center>
<p>Each row in season corresponds to a single player. In this problem,
we‚Äôll be looking at the <code>'PPG'</code> column, which records the
number of points scored per game played.</p>
<p>Now, suppose we only have access to the DataFrame
<code>small_season</code>, which is a random sample of <strong>size
36</strong> from <code>season</code>. We‚Äôre interested in learning about
the true mean points per game of all players in <code>season</code>
given just the information in <code>small_season</code>.</p>
<p>To start, we want to bootstrap <code>small_season</code> 10,000 times
and compute the mean of the resample each time. We want to store these
10,000 bootstrapped means in the array <code>boot_means</code>.</p>
<p>Here is a broken implementation of this procedure.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>boot_means <span class="op">=</span> np.array([])                                           </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> np.arange(<span class="dv">10000</span>):                                          </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    resample <span class="op">=</span> small_season.sample(season.shape[<span class="dv">0</span>], replace<span class="op">=</span><span class="va">False</span>)  <span class="co"># Line 1</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    resample_mean <span class="op">=</span> small_season.get(<span class="st">&#39;PPG&#39;</span>).mean()                  <span class="co"># Line 2</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    np.append(boot_means, new_mean)                                 <span class="co"># Line 3</span></span></code></pre></div>
<p>For each of the 3 lines of code above (marked by comments), specify
what is incorrect about the line by selecting one or more of the
corresponding options below. Or, select ‚ÄúLine _ is correct as-is‚Äù if you
believe there‚Äôs nothing that needs to be changed about the line in order
for the above code to run properly.</p>
<p><br></p>
<h3 id="problem-1.1">Problem 1.1</h3>
<p>What is incorrect about Line 1? Select all that apply.</p>
<ul class="task-list">
<li><p><input type="checkbox" disabled="" /> Currently the procedure samples from <code>small_season</code>, when
it should be sampling from <code>season</code></p></li>
<li><p><input type="checkbox" disabled="" /> The sample size is <code>season.shape[0]</code>, when it should be
<code>small_season.shape[0]</code></p></li>
<li><p><input type="checkbox" disabled="" /> Sampling is currently being done without replacement, when it should
be done with replacement</p></li>
<li><p><input type="checkbox" disabled="" /> Line 1 is correct as-is</p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading1_1">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse1_1" aria-expanded="true" aria-controls="collapse1_1">
Click to view the solution.
</button>
</h2>
<div id="collapse1_1" class="accordion-collapse collapse"
aria-labelledby="heading1_1" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answers:</strong></p>
<ul>
<li>The sample size is <code>season.shape[0]</code>, when it should be
<code>small_season.shape[0]</code></li>
<li>Sampling is currently being done without replacement, when it should
be done with replacement</li>
</ul>
<p>Here, our goal is to bootstrap from <code>small_season</code>. When
bootstrapping, we <strong>sample with replacement</strong> from our
original sample, with a sample size that‚Äôs equal to the original
sample‚Äôs size. Here, our original sample is <code>small_season</code>,
so we should be taking samples of size
<code>small_season.shape[0]</code> from it.</p>
<p>Option 1 is incorrect; <code>season</code> has nothing to do with
this problem, as we are bootstrapping from
<code>small_season</code>.</p>
<hr/>
<h5>Difficulty: ‚≠êÔ∏è</h5>
<p>
</p>
<p>The average score on this problem was 95%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<h3 id="problem-1.2">Problem 1.2</h3>
<p>What is incorrect about Line 2? Select all that apply.</p>
<ul class="task-list">
<li><p><input type="checkbox" disabled="" /> Currently it is taking the mean of the <code>'PPG'</code> column in
<code>small_season</code>, when it should be taking the mean of the
<code>'PPG'</code> column in <code>season</code></p></li>
<li><p><input type="checkbox" disabled="" /> Currently it is taking the mean of the <code>'PPG'</code> column in
<code>small_season</code>, when it should be taking the mean of the
<code>'PPG'</code> column in <code>resample</code></p></li>
<li><p><input type="checkbox" disabled="" /> <code>.mean()</code> is not a valid Series method, and should be
replaced with a call to the function <code>np.mean</code></p></li>
<li><p><input type="checkbox" disabled="" /> Line 2 is correct as-is</p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading1_2">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse1_2" aria-expanded="true" aria-controls="collapse1_2">
Click to view the solution.
</button>
</h2>
<div id="collapse1_2" class="accordion-collapse collapse"
aria-labelledby="heading1_2" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer:</strong> Currently it is taking the mean of the
<code>'PPG'</code> column in <code>small_season</code>, when it should
be taking the mean of the <code>'PPG'</code> column in
<code>resample</code></p>
<p>The current implementation of Line 2 doesn‚Äôt use the
<code>resample</code> at all, when it should. If we were to leave Line 2
as it is, all of the values in <code>boot_means</code> would be
identical (and equal to the mean of the <code>'PPG'</code> column in
<code>small_season</code>).</p>
<p>Option 1 is incorrect since our bootstrapping procedure is
independent of <code>season</code>. Option 3 is incorrect because
<code>.mean()</code> is a valid Series method.</p>
<hr/>
<h5>Difficulty: ‚≠êÔ∏è</h5>
<p>
</p>
<p>The average score on this problem was 98%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<h3 id="problem-1.3">Problem 1.3</h3>
<p>What is incorrect about Line 3? Select all that apply.</p>
<ul class="task-list">
<li><p><input type="checkbox" disabled="" /> The result of calling <code>np.append</code> is not being reassigned
to <code>boot_means</code>, so <code>boot_means</code> will be an empty
array after running this procedure</p></li>
<li><p><input type="checkbox" disabled="" /> The indentation level of the line is incorrect ‚Äì
<code>np.append</code> should be outside of the <code>for</code>-loop
(and aligned with <code>for i</code>)</p></li>
<li><p><input type="checkbox" disabled="" /> <code>new_mean</code> is not a defined variable name, and should be
replaced with <code>resample_mean</code></p></li>
<li><p><input type="checkbox" disabled="" /> Line 3 is correct as-is</p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading1_3">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse1_3" aria-expanded="true" aria-controls="collapse1_3">
Click to view the solution.
</button>
</h2>
<div id="collapse1_3" class="accordion-collapse collapse"
aria-labelledby="heading1_3" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answers:</strong></p>
<ul>
<li>The result of calling <code>np.append</code> is not being reassigned
to <code>boot_means</code>, so <code>boot_means</code> will be an empty
array after running this procedure</li>
<li><code>new_mean</code> is not a defined variable name, and should be
replaced with <code>resample_mean</code></li>
</ul>
<p><code>np.append</code> returns a new array and does not modify the
array it is called on (<code>boot_means</code>, in this case), so Option
1 is a necessary fix. Furthermore, Option 3 is a necessary fix since
<code>new_mean</code> wasn‚Äôt defined anywhere.</p>
<p>Option 2 is incorrect; if <code>np.append</code> were outside of the
<code>for</code>-loop, none of the 10,000 resampled means would be saved
in <code>boot_means</code>.</p>
<hr/>
<h5>Difficulty: ‚≠êÔ∏è</h5>
<p>
</p>
<p>The average score on this problem was 94%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<h3 id="problem-1.4">Problem 1.4</h3>
<p>We construct a 95% confidence interval for the true mean points per
game for all players by taking the middle 95% of the bootstrapped sample
means.</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>left_b <span class="op">=</span> np.percentile(boot_means, <span class="fl">2.5</span>)</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>right_b <span class="op">=</span> np.percentile(boot_means, <span class="fl">97.5</span>)</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>boot_ci <span class="op">=</span> [left_b, right_b]         </span></code></pre></div>
<p>We find that <code>boot_ci</code> is the interval [7.7, 10.3].
However, the mean points per game in <code>season</code> is 7, which is
not in the interval we found. Which of the following statements is true?
(Select all question)</p>
<ul class="task-list">
<li><p><input type="checkbox" disabled="" /> 95% of games in <code>season</code> have a number of points between
7.7 and 10.3.</p></li>
<li><p><input type="checkbox" disabled="" /> 95% of values in <code>boot_means</code> fall between 7.7 and
10.3.</p></li>
<li><p><input type="checkbox" disabled="" /> There is a 95% chance that the true mean points per game is between
7.7 and 10.3.</p></li>
<li><p><input type="checkbox" disabled="" /> The interval we created did not contain the true mean points per
game, but if we collected many original samples and constructed many 95%
confidence intervals, then exactly 95% of them would contain the true
mean points per game.</p></li>
<li><p><input type="checkbox" disabled="" /> The interval we created did not contain the true mean points per
game, but if we collected many original samples and constructed many 95%
confidence intervals, then roughly 95% of them would contain the true
mean points per game.</p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading1_4">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse1_4" aria-expanded="true" aria-controls="collapse1_4">
Click to view the solution.
</button>
</h2>
<div id="collapse1_4" class="accordion-collapse collapse"
aria-labelledby="heading1_4" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answers:</strong></p>
<ul>
<li>95% of values in <code>boot_means</code> fall between the endpoints
of the interval we found.</li>
<li>The interval we created did not contain the true mean points per
game, but if we collected many original samples and constructed many 95%
confidence intervals, then roughly 95% of them would contain the true
mean points per game.</li>
</ul>
<p>The first option is incorrect because the confidence interval
describes what we think the <em>mean</em> points per game could be.
Individual games likely have a very large variety in the number of
points scores. Probably very few have between 7.7 and 10.3 points.</p>
<p>The second option is correct because this is precisely how we
calculated the endpoints of our interval, by taking the middle 95% of
values in <code>boot_means</code>.</p>
<p>The third option is incorrect because we know the true mean points
per game - it‚Äôs 7. 7 does not fall in the interval 7.7 to 10.3, and we
can say that with certainty. This is not a probability statement because
the interval and the parameter are both fixed.</p>
<p>The fourth option is incorrect because of the word <em>exactly</em>.
We generally can‚Äôt make guarantees like this when working with
randomness.</p>
<p>The fifth option is correct, as this is the meaning of confidence. We
have confidence in the process of generating 95% confidence intervals,
because roughly 95% of such intervals we create will capture the
parameter of interest.</p>
<!-- <hr><h5>Difficulty: ‚≠êÔ∏è‚≠êÔ∏è</h5><p>The average score on this problem was 87%. -->
</div>
</div>
</div>
</div>
<p><br></p>
<hr />
<h2 id="problem-2">Problem 2</h2>
<p><strong>True or False</strong>: Suppose that from a sample, you
compute a 95% bootstrapped confidence interval for a population
parameter to be the interval [L, R]. Then the average of L and R is the
mean of the original sample.</p>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading2">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse2" aria-expanded="true" aria-controls="collapse2">
Click to view the solution.
</button>
</h2>
<div id="collapse2" class="accordion-collapse collapse"
aria-labelledby="heading2" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer: </strong> False</p>
<p>A 95% confidence interval indicates we are 95% confident that the
true population parameter falls within the interval [L, R]. Note that
the problem specifies that the confidence interval is bootstrapped.
Since the interval is found using bootstrapping, L and R averaged will
not be the mean of the original sample since the mean of the original
sample is not what is used in calculating the bootstrapped confidence
interval. The bootstrapped confidence interval is created by re-sampling
the data with replacement over and over again. Thus, while the interval
is typically centered around the sample mean due to the nature of
bootstrapping, the average of L and R (the 2.5th and 97.5th percentiles
of the distribution of bootstrapped means) may not exactly equal the
sample mean, but should be close to it. Additionally, L is the 2.5th
percentile of the distribution of bootstrapped means and R is the 97.5th
percentile, and these are not necessarily the same distance away from
the mean of the sample.</p>
<hr/>
<h5>Difficulty: ‚≠êÔ∏è‚≠êÔ∏è</h5>
<p>
</p>
<p>The average score on this problem was 87%.</p>
</div>
</div>
</div>
</div>
<hr />
<h2 id="problem-3">Problem 3</h2>
<div class="sourceCode" id="cb3"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>results <span class="op">=</span> np.array([])</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> np.arange(<span class="dv">10</span>):</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    result <span class="op">=</span> np.random.choice(np.arange(<span class="dv">1000</span>), replace<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    results <span class="op">=</span> np.append(results, result)</span></code></pre></div>
<p>After this code executes, <code>results</code> contains:</p>
<ul class="task-list">
<li><p><input type="radio" disabled="" /> a simple random sample of size 9, chosen from a set of size 999 with
replacement</p></li>
<li><p><input type="radio" disabled="" /> a simple random sample of size 9, chosen from a set of size 999
without replacement</p></li>
<li><p><input type="radio" disabled="" /> a simple random sample of size 10, chosen from a set of size 1000
with replacement</p></li>
<li><p><input type="radio" disabled="" /> a simple random sample of size 10, chosen from a set of size 1000
without replacement</p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading3">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse3" aria-expanded="true" aria-controls="collapse3">
Click to view the solution.
</button>
</h2>
<div id="collapse3" class="accordion-collapse collapse"
aria-labelledby="heading3" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer: </strong> a simple random sample of size 10, chosen
from a set of size 1000 with replacement</p>
<p>Let‚Äôs see what the code is doing. The first line initializes an empty
array called <code>results</code>. The for loop runs 10 times. Each
time, it creates a value called <code>result</code> by some process
we‚Äôll inspect shortly and appends this value to the end of the
<code>results</code> array. At the end of the code snippet,
<code>results</code> will be an array containing 10 elements.</p>
<p>Now, let‚Äôs look at the process by which each element
<code>result</code> is generated. Each <code>result</code> is a random
element chosen from <code>np.arange(1000)</code> which is the numbers
from 0 to 999, inclusive. That‚Äôs 1000 possible numbers. Each time
<code>np.random.choice</code> is called, just one value is chosen from
this set of 1000 possible numbers.</p>
<p>When we sample just one element from a set of values, sampling with
replacement is the same as sampling without replacement, because
sampling with or without replacement concerns whether subsequent draws
can be the same as previous ones. When we‚Äôre just sampling one element,
it really doesn‚Äôt matter whether our process involves putting that
element back, as we‚Äôre not going to draw again!</p>
<p>Therefore, <code>result</code> is just one random number chosen from
the 1000 possible numbers. Each time the <code>for</code> loop executes,
<code>result</code> gets set to a random number chosen from the 1000
possible numbers. It is possible (though unlikely) that the random
<code>result</code> of the first execution of the loop matches the
<code>result</code> of the second execution of the loop. More generally,
there can be repeated values in the <code>results</code> array since
each entry of this array is independently drawn from the same set of
possibilities. Since repetitions are possible, this means the sample is
drawn with replacement.</p>
<p>Therefore, the <code>results</code> array contains a sample of size
10 chosen from a set of size 1000 with replacement. This is called a
‚Äúsimple random sample‚Äù because each possible sample of 10 values is
equally likely, which comes from the fact that
<code>np.random.choice</code> chooses each possible value with equal
probability by default.</p>
<hr/>
<h5>Difficulty: ‚≠êÔ∏è‚≠êÔ∏è‚≠êÔ∏è‚≠êÔ∏è‚≠êÔ∏è</h5>
<p>
</p>
<p>The average score on this problem was 11%.</p>
</div>
</div>
</div>
</div>
<hr />
<h2 id="problem-4">Problem 4</h2>
<p>An IKEA fan created an app where people can log the amount of time it
took them to assemble their IKEA furniture. The DataFrame
<code>app_data</code> has a row for each product build that was logged
on the app. The columns are:</p>
<ul>
<li><code>'product'</code> (<code>str</code>): the name of the product,
which includes the product line as the first word, followed by a
description of the product</li>
<li><code>'category'</code> (<code>str</code>): a categorical
description of the type of product</li>
<li><code>'assembly_time'</code> (<code>str</code>): the amount of time
to assemble the product, formatted as <code>'x hr, y min'</code> where
<code>x</code> and <code>y</code> represent integers, possibly zero</li>
<li><code>'minutes'</code> (<code>int</code>): integer values
representing the number of minutes it took to assemble each product
<br><br></li>
</ul>
<p>We want to use <code>app_data</code> to estimate the average amount
of time it takes to build an IKEA bed (any product in the
<code>'bed'</code> category). Which of the following strategies would be
an appropriate way to estimate this quantity? Select all that apply.</p>
<ul class="task-list">
<li><p><input type="checkbox" disabled="" /> Query to keep only the beds. Then resample with replacement many
times. For each resample, take the mean of the <code>'minutes'</code>
column. Compute a 95% confidence interval based on those means.</p></li>
<li><p><input type="checkbox" disabled="" /> Query to keep only the beds. Group by <code>'product'</code> using
the mean aggregation function. Then resample with replacement many
times. For each resample, take the mean of the <code>'minutes'</code>
column. Compute a 95% confidence interval based on those means.</p></li>
<li><p><input type="checkbox" disabled="" /> Resample with replacement many times. For each resample, first query
to keep only the beds and then take the mean of the
<code>'minutes'</code> column. Compute a 95% confidence interval based
on those means.</p></li>
<li><p><input type="checkbox" disabled="" /> Resample with replacement many times. For each resample, first query
to keep only the beds. Then group by <code>'product'</code> using the
mean aggregation function, and finally take the mean of the
<code>'minutes'</code> column. Compute a 95% confidence interval based
on those means.</p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading4">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse4" aria-expanded="true" aria-controls="collapse4">
Click to view the solution.
</button>
</h2>
<div id="collapse4" class="accordion-collapse collapse"
aria-labelledby="heading4" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer: </strong></p>
<p>Only the first answer is correct. This is a question of parameter
estimation, so our approach is to use bootstrapping to create many
resamples of our original sample, computing the average of each
resample. Each resample should always be the same size as the original
sample. The first answer choice accomplishes this by querying first to
keep only the beds, then resampling from the DataFrame of beds only.
This means resamples will have the same size as the original sample.
Each resample‚Äôs mean will be computed, so we will have many resample
means from which to construct our 95% confidence interval.</p>
<p>In the second answer choice, we are actually taking the mean twice.
We first average the build times for all builds of the same product when
grouping by product. This produces a DataFrame of different products
with the average build time for each. We then resample from this
DataFrame, computing the average of each resample. But this is a
resample of products, not of product builds. The size of the resample is
the number of unique products in <code>app_data</code>, not the number
of reported product builds in <code>app_data</code>. Further, we get
incorrect results by averaging numbers that are already averages. For
example, if 5 people build bed A and it takes them each 1 hour, and 1
person builds bed B and it takes them 10 hours, the average amount of
time to build a bed is <span class="math inline">\frac{5*1+10}{6} =
2.5</span>. But if we average the times for bed A (1 hour) and average
the times for bed B (5 hours), then average those, we get <span class="math inline">\frac{1+5}{2} = 3</span>, which is not the same.
More generally, grouping is not a part of the bootstrapping process
because we want each data value to be weighted equally.</p>
<p>The last two answer choices are incorrect because they involve
resampling from the full <code>app_data</code> DataFrame before querying
to keep only the beds. This is incorrect because it does not preserve
the sample size. For example, if <code>app_data</code> contains 1000
reported bed builds and 4000 other product builds, then the only
relevant data is the 1000 bed build times, so when we resample, we want
to consider another set of 1000 beds. If we resample from the full
<code>app_data</code> DataFrame, our resample will contain 5000 rows,
but the number of beds will be random, not necessarily 1000. If we query
first to keep only the beds, then resample, our resample will contain
exactly 1000 beds every time. As an added bonus, since we only care
about beds, it‚Äôs much faster to resample from a smaller DataFrame of
beds only than it is to resample from all <code>app_data</code> with
plenty of rows we don‚Äôt care about.</p>
<hr/>
<h5>Difficulty: ‚≠êÔ∏è‚≠êÔ∏è‚≠êÔ∏è</h5>
<p>
</p>
<p>The average score on this problem was 71%.</p>
</div>
</div>
</div>
</div>
<hr />
<h2 id="problem-5">Problem 5</h2>
<p>Suppose we take a uniform random sample with replacement from a
population, and use the sample mean as an estimate for the population
mean. Which of the following is correct?</p>
<ul class="task-list">
<li><p><input type="radio" disabled="" /> If we take a larger sample, our sample mean will be closer to the
population mean.</p></li>
<li><p><input type="radio" disabled="" /> If we take a smaller sample, our sample mean will be closer to the
population mean.</p></li>
<li><p><input type="radio" disabled="" /> If we take a larger sample, our sample mean is more likely to be
close to the population mean than if we take a smaller sample.</p></li>
<li><p><input type="radio" disabled="" /> If we take a smaller sample, our sample mean is more likely to be
close to the population mean than if we take a larger sample.</p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading5">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse5" aria-expanded="true" aria-controls="collapse5">
Click to view the solution.
</button>
</h2>
<div id="collapse5" class="accordion-collapse collapse"
aria-labelledby="heading5" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer: </strong> If we take a larger sample, our sample mean
is more likely to be close to the population mean than if we take a
smaller sample.</p>
<p>Larger samples tend to give better estimates of the population mean
than smaller samples. That‚Äôs because large samples are more like the
population than small samples. We can see this in the extreme. Imagine a
sample of 1 element from a population. The sample might vary a lot,
depending on the distribution of the population. On the other extreme,
if we sample the whole population, our sample mean will be exactly the
same as the population mean.</p>
<p>Notice that the correct answer choice uses the words ‚Äúis more likely
to be close to‚Äù as opposed to ‚Äúwill be closer to.‚Äù We‚Äôre talking about a
general phenomenon here: larger samples tend to give better estimates of
the population mean than smaller samples. We cannot say that if we take
a larger sample our sample mean ‚Äúwill be closer to‚Äù the population mean,
since it‚Äôs always possible to get lucky with a small sample and unlucky
with a large sample. That is, one particular small sample may happen to
have a mean very close to the population mean, and one particular large
sample may happen to have a mean that‚Äôs not so close to the population
mean. This <em>can</em> happen, it‚Äôs just not likely to.</p>
<hr/>
<h5>Difficulty: ‚≠êÔ∏è</h5>
<p>
</p>
<p>The average score on this problem was 100%.</p>
</div>
</div>
</div>
</div>
<hr />
<h2 id="problem-6">Problem 6</h2>
<p>Suppose we have access to a simple random sample of all US Costco
members of size <strong>145</strong>. Our sample is stored in a
DataFrame named <code>us_sample</code>, in which the
<code>"Spend"</code> column contains the October 2023 spending of each
sampled member in dollars.</p>
<p><br></p>
<h3 id="problem-6.1">Problem 6.1</h3>
<p>Fill in the blanks below so that <code>us_left</code> and
<code>us_right</code> are the left and right endpoints of a
<strong>46%</strong> confidence interval for the average October 2023
spending of all US members.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>costco_means <span class="op">=</span> np.array([])</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> np.arange(<span class="dv">5000</span>):</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    resampled_spends <span class="op">=</span> __(x)__</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>    costco_means <span class="op">=</span> np.append(costco_means, resampled_spends.mean())</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>left <span class="op">=</span> np.percentile(costco_means, __(y)__)</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>right <span class="op">=</span> np.percentile(costco_means, __(z)__)</span></code></pre></div>
<p>Which of the following could go in blank (x)? <strong>Select all that
apply.</strong></p>
<ul class="task-list">
<li><p><input type="checkbox" disabled="" /> <code>us_sample.sample(145, replace=True).get("Spend")</code></p></li>
<li><p><input type="checkbox" disabled="" /> <code>us_sample.sample(145, replace=False).get("Spend")</code></p></li>
<li><p><input type="checkbox" disabled="" /> <code>np.random.choice(us_sample.get("Spend"), 145)</code></p></li>
<li><p><input type="checkbox" disabled="" /> <code>np.random.choice(us_sample.get("Spend"), 145, replace=True)</code></p></li>
<li><p><input type="checkbox" disabled="" /> <code>np.random.choice(us_sample.get("Spend"), 145, replace=False)</code></p></li>
<li><p><input type="checkbox" disabled="" /> None of the above.</p></li>
</ul>
<p>What goes in blanks (y) and (z)? Give your answers as integers.</p>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading6_1">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse6_1" aria-expanded="true" aria-controls="collapse6_1">
Click to view the solution.
</button>
</h2>
<div id="collapse6_1" class="accordion-collapse collapse"
aria-labelledby="heading6_1" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer</strong>:</p>
<ul>
<li><code>x</code>:
<ul>
<li><code>us_sample.sample(145, replace=True).get("Spend")</code></li>
<li><code>np.random.choice(us_sample.get("Spend"), 145)</code></li>
<li><code>np.random.choice(us_sample.get("Spend"), 145, replace=True)</code></li>
</ul></li>
<li><code>y</code>: <code>27</code></li>
<li><code>z</code>: <code>73</code></li>
</ul>
<hr/>
<h5>Difficulty: ‚≠êÔ∏è‚≠êÔ∏è</h5>
<p>
</p>
<p>The average score on this problem was 79%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<h3 id="problem-6.2">Problem 6.2</h3>
<p>True or False: <strong>46%</strong> of all US members in
<code>us_sample</code> spent between <code>us_left</code> and
<code>us_right</code> in October 2023.</p>
<ul class="task-list">
<li><p><input type="radio" disabled="" /> True</p></li>
<li><p><input type="radio" disabled="" /> False</p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading6_2">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse6_2" aria-expanded="true" aria-controls="collapse6_2">
Click to view the solution.
</button>
</h2>
<div id="collapse6_2" class="accordion-collapse collapse"
aria-labelledby="heading6_2" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer</strong>: False</p>
<hr/>
<h5>Difficulty: ‚≠êÔ∏è‚≠êÔ∏è</h5>
<p>
</p>
<p>The average score on this problem was 85%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<h3 id="problem-6.3">Problem 6.3</h3>
<p>True or False: If we repeat the code from part (b) 200 times, each
time bootstrapping from a new random sample of 145 members drawn from
all US members, then about <strong>92</strong> of the intervals we
create will contain the average October 2023 spending of all US
members.</p>
<ul class="task-list">
<li><p><input type="radio" disabled="" /> True</p></li>
<li><p><input type="radio" disabled="" /> False</p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading6_3">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse6_3" aria-expanded="true" aria-controls="collapse6_3">
Click to view the solution.
</button>
</h2>
<div id="collapse6_3" class="accordion-collapse collapse"
aria-labelledby="heading6_3" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer</strong>: True</p>
<hr/>
<h5>Difficulty: ‚≠êÔ∏è‚≠êÔ∏è‚≠êÔ∏è</h5>
<p>
</p>
<p>The average score on this problem was 51%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<h3 id="problem-6.4">Problem 6.4</h3>
<p>True or False: If we repeat the code from part (b) 200 times, each
time bootstrapping from <code>us_sample</code>, then about
<strong>92</strong> of the intervals we create will contain the average
October 2023 spending of all US members.</p>
<ul class="task-list">
<li><p><input type="radio" disabled="" /> True</p></li>
<li><p><input type="radio" disabled="" /> False</p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading6_4">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse6_4" aria-expanded="true" aria-controls="collapse6_4">
Click to view the solution.
</button>
</h2>
<div id="collapse6_4" class="accordion-collapse collapse"
aria-labelledby="heading6_4" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer</strong>: False</p>
<hr/>
<h5>Difficulty: ‚≠êÔ∏è‚≠êÔ∏è‚≠êÔ∏è‚≠êÔ∏è</h5>
<p>
</p>
<p>The average score on this problem was 30%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<hr />
<h2 id="section"><span class="math display"> </span></h2>
<h4
id="feedback-find-an-error-still-confused-have-a-suggestion-let-us-know-here.">üëã
Feedback: Find an error? Still confused? Have a suggestion?
<a href="https://forms.gle/WZ71FchnXU1K154d7">Let us know
here</u></a>.</h4>
<hr />
</body>
</html>
