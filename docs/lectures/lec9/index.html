<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Lecture 9 — Practice</title>
  <style>
    /* Default styles provided by pandoc.
    ** See https://pandoc.org/MANUAL.html#variables-for-html for config info.
    */
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    /* CSS for syntax highlighting */
    html { -webkit-text-size-adjust: 100%; }
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { color: #008000; } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { color: #008000; font-weight: bold; } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="../../assets/theme.css" />
  <script defer=""
  src="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <link rel="stylesheet"
  href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css" />
</head>
<body>
<header id="title-block-header">
<h1 class="title">Lecture 9 — Practice</h1>
</header>
<p><link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-EVSTQN3/azprG1Anm3QDgpJLIm9Nao0Yz1ztcQTwFspd3yD65VohhpuuCOmLASjC" crossorigin="anonymous">
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/js/bootstrap.bundle.min.js" integrity="sha384-MrcW6ZMFYlzcLA8Nl+NtUVF0sA7MsXsP1UyJoMp4YLEuNSfAP+JcXn/tWtIaxVXM" crossorigin="anonymous"></script>
<!-- add after bootstrap.min.css -->
<link rel="stylesheet" href="https://cdn.rawgit.com/afeld/bootstrap-toc/v1.0.1/dist/bootstrap-toc.min.css"/>
<!-- add after bootstrap.min.js or bootstrap.bundle.min.js -->
<script src="https://cdn.rawgit.com/afeld/bootstrap-toc/v1.0.1/dist/bootstrap-toc.min.js"></script></p>
<!-- for difficulty gauges-->
<script src="https://cdn.plot.ly/plotly-2.16.1.min.js"></script>
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-B947E6J6H4"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-B947E6J6H4');
</script>
<p><a href="../../index.html">← return to practice.dsc10.com</a></p>
<hr />
<h1 id="lecture-9-collected-practice-questions">Lecture 9 — Collected
Practice Questions</h1>
<p>Below are practice problems tagged for Lecture <strong>9</strong>
(rendered directly from the original exam/quiz sources).</p>
<hr />
<h2 id="problem-1">Problem 1</h2>
<p>Suppose we create a DataFrame called <code>socal</code> containing
only King Triton’s flights departing from SAN, LAX, or SNA (John Wayne
Airport in Orange County). <code>socal</code> has 10 rows; the bar chart
below shows how many of these 10 flights departed from each airport.</p>
<center><img src='../../assets/images/fa21-midterm/socal.png' width=30%></center>
<p><br></p>
<p>Consider the DataFrame that results from merging <code>socal</code>
with itself, as follows:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>double_merge <span class="op">=</span> socal.merge(socal, left_on<span class="op">=</span><span class="st">&#39;FROM&#39;</span>, right_on<span class="op">=</span><span class="st">&#39;FROM&#39;</span>)</span></code></pre></div>
<p>How many rows does <code>double_merge</code> have?</p>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading1">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse1" aria-expanded="true" aria-controls="collapse1">
Click to view the solution.
</button>
</h2>
<div id="collapse1" class="accordion-collapse collapse"
aria-labelledby="heading1" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer: </strong> 38</p>
<p>There are two flights from LAX. When we merge <code>socal</code> with
itself on the <code>'FROM'</code> column, each of these flights gets
paired up with each of these flights, for a total of four rows in the
output. That is, the first flight from LAX gets paired with both the
first and second flights from LAX. Similarly, the second flight from LAX
gets paired with both the first and second flights from LAX.</p>
<p>Following this logic, each of the five flights from SAN gets paired
with each of the five flights from SAN, for an additional 25 rows in the
output. For SNA, there will be 9 rows in the output. The total is
therefore <span class="math inline">2^2 + 5^2 + 3^2 = 4 + 25 + 9 =
38</span> rows.</p>
<hr/>
<h5>Difficulty: ⭐️⭐️⭐️⭐️⭐️</h5>
<p>
</p>
<p>The average score on this problem was 27%.</p>
</div>
</div>
</div>
</div>
<hr />
<h2 id="problem-2">Problem 2</h2>
<p>We also have a DataFrame that contains the distribution of
“BodyStyle” for all “Brands” in <code>evs</code>, other than Nissan.</p>
<center><img src='../../assets/images/fa22-midterm/midq6.png' width=50%></center>
<p>Suppose we’ve run the following few lines of code.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>tesla <span class="op">=</span> evs[evs.get(<span class="st">&quot;Brand&quot;</span>) <span class="op">==</span> <span class="st">&quot;Tesla&quot;</span>]</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>bmw <span class="op">=</span> evs[evs.get(<span class="st">&quot;Brand&quot;</span>) <span class="op">==</span> <span class="st">&quot;BMW&quot;</span>]</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>audi <span class="op">=</span> evs[evs.get(<span class="st">&quot;Brand&quot;</span>) <span class="op">==</span> <span class="st">&quot;Audi&quot;</span>]</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>combo <span class="op">=</span> tesla.merge(bmw, on<span class="op">=</span><span class="st">&quot;BodyStyle&quot;</span>).merge(audi, on<span class="op">=</span><span class="st">&quot;BodyStyle&quot;</span>)</span></code></pre></div>
<p>How many rows does the DataFrame <code>combo</code> have?</p>
<ul class="task-list">
<li><p><input type="radio" disabled="" /> 21</p></li>
<li><p><input type="radio" disabled="" /> 24</p></li>
<li><p><input type="radio" disabled="" /> 35</p></li>
<li><p><input type="radio" disabled="" /> 65</p></li>
<li><p><input type="radio" disabled="" /> 72</p></li>
<li><p><input type="radio" disabled="" /> 96</p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading2">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse2" aria-expanded="true" aria-controls="collapse2">
Click to view the solution.
</button>
</h2>
<div id="collapse2" class="accordion-collapse collapse"
aria-labelledby="heading2" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer:</strong> 35</p>
<p>Let’s attempt this problem step-by-step. We’ll first determine the
number of rows in <code>tesla.merge(bmw, on="BodyStyle")</code>, and
then determine the number of rows in <code>combo</code>. <strong>For the
purposes of the solution, let’s use <code>temp</code> to refer to the
first merged DataFrame,
<code>tesla.merge(bmw, on="BodyStyle")</code>.</strong></p>
<p>Recall, when we <code>merge</code> two DataFrames, the resulting
DataFrame contains a single row for every match between the two columns,
and rows in either DataFrame without a match disappear. In this problem,
the column that we’re looking for matches in is
<code>"BodyStyle"</code>.</p>
<p>To determine the number of rows of <code>temp</code>, we need to
determine which rows of <code>tesla</code> have a
<code>"BodyStyle"</code> that matches a row in <code>bmw</code>. From
the DataFrame provided, we can see that the only
<code>"BodyStyle"</code>s in both <code>tesla</code> and
<code>bmw</code> are SUV and sedan. When we merge <code>tesla</code> and
<code>bmw</code> on <code>"BodyStyle"</code>:</p>
<ul>
<li>The 4 SUV rows in <code>tesla</code> each match the 1 SUV row in
<code>bmw</code>. This will create 4 SUV rows in <code>temp</code>.</li>
<li>The 3 sedan rows in <code>tesla</code> each match the 1 sedan row in
<code>bmw</code>. This will create 3 sedan rows in
<code>temp</code>.</li>
</ul>
<p>So, <code>temp</code> is a DataFrame with a total of 7 rows, with 4
rows for SUVs and 3 rows for sedans (in the <code>"BodyStyle"</code>)
column. Now, when we merge <code>temp</code> and <code>audi</code> on
<code>"BodyStyle"</code>:</p>
<ul>
<li>The 4 SUV rows in <code>temp</code> each match the 8 SUV rows in
<code>audi</code>. This will create <span class="math inline">4 \cdot 8
= 32</span> SUV rows in <code>combo</code>.</li>
<li>The 3 sedan rows in <code>temp</code> each match the 1 sedan row in
<code>audi</code>. This will create <span class="math inline">3 \cdot 1
= 3</span> sedan rows in <code>combo</code>.</li>
</ul>
<p>Thus, the total number of rows in <code>combo</code> is <span class="math inline">32 + 3 = 35</span>.</p>
<p>Note: You may notice that 35 is the result of multiplying the
<code>"SUV"</code> and <code>"Sedan"</code> columns in the DataFrame
provided, and adding up the results. This problem is similar to <a href="../fa21-midterm/index.html#problem-5">Problem 5 from the Fall 2021
Midterm</a>).</p>
<hr/>
<h5>Difficulty: ⭐️⭐️⭐️⭐️</h5>
<p>
</p>
<p>The average score on this problem was 45%.</p>
</div>
</div>
</div>
</div>
<hr />
<p class="meta"><em>Source:</em> fa22-midterm — Q7</p>
<h2 id="problem-3">Problem 3</h2>
<p>Below, we provide the same DataFrame as shown at the start of the
previous problem, which contains the distribution of “BodyStyle” for all
“Brands” in evs, other than Nissan.</p>
<center><img src='../../assets/images/fa22-midterm/midq6.png' width=50%></center>
<p>Suppose we’ve run the following few lines of code.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>tesla <span class="op">=</span> evs[evs.get(<span class="st">&quot;Brand&quot;</span>) <span class="op">==</span> <span class="st">&quot;Tesla&quot;</span>]</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>bmw <span class="op">=</span> evs[evs.get(<span class="st">&quot;Brand&quot;</span>) <span class="op">==</span> <span class="st">&quot;BMW&quot;</span>]</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>audi <span class="op">=</span> evs[evs.get(<span class="st">&quot;Brand&quot;</span>) <span class="op">==</span> <span class="st">&quot;Audi&quot;</span>]</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>combo <span class="op">=</span> tesla.merge(bmw, on<span class="op">=</span><span class="st">&quot;BodyStyle&quot;</span>).merge(audi, on<span class="op">=</span><span class="st">&quot;BodyStyle&quot;</span>)</span></code></pre></div>
<p>How many rows does the DataFrame <code>combo</code> have?</p>
<ul class="task-list">
<li><p><input type="radio" disabled="" /> 21</p></li>
<li><p><input type="radio" disabled="" /> 24</p></li>
<li><p><input type="radio" disabled="" /> 35</p></li>
<li><p><input type="radio" disabled="" /> 65</p></li>
<li><p><input type="radio" disabled="" /> 72</p></li>
<li><p><input type="radio" disabled="" /> 96</p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading3">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse3" aria-expanded="true" aria-controls="collapse3">
Click to view the solution.
</button>
</h2>
<div id="collapse3" class="accordion-collapse collapse"
aria-labelledby="heading3" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer:</strong> 35</p>
<p>Let’s attempt this problem step-by-step. We’ll first determine the
number of rows in <code>tesla.merge(bmw, on="BodyStyle")</code>, and
then determine the number of rows in <code>combo</code>. <strong>For the
purposes of the solution, let’s use <code>temp</code> to refer to the
first merged DataFrame,
<code>tesla.merge(bmw, on="BodyStyle")</code>.</strong></p>
<p>Recall, when we <code>merge</code> two DataFrames, the resulting
DataFrame contains a single row for every match between the two columns,
and rows in either DataFrame without a match disappear. In this problem,
the column that we’re looking for matches in is
<code>"BodyStyle"</code>.</p>
<p>To determine the number of rows of <code>temp</code>, we need to
determine which rows of <code>tesla</code> have a
<code>"BodyStyle"</code> that matches a row in <code>bmw</code>. From
the DataFrame provided, we can see that the only
<code>"BodyStyle"</code>s in both <code>tesla</code> and
<code>bmw</code> are SUV and sedan. When we merge <code>tesla</code> and
<code>bmw</code> on <code>"BodyStyle"</code>:</p>
<ul>
<li>The 4 SUV rows in <code>tesla</code> each match the 1 SUV row in
<code>bmw</code>. This will create 4 SUV rows in <code>temp</code>.</li>
<li>The 3 sedan rows in <code>tesla</code> each match the 1 sedan row in
<code>bmw</code>. This will create 3 sedan rows in
<code>temp</code>.</li>
</ul>
<p>So, <code>temp</code> is a DataFrame with a total of 7 rows, with 4
rows for SUVs and 3 rows for sedans (in the <code>"BodyStyle"</code>)
column. Now, when we merge <code>temp</code> and <code>audi</code> on
<code>"BodyStyle"</code>:</p>
<ul>
<li>The 4 SUV rows in <code>temp</code> each match the 8 SUV rows in
<code>audi</code>. This will create <span class="math inline">4 \cdot 8
= 32</span> SUV rows in <code>combo</code>.</li>
<li>The 3 sedan rows in <code>temp</code> each match the 1 sedan row in
<code>audi</code>. This will create <span class="math inline">3 \cdot 1
= 3</span> sedan rows in <code>combo</code>.</li>
</ul>
<p>Thus, the total number of rows in <code>combo</code> is <span class="math inline">32 + 3 = 35</span>.</p>
<p>Note: You may notice that 35 is the result of multiplying the
<code>"SUV"</code> and <code>"Sedan"</code> columns in the DataFrame
provided, and adding up the results. This problem is similar to <a href="../fa21-midterm/index.html#problem-5">Problem 5 from the Fall 2021
Midterm</a>).</p>
<hr/>
<h5>Difficulty: ⭐️⭐️⭐️⭐️</h5>
<p>
</p>
<p>The average score on this problem was 45%.</p>
</div>
</div>
</div>
</div>
<hr />
<p class="meta"><em>Source:</em> fa23-final — Q2</p>
<h2 id="problem-4">Problem 4</h2>
<p>Consider the DataFrame <code>combo</code>, defined below.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>    combo <span class="op">=</span> txn.groupby([<span class="st">&quot;is_fraud&quot;</span>, <span class="st">&quot;method&quot;</span>, <span class="st">&quot;card&quot;</span>]).mean()</span></code></pre></div>
<p><br></p>
<h3 id="problem-4.1">Problem 4.1</h3>
<p>What is the maximum possible value of <code>combo.shape[0]</code>?
Give your answer as an integer.</p>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading4_1">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse4_1" aria-expanded="true" aria-controls="collapse4_1">
Click to view the solution.
</button>
</h2>
<div id="collapse4_1" class="accordion-collapse collapse"
aria-labelledby="heading4_1" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer:</strong> 16</p>
<p><code>combo.shape[0]</code> will give us the number of rows of the
<code>combo</code> DataFrame. Since we’re grouping by
<code>"is_fraud"</code>, <code>"method"</code>, and <code>"card"</code>,
we will have one row for each unique combination of values in these
columns. There are 2 possible values for <code>"is_fraud"</code>, 2
possible values for <code>"method"</code>, and 2 possible values for
<code>"card"</code>, so the total number of possibilities is 2 * 2 * 4 =
16. This is the maximum number possible because 16 combinations of
<code>"is_fraud"</code>, <code>"method"</code>, and <code>"card"</code>
are possible, but they may not all exist in the data.</p>
<hr/>
<h5>Difficulty: ⭐️⭐️</h5>
<p>
</p>
<p>The average score on this problem was 75%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<h3 id="problem-4.2">Problem 4.2</h3>
<p>What is the value of <code>combo.shape[1]</code>?</p>
<ul class="task-list">
<li><p><input type="radio" disabled="" /> 1</p></li>
<li><p><input type="radio" disabled="" /> 2</p></li>
<li><p><input type="radio" disabled="" /> 3</p></li>
<li><p><input type="radio" disabled="" /> 4</p></li>
<li><p><input type="radio" disabled="" /> 5</p></li>
<li><p><input type="radio" disabled="" /> 6</p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading4_2">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse4_2" aria-expanded="true" aria-controls="collapse4_2">
Click to view the solution.
</button>
</h2>
<div id="collapse4_2" class="accordion-collapse collapse"
aria-labelledby="heading4_2" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer:</strong> 2</p>
<p><code>combo.shape[1]</code> will give us the number of columns of the
DataFrame. In this case, we’re using <code>.mean()</code> as our
aggregation function, so the resulting DataFrame will only have columns
with numeric types (since BabyPandas automatically ignores columns which
have a data type incompatible with the aggregation function). In this
case, <code>"amount"</code> and <code>"lifetime"</code> are the only
numeric columns, so <code>combo</code> will have 2 columns.</p>
<hr/>
<h5>Difficulty: ⭐️⭐️⭐️⭐️</h5>
<p>
</p>
<p>The average score on this problem was 47%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<hr />
<p class="meta"><em>Source:</em> fa23-final — Q5</p>
<h2 id="problem-5">Problem 5</h2>
<p>The DataFrame <code>seven</code>, shown below to the
<strong>left</strong>, consists of a simple random sample of 7 rows from
<code>txn</code>, with just the <code>"is_fraud"</code> and
<code>"amount"</code> columns selected.</p>
<p>The DataFrame <code>locations</code>, shown below to the
<strong>right</strong>, is missing some values in its
<code>"is_fraud"</code> column.</p>
<center><img src='../../assets/images/fa23-final/final-merge.png' width=1000></center>
<p><br></p>
<h3 id="problem-5.1">Problem 5.1</h3>
<p>Fill in the blanks to complete the <code>"is_fraud"</code> column of
<code>locations</code> so that the DataFrame
<code>seven.merge(locations, on="is_fraud")</code> has
<strong>19</strong> rows.</p>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading5_1">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse5_1" aria-expanded="true" aria-controls="collapse5_1">
Click to view the solution.
</button>
</h2>
<div id="collapse5_1" class="accordion-collapse collapse"
aria-labelledby="heading5_1" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer</strong> A correct answer has one <code>True</code>
and three <code>False</code> rows.</p>
<p>We’re merging on the <code>"is_fraud"</code> column, so we want to
look at which rows have which values for <code>"is_fraud"</code>. There
are only two possible values (<code>True</code> and <code>False</code>),
and we see that there are two <code>True</code>s and 5
<code>False</code>s in <code>seven</code>. Now, think about what happens
“under the hood” for this merge, and how many rows are created when it
occurs. Python will match each <code>True</code> in <code>seven</code>
with each <code>True</code> in the <code>"is_fraud"</code> column of
<code>location</code>, and make a new row for each such pair. For
example, since Toronto’s row in <code>location</code> has a
<code>True</code> value in <code>location</code>, the merged DataFrame
will have one row where Toronto is matched with the transaction of
$34.92 and one where Toronto is matched with the transaction of $25.07.
More broadly, each <code>True</code> in <code>locations</code> creates 2
rows in the merged DataFrame, and each <code>False</code> in
<code>locations</code> creates 5 rows in the merged DataFrame. The
question now boils down to creating 19 by summing 2s and 5s. Notice that
<span class="math inline">19 = 3\cdot5+2\cdot2</span>. This means we can
achieve the desired 19 rows by making sure the <code>locations</code>
DataFrame has three <code>False</code> rows and two <code>True</code>
rows. Since <code>location</code> already has one <code>True</code>, we
can fill in the remaining spots with three <code>False</code>s and one
<code>True</code>. It doesn’t matter which rows we make
<code>True</code> and which ones we make <code>False</code>, since
either way the merge will produce the same number of rows for each (5
each for every <code>False</code> and 2 each for every
<code>True</code>).</p>
<hr/>
<h5>Difficulty: ⭐️⭐️</h5>
<p>
</p>
<p>The average score on this problem was 88%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<h3 id="problem-5.2">Problem 5.2</h3>
<p>True or False: It is possible to fill in the four blanks in the
<code>"is_fraud"</code> column of <code>locations</code> so that the
DataFrame <code>seven.merge(locations, on="is_fraud")</code> has
<strong>14</strong> rows.</p>
<ul class="task-list">
<li><p><input type="radio" disabled="" /> True</p></li>
<li><p><input type="radio" disabled="" /> False</p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading5_2">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse5_2" aria-expanded="true" aria-controls="collapse5_2">
Click to view the solution.
</button>
</h2>
<div id="collapse5_2" class="accordion-collapse collapse"
aria-labelledby="heading5_2" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer:</strong> False</p>
<p>As we discovered by solving problem 5.1, each <code>False</code>
value in <code>locations</code> gives rise to 5 rows of the merged
DataFrame, and each <code>True</code> value gives rise to 2 rows. This
means that the number of rows in the merged DataFrame will be <span class="math inline">m\cdot5 + n\cdot2</span>, where m is the number of
Falses in <code>location</code> and n is the number of
<code>Trues</code> in <code>location</code>. Namely, m and n are
integers that add up to 5. There’s only a few possibilities so we can
try them all, and see that none add up 14:</p>
<ul>
<li><p><span class="math inline">0\cdot5 + 5\cdot2 = 10</span></p></li>
<li><p><span class="math inline">1\cdot5 + 4\cdot2 = 13</span></p></li>
<li><p><span class="math inline">2\cdot5 + 3\cdot2 = 16</span></p></li>
<li><p><span class="math inline">3\cdot5 + 2\cdot2 = 19</span></p></li>
<li><p><span class="math inline">4\cdot5 + 1\cdot2 = 22</span></p></li>
</ul>
<hr/>
<h5>Difficulty: ⭐️⭐️</h5>
<p>
</p>
<p>The average score on this problem was 79%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<hr />
<p class="meta"><em>Source:</em> fa23-midterm — Q4</p>
<h2 id="problem-6">Problem 6</h2>
<p>For those who plan on having children, an important consideration
when deciding whether to live in an area is the cost of raising children
in that area. The DataFrame <code>expensive</code>, defined below,
contains all of the rows in <code>living_cost</code> where the
<code>"avg_childcare_cost"</code> is at least $20,000.</p>
<pre><code>expensive = living_cost[living_cost.get(&quot;avg_childcare_cost&quot;) 
                        &gt;= 20000]</code></pre>
<p>We’ll call a county an “expensive county" if there is <strong>at
least one</strong> <code>"family_type"</code> in that county with an
<code>"avg_childcare_cost"</code> of at least $20,000. Note that all
expensive counties appear in the <code>expensive</code> DataFrame, but
some may appear multiple times (if they have multiple
<code>"family_type"</code>s with an <code>"avg_childcare_cost"</code> of
at least $20,000).</p>
<p>Recall that the <code>"is_metro"</code> column contains Boolean
values indicating whether or not each county is part of a metropolitan
(urban) area. For all rows of <code>living_cost</code> (and, hence,
<code>expensive</code>) corresponding to the same geographic location,
the value of <code>"is_metro"</code> is the same. For instance, every
row corresponding to San Diego County has an <code>"is_metro"</code>
value of <code>True</code>.</p>
<p>Fill in the blanks below so that the result is a DataFrame indexed by
<code>"state"</code> where the <code>"is_metro"</code> column gives the
<strong>proportion of expensive counties in each state that are part of
a metropolitan area</strong>. For example, if New Jersey has five
expensive counties and four of them are metropolitan, the row
corresponding to a New Jersey should have a value of 0.8 in the
<code>"is_metro"</code> column.</p>
<pre><code>(expensive.groupby(____(a)____).max()
          .reset_index()
          .groupby(____(b)____).____(c)____)</code></pre>
<p><br></p>
<h3 id="problem-6.1">Problem 6.1</h3>
<p>What goes in blank (a)?</p>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading6_1">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse6_1" aria-expanded="true" aria-controls="collapse6_1">
Click to view the solution.
</button>
</h2>
<div id="collapse6_1" class="accordion-collapse collapse"
aria-labelledby="heading6_1" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer:</strong> <code>["state", "county"]</code> or
<code>["county", "state"]</code></p>
<p>We are told that all expensive counties appear in the
<code>expensive</code> DataFrame, but some may appear multiple times,
for several different <code>"family_type"</code> values. The question we
want to answer, however, is about the proportion of expensive counties
in each state that are part of a metropolitan area, which has nothing to
do with <code>"family_type"</code>. In other words, we don’t want or
need multiple rows corresponding to the same US county.</p>
<p>To keep just one row for each US county, we can group by both
<code>"state"</code> and <code>"county"</code> (in either order). Then
the resulting DataFrame will have one row for each unique combination of
<code>"state"</code> and <code>"county"</code>, or one row for each US
county. Notice that the <code>.max()</code> aggregation method keeps the
last alphabetical value from the <code>"is_metro"</code> column in each
US county. If there are multiple rows in <code>expensive</code>
corresponding to the same US county, we are told that they will all have
the same value in the <code>"is_metro"</code> column, so taking the
maximum just takes any one of these values, which are all the same. We
could have just as easily taken the minimum.</p>
<p>Notice the presence of <code>.reset_index()</code> in the provided
code. That is a clue that we may need to group by multiple columns in
this problem!</p>
<hr/>
<h5>Difficulty: ⭐️⭐️⭐️⭐️⭐️</h5>
<p>
</p>
<p>The average score on this problem was 14%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<h3 id="problem-6.2">Problem 6.2</h3>
<p>What goes in blank (b)?</p>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading6_2">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse6_2" aria-expanded="true" aria-controls="collapse6_2">
Click to view the solution.
</button>
</h2>
<div id="collapse6_2" class="accordion-collapse collapse"
aria-labelledby="heading6_2" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer:</strong> <code>"state"</code></p>
<p>Now that we have one row for each US county that is considered
expensive, we want to proceed by calculating the proportion of expensive
counties within each state that are in a metropolitan area. Our goal is
to organize the counties by state and create a DataFrame indexed only by
<code>"state"</code> so we want to group by <code>"state"</code> to
achieve this. </p>
<hr/>
<h5>Difficulty: ⭐️⭐️⭐️</h5>
<p>The average score on
this problem was 68%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<h3 id="problem-6.3">Problem 6.3</h3>
<p>What goes in blank (c)?</p>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading6_3">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse6_3" aria-expanded="true" aria-controls="collapse6_3">
Click to view the solution.
</button>
</h2>
<div id="collapse6_3" class="accordion-collapse collapse"
aria-labelledby="heading6_3" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer:</strong> <code>mean()</code></p>
<p>Recall that the <code>"is_metro"</code> column consists of Boolean
values, where <code>True</code> equals 1 and <code>False</code> equals
0. Notice that if we take the average of the <code>"is_metro"</code>
column for all the counties in a given state, we’ll be computing the sum
of these 0s and 1s (or the number of <code>True</code> values) divided
by the total number of expensive counties in that state. This gives the
proportion of expensive counties in the state that are in a metropolitan
area. Thus, when we group the expensive counties according to what state
they are in, we can use the <code>.mean()</code> aggregation method to
calculate the proportion of expensive counties in each state that are in
a metropolitan area.</p>
<hr/>
<h5>Difficulty: ⭐️⭐️⭐️⭐️</h5>
<p>
</p>
<p>The average score on this problem was 35%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<hr />
<p class="meta"><em>Source:</em> fa23-midterm — Q6</p>
<h2 id="problem-7">Problem 7</h2>
<p>Recall that <code>living_cost</code> has <span
class="math inline">31430</span> rows, one for each of the ten possible
<code>"family_type"</code> values in each of the <span
class="math inline">3143</span> US counties.</p>
<p>Consider the function <code>state_merge</code>, defined below.</p>
<pre><code>def state_merge(A, B):
    state_A = living_cost[living_cost.get(&quot;state&quot;) == A]
    state_B = living_cost[living_cost.get(&quot;state&quot;) == B]
    return state_A.merge(state_B, on=&quot;family_type&quot;).shape[0]</code></pre>
<p>Suppose Montana (<code>"MT"</code>) has 5 counties, and suppose
<code>state_merge("MT", "NV")</code> evaluates to <code>1050</code>. How
many counties does Nevada (<code>"NV"</code>) have? Give your answer as
an integer.</p>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading7">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse7" aria-expanded="true" aria-controls="collapse7">
Click to view the solution.
</button>
</h2>
<div id="collapse7" class="accordion-collapse collapse"
aria-labelledby="heading7" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer</strong> <span class="math inline">21</span></p>
<p>We are told Montana has 5 counties. We don’t know how many counties
Nevada has, but let’s call the number of counties in Nevada <span class="math inline">x</span> and see how many rows the merged DataFrame
should have, in terms of <span class="math inline">x</span>. If Montana
has 5 counties, since there are 10 <code>"family_type"</code> values per
county, this means the <code>state_A</code> DataFrame has 50 rows.</p>
<p>Similarly, if Nevada has <span class="math inline">x</span> counties,
then <code>state_B</code> has <span class="math inline">10x</span> rows.
When we merge on <code>"family_type"</code>, each of the 5 rows in
<code>state_A</code> with a given <code>"family_type"</code> (say
<code>"2a3c"</code>) will match with each of the <span class="math inline">x</span> rows in <code>state_B</code> with that same
<code>"family_type"</code>. This will lead to <span class="math inline">5x</span> rows in the output corresponding to each
<code>"family_type"</code>, and since there are 10 different values for
<code>"family_type"</code>, this means the final output will have <span class="math inline">50x</span> rows.</p>
<p>We are told that the merged DataFrame has <span class="math inline">1050</span> rows, so we can find <span class="math inline">x</span> by solving <span class="math inline">50x =
1050</span>, which leads to <span class="math inline">x = 21</span>.</p>
<hr/>
<h5>Difficulty: ⭐️⭐️⭐️⭐️</h5>
<p>
</p>
<p>The average score on this problem was 36%.</p>
</div>
</div>
</div>
</div>
<hr />
<p class="meta"><em>Source:</em> fa24-midterm — Q8</p>
<h2 id="problem-8">Problem 8</h2>
<p>Select the correct way to fill in the blank such that the code below
evaluates to <code>True</code>.</p>
<pre><code>treat.groupby(______).mean().shape[0] == treat.shape[0]</code></pre>
<ul class="task-list">
<li><p><input type="radio" disabled="" /> <code>"address"</code></p></li>
<li><p><input type="radio" disabled="" /> <code>"candy"</code></p></li>
<li><p><input type="radio" disabled="" /> <code>"neighborhood"</code></p></li>
<li><p><input type="radio" disabled="" /> <code>["address", "candy"]</code></p></li>
<li><p><input type="radio" disabled="" /> <code>["candy", "neighborhood"]</code></p></li>
<li><p><input type="radio" disabled="" /> <code>["address", "neighborhood"]</code></p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading8">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse8" aria-expanded="true" aria-controls="collapse8">
Click to view the solution.
</button>
</h2>
<div id="collapse8" class="accordion-collapse collapse"
aria-labelledby="heading8" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer</strong>: <code>["address", "candy"]</code></p>
<p><code>.shape</code> returns a tuple containing the number of rows and
number of columns of a DataFrame respectively. By indexing
<code>.shape[0]</code> we get the number of rows. In the above question,
we are comparing whether the number of rows of <code>treat</code>
grouped by its column(s) is equal to the number of rows of the original
<code>treat</code> itself. This is only possible when there is a unique
row for each value in the column or for each combination of columns.
Since it is possible for an address to give out different types of
candy, values in <code>"address"</code> can show up multiple times.
Similarly, values in <code>"candy"</code> can also show up multiple
times since more than one house may give out a specific candy. A
neighborhood has multiple houses, so if a neighborhood has more than one
house, <code>"neighborhood"</code> will appear multiple times.</p>
<p>% write for combinations here % Each address gives out a specific
candy only once, and hence <code>["address", "candy"]</code> would have
a unique row for each combination. This would make the number of rows in
the grouped DataFrame equal to <code>treat</code> itself. Multiple
neighborhoods might be giving out the same candy or a single
neighborhood could be giving out multiple candies, so
<code>["candy", "neighborhood"]</code> is not the answer. Finally, a
neighborhood can have multiple addresses, but each address could be
giving out more than one candy, which would mean this combination would
occur multiple times in <code>treat</code>, which means this would also
not be an answer. Since <code>["address", "candy"]</code> is the only
combination that gives a unique row for each combination, the grouped
DataFrame would contain the same number of rows as <code>treat</code>
itself.</p>
<hr/>
<h5>Difficulty: ⭐️⭐️⭐️</h5>
<p>
</p>
<p>The average score on this problem was 69%.</p>
</div>
</div>
</div>
</div>
<hr />
<p class="meta"><em>Source:</em> fa24-midterm — Q9</p>
<h2 id="problem-9">Problem 9</h2>
<p>Assume that all houses in <code>treat</code> give out the same size
candy, say fun-sized. Suppose we have an additional DataFrame,
<code>trick</code>, which is indexed by <code>"candy"</code> and has one
column, <code>"price"</code>, containing the cost in dollars of a
<strong>single piece</strong> of fun-sized candy, as a
<code>float</code>.</p>
<p>Suppose that:</p>
<ul>
<li><p><code>treat</code> has 200 rows total, and includes 15 distinct
types of candies.</p></li>
<li><p><code>trick</code> has 25 rows total: 15 for the candies that
appear in <code>treat</code>, plus 10 additional rows that correspond to
candies not represented in <code>treat</code>.</p></li>
</ul>
<p>Consider the following line of code:</p>
<pre><code>trick_or_treat = trick.merge(treat, left_index = True, right_on = &quot;candy&quot;)</code></pre>
<p>How many rows does <code>trick_or_treat</code> have?</p>
<ul class="task-list">
<li><p><input type="radio" disabled="" /> <span class="math inline">15</span></p></li>
<li><p><input type="radio" disabled="" /> <span class="math inline">25</span></p></li>
<li><p><input type="radio" disabled="" /> <span class="math inline">200</span></p></li>
<li><p><input type="radio" disabled="" /> <span class="math inline">215</span></p></li>
<li><p><input type="radio" disabled="" /> <span class="math inline">225</span></p></li>
<li><p><input type="radio" disabled="" /> <span class="math inline">3000</span></p></li>
<li><p><input type="radio" disabled="" /> <span class="math inline">5000</span></p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading9">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse9" aria-expanded="true" aria-controls="collapse9">
Click to view the solution.
</button>
</h2>
<div id="collapse9" class="accordion-collapse collapse"
aria-labelledby="heading9" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer</strong>: 200</p>
<p>We are told that <code>trick</code> has 25 rows: 15 from candies that
are in <code>treat</code> and 10 additional candies. This means that
each candy in <code>trick</code> appears exactly once because 15+10= 25.
In addition, a general property when merging dataframes is that the
number of rows for one shared value between the dataframes is the
product of the number of occurences in either dataframe. For example, if
Twix occurs 5 times in <code>treat</code>, the number of times it occurs
in <code>trick_or_treat</code> is 5 * 1 = 5 (it occurs once in
<code>trick</code>). Using this logic, we can determine how many rows
are in <code>trick_or_treat</code>. Since each number of candies is
multipled by one and they sum up to 200, the number of rows will be
200.</p>
<hr/>
<h5>Difficulty: ⭐️⭐️⭐️⭐️</h5>
<p>
</p>
<p>The average score on this problem was 39%.</p>
</div>
</div>
</div>
</div>
<hr />
<h2 id="problem-10">Problem 10</h2>
<p>Recall that we have the complete set of currently available discounts
in the DataFrame <code>offers</code>.</p>
<p>The DataFrame <code>with_offers</code> is created as follows.</p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode py"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>    (with_offers <span class="op">=</span> ikea.take(np.arange(<span class="dv">6</span>))</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>                       .merge(offers, left_on<span class="op">=</span><span class="st">&#39;category&#39;</span>,  </span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>                                      right_on<span class="op">=</span><span class="st">&#39;eligible_category&#39;</span>))</span></code></pre></div>
<p><br></p>
<h3 id="problem-10.1">Problem 10.1</h3>
<p>How many rows does <code>with_offers</code> have?</p>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading10_1">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse10_1" aria-expanded="true" aria-controls="collapse10_1">
Click to view the solution.
</button>
</h2>
<div id="collapse10_1" class="accordion-collapse collapse"
aria-labelledby="heading10_1" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer: </strong> 11</p>
<p>First, consider the DataFrame <code>ikea.take(np.arange(6))</code>,
which contains the first six rows of <code>ikea</code>. We know the
contents of these first six rows from the preview of the DataFrame at
the start of this exam. To merge with <code>offers</code>, we need to
look at the <code>'category'</code> of each of these six rows and see
how many rows of <code>offers</code> have the same value in the
<code>'eligible_category'</code> column.</p>
<p>The first row of <code>ikea.take(np.arange(6))</code> is a
<code>'bed'</code>. There are two <code>'bed'</code> offers, so that
will create two rows in the output DataFrame. Similarly, the second row
of <code>ikea.take(np.arange(6))</code> creates two rows in the output
DataFrame because there are two <code>'outdoor'</code> offers. The third
row creates just one row in the output, since there is only one
<code>'dresser'</code> offer. Continuing row-by-row in this way, we can
sum the number of rows created to get: <span class="math display">2+2+1+2+2+2 = 11.</span></p>
<p>Pandas Tutor is a really helpful tool to visualize the merge process.
Below is a color-coded visualization of this merge, generated by the
<a href="https://pandastutor.com/vis.html#code=import%20pandas%20as%20pd%0Aimport%20numpy%20as%20np%0Aimport%20io%0A%0Aikea%20%3D%20pd.DataFrame%28%29.assign%28product%3D%5B%22%C3%84PPLAR%C3%96%20Table%2B6%20armchairs,%20outdoor,%20brown%20stained%22,%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%22SUNDS%C3%96%20Table%2B2%20chairs,%20outdoor,%20gray/gray%22,%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%22GLADSTAD%20Upholstered%20bed,%202%20storage%20boxes,%20Kabusa%20light%20gray,%20Twin%22,%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%22HEMNES%20Daybed%20frame%20with%203%20drawers,%20white,%20Twin%22,%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%22HEMNES%206-drawer%20chest,%20white%20stain,%2042%201/2x51%205/8%22,%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%22LAPPLAND%20TV%20storage%20unit,%20white,%2072x15%203/8x57%207/8%22%5D,%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20category%3D%5B%22outdoor%22,%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%22outdoor%22,%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%22bed%22,%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%22bed%22,%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%22dresser%22,%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%22storage%22%5D,%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20price%3D%5B629,%20149,%20254,%20399,%20299,%20179%5D,%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20assembly_cost%3D%5B62,%2035,%2098,%2075,%2065,%2056%5D,%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20packages%3D%5B7,%203,%201,%201,%201,%201%5D%29.take%28%5B2,%200,%204,%205,%201,%203%5D%29.reset_index%28%29.drop%28columns%3D%22index%22%29%0Aoffers%20%3D%20pd.DataFrame%28%29.assign%28offer%3D%5B%22summer%20sale%22,%20%22summer%20sale%22,%20%22get%20organized%20promo%22,%20%22get%20organized%20promo%22,%20%22snooze%20sale%22,%20%22birthday%20coupon%22,%20%22birthday%20coupon%22,%20%22birthday%20coupon%22%5D,%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20eligible_category%20%3D%20%5B%22outdoor%22,%20%22grill%22,%20%22storage%22,%20%22dresser%22,%20%22bed%22,%20%22outdoor%22,%20%22storage%22,%20%22bed%22%5D,%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20percent_off%3D%5B15,%2015,%2010,%2010,%2020,%2015,%2015,%2015%5D%29%0Aikea.take%28np.arange%286%29%29.merge%28offers,%20left_on%3D'category',%20right_on%3D'eligible_category'%29%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%0A%0A&amp;d=2022-07-27&amp;lang=py&amp;v=v1">code
here</a>.</p>
<center><img src="../../assets/images/sp22-final/mergetutor.jpg" width="80%"/></center>
<hr/>
<h5>Difficulty: ⭐️⭐️⭐️⭐️</h5>
<p>
</p>
<p>The average score on this problem was 41%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<h3 id="problem-10.2">Problem 10.2</h3>
<p>How many rows of <code>with_offers</code> have a value of 20 in the
<code>'percent_off'</code> column?</p>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading10_2">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse10_2" aria-expanded="true" aria-controls="collapse10_2">
Click to view the solution.
</button>
</h2>
<div id="collapse10_2" class="accordion-collapse collapse"
aria-labelledby="heading10_2" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer: </strong> 2</p>
<p>There is just one offer with a value of 20 in the
<code>'percent_off'</code> column, and this corresponds to an offer on a
<code>'bed'</code>. Since there are two rows of
<code>ikea.take(np.arange(6))</code> with a <code>'category'</code> of
<code>'bed'</code>, each of these will match with the 20 percent-off
offer, creating two rows of <code>with_offers</code> with a value of 20
in the <code>'percent_off'</code> column.</p>
<p>The
<a href="https://pandastutor.com/vis.html#code=import%20pandas%20as%20pd%0Aimport%20numpy%20as%20np%0Aimport%20io%0A%0Aikea%20%3D%20pd.DataFrame%28%29.assign%28product%3D%5B%22%C3%84PPLAR%C3%96%20Table%2B6%20armchairs,%20outdoor,%20brown%20stained%22,%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%22SUNDS%C3%96%20Table%2B2%20chairs,%20outdoor,%20gray/gray%22,%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%22GLADSTAD%20Upholstered%20bed,%202%20storage%20boxes,%20Kabusa%20light%20gray,%20Twin%22,%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%22HEMNES%20Daybed%20frame%20with%203%20drawers,%20white,%20Twin%22,%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%22HEMNES%206-drawer%20chest,%20white%20stain,%2042%201/2x51%205/8%22,%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%22LAPPLAND%20TV%20storage%20unit,%20white,%2072x15%203/8x57%207/8%22%5D,%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20category%3D%5B%22outdoor%22,%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%22outdoor%22,%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%22bed%22,%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%22bed%22,%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%22dresser%22,%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%22storage%22%5D,%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20price%3D%5B629,%20149,%20254,%20399,%20299,%20179%5D,%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20assembly_cost%3D%5B62,%2035,%2098,%2075,%2065,%2056%5D,%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20packages%3D%5B7,%203,%201,%201,%201,%201%5D%29.take%28%5B2,%200,%204,%205,%201,%203%5D%29.reset_index%28%29.drop%28columns%3D%22index%22%29%0Aoffers%20%3D%20pd.DataFrame%28%29.assign%28offer%3D%5B%22summer%20sale%22,%20%22summer%20sale%22,%20%22get%20organized%20promo%22,%20%22get%20organized%20promo%22,%20%22snooze%20sale%22,%20%22birthday%20coupon%22,%20%22birthday%20coupon%22,%20%22birthday%20coupon%22%5D,%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20eligible_category%20%3D%20%5B%22outdoor%22,%20%22grill%22,%20%22storage%22,%20%22dresser%22,%20%22bed%22,%20%22outdoor%22,%20%22storage%22,%20%22bed%22%5D,%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20percent_off%3D%5B15,%2015,%2010,%2010,%2020,%2015,%2015,%2015%5D%29%0Aikea.take%28np.arange%286%29%29.merge%28offers,%20left_on%3D'category',%20right_on%3D'eligible_category'%29%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%0A%0A&amp;d=2022-07-27&amp;lang=py&amp;v=v1">visualization
from Pandas Tutor</a> below confirms our answer. The two rows with a
value of 20 in the <code>'percent_off'</code> column are both shown in
rows 0 and 2 of the output DataFrame.</p>
<center><img src="../../assets/images/sp22-final/mergetutor.jpg" width="80%"/></center>
<hr/>
<h5>Difficulty: ⭐️⭐️⭐️</h5>
<p>
</p>
<p>The average score on this problem was 70%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<h3 id="problem-10.3">Problem 10.3</h3>
<p>If you can use just one offer per product, you’d want to use the one
that saves you the most money, which we’ll call the best offer.</p>
<p><strong>True or False</strong>: The expression below evaluates to a
Series indexed by <code>'product'</code> with the name of the best offer
for each product that appears in the <code>with_offers</code>
DataFrame.</p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode py"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>with_offers.groupby(<span class="st">&#39;product&#39;</span>).<span class="bu">max</span>().get(<span class="st">&#39;offer&#39;</span>)</span></code></pre></div>
<ul class="task-list">
<li><p><input type="radio" disabled="" /> True</p></li>
<li><p><input type="radio" disabled="" /> False</p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading10_3">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse10_3" aria-expanded="true" aria-controls="collapse10_3">
Click to view the solution.
</button>
</h2>
<div id="collapse10_3" class="accordion-collapse collapse"
aria-labelledby="heading10_3" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer: </strong> False</p>
<p>Recall that <code>groupby</code> applies the aggregation function
separately to each column. Applying the <code>.max()</code> aggregate on
the <code>'offer'</code> column for each group gives the name that is
latest in alphabetical order because it contains strings, whereas
applying the <code>.max()</code> aggregate on the
<code>'percent_off'</code> column gives the largest numerical value.
These don’t necessarily go together in <code>with_offers</code>.</p>
<p>In particular, the element of
<code>with_offers.groupby('product').max().get('offer')</code>
corresponding to the LAPPLAND TV storage unit will be
<code>'get_organized_promo'</code>. This happens because the two rows of
<code>with_offers</code> corresponding to the LAPPLAND TV storage unit
have values of <code>'get_organized_promo'</code> and
<code>'birthday coupon'</code>, but <code>'get_organized_promo'</code>
is alphabetically later, so it’s considered the max by
<code>.groupby</code>. However, the <code>'birthday coupon'</code> is
actually a better offer, since it’s 15 percent off, while the
<code>'get_organized_promo'</code> is only 10 percent off. The
expression does not actually find the best offer for each product, but
instead finds the latest alphabetical offer for each product.</p>
<p>We can see this directly by looking at the output of Pandas Tutor
below, generated by
<a href="https://pandastutor.com/vis.html#code=import%20pandas%20as%20pd%0Aimport%20numpy%20as%20np%0Aimport%20io%0A%0Aikea%20%3D%20pd.DataFrame%28%29.assign%28product%3D%5B%22%C3%84PPLAR%C3%96%20Table%2B6%20armchairs,%20outdoor,%20brown%20stained%22,%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%22SUNDS%C3%96%20Table%2B2%20chairs,%20outdoor,%20gray/gray%22,%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%22GLADSTAD%20Upholstered%20bed,%202%20storage%20boxes,%20Kabusa%20light%20gray,%20Twin%22,%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%22HEMNES%20Daybed%20frame%20with%203%20drawers,%20white,%20Twin%22,%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%22HEMNES%206-drawer%20chest,%20white%20stain,%2042%201/2x51%205/8%22,%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%22LAPPLAND%20TV%20storage%20unit,%20white,%2072x15%203/8x57%207/8%22%5D,%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20category%3D%5B%22outdoor%22,%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%22outdoor%22,%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%22bed%22,%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%22bed%22,%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%22dresser%22,%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%22storage%22%5D,%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20price%3D%5B629,%20149,%20254,%20399,%20299,%20179%5D,%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20assembly_cost%3D%5B62,%2035,%2098,%2075,%2065,%2056%5D,%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20packages%3D%5B7,%203,%201,%201,%201,%201%5D%29.take%28%5B2,%200,%204,%205,%201,%203%5D%29.reset_index%28%29.drop%28columns%3D%22index%22%29%0Aoffers%20%3D%20pd.DataFrame%28%29.assign%28offer%3D%5B%22summer%20sale%22,%20%22summer%20sale%22,%20%22get%20organized%20promo%22,%20%22get%20organized%20promo%22,%20%22snooze%20sale%22,%20%22birthday%20coupon%22,%20%22birthday%20coupon%22,%20%22birthday%20coupon%22%5D,%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20eligible_category%20%3D%20%5B%22outdoor%22,%20%22grill%22,%20%22storage%22,%20%22dresser%22,%20%22bed%22,%20%22outdoor%22,%20%22storage%22,%20%22bed%22%5D,%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20percent_off%3D%5B15,%2015,%2010,%2010,%2020,%2015,%2015,%2015%5D%29%0Awith_offers%20%3D%20ikea.take%28np.arange%286%29%29.merge%28offers,%20left_on%3D'category',%20right_on%3D'eligible_category'%29%0Awith_offers.groupby%28'product'%29.max%28%29.get%28'offer'%29%0A%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%0A%0A&amp;d=2022-07-27&amp;lang=py&amp;v=v1">this
code</a>.</p>
<center><img src="../../assets/images/sp22-final/maxtutor.jpg" width="80%"/></center>
<hr/>
<h5>Difficulty: ⭐️⭐️⭐️</h5>
<p>
</p>
<p>The average score on this problem was 69%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<h3 id="problem-10.4">Problem 10.4</h3>
<p>You want to add a column to <code>with_offers</code> containing the
price after the offer discount is applied.</p>
<div class="sourceCode" id="cb12"><pre
class="sourceCode py"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>with_offers <span class="op">=</span> with_offers.assign(after_price <span class="op">=</span> _________)</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>with_offers</span></code></pre></div>
<p>Which of the following could go in the blank? Select all that
apply.</p>
<ul class="task-list">
<li><p><input type="checkbox" disabled="" /> <code>with_offers.get('price') - with_offers.get('percent_off')/100</code></p></li>
<li><p><input type="checkbox" disabled="" /> <code>with_offers.get('price')*(100 - with_offers.get('percent_off'))/100</code></p></li>
<li><p><input type="checkbox" disabled="" /> <code>with_offers.get('price') - with_offers.get('price')*with_offers.get('percent_off')/100</code></p></li>
<li><p><input type="checkbox" disabled="" /> <code>with_offers.get('price')*(100 - with_offers.get('percent_off')/100)</code></p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading10_4">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse10_4" aria-expanded="true" aria-controls="collapse10_4">
Click to view the solution.
</button>
</h2>
<div id="collapse10_4" class="accordion-collapse collapse"
aria-labelledby="heading10_4" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer: </strong>
<code>with_offers.get('price')*(100 - with_offers.get('percent_off'))/100</code>,
<code>(with_offers.get('price') - with_offers.get('price')*with_offers.get('percent_off')/100)</code></p>
<p>Notice that all the answer choices use
<code>with_offers.get('price')</code>, which is a Series of prices, and
<code>with_offers.get('percent_off')</code>, which is a Series of
associated percentages off. Using Series arithmetic, which works
element-wise, the goal is to create a Series of prices after the
discount is applied.</p>
<p>For example, the first row of <code>with_offers</code> corresponds to
an item with a price of 254 dollars, and a discount of 20 percent off,
coming from the snooze sale. This means its price after the discount
should be 80 percent of the original value, which is <span class="math inline">254*0.8 = 203.2</span> dollars.</p>
<p>Let’s go through each answer in order, working with this example.</p>
<p>The first answer choice takes the price and subtracts the percent off
divided by 100. For our example, this would compute the discounted price
as <span class="math inline">254 - 20/100 = 253.8</span> dollars, which
is incorrect.</p>
<p>The second answer choice multiplies the price by the quantity 100
minus the percent off, then divides by 100. This works because when we
subtract the percent off from 100 and divide by 100, the result
represents the proportion or fraction of the cost we must pay, and so
multiplying by the price gives the price after the discount. For our
example, this comes out to <span class="math inline">254*(100-20)/100=
203.2</span> dollars, which is correct.</p>
<p>The third answer choice is also correct. This corresponds to taking
the original price and subtracting from it the dollar amount off, which
comes from multiplying the price by the percent off and dividing by 100.
For our example, this would be computed as <span class="math inline">254
- 254*20/100 = 203.2</span> dollars, which is correct.</p>
<p>The fourth answer multiplies the price by the quantity 100 minus the
percent off divided by 100. For our example, this would compute the
discounted price as <span class="math inline">254*(100 - 20/100) =
25349.2</span> dollars, a number that’s nearly one hundred times the
original price!</p>
<p>Therefore, only the second and third answer choices are correct.</p>
<hr/>
<h5>Difficulty: ⭐️⭐️</h5>
<p>
</p>
<p>The average score on this problem was 79%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<hr />
<h2 id="problem-11">Problem 11</h2>
<p>For each offer currently available, the DataFrame <code>offers</code>
has a separate row for each category of products to which the offer can
be applied. The columns are:</p>
<ul>
<li><code>'offer'</code> (<code>str</code>): the name of the offer</li>
<li><code>'category'</code> (<code>str</code>): the category to which
the offer applies</li>
<li><code>'percent_off'</code> (<code>int</code>): the percent discount
when applying this offer to this category</li>
</ul>
<p>The full <code>offers</code> DataFrame is shown below. All rows are
pictured.</p>
<center><img src='../../assets/images/sp22-final/offersdf.png' height=270></center>
<p><br></p>
<p>The DataFrame <code>with_offers</code> is created as follows.</p>
<div class="sourceCode" id="cb13"><pre
class="sourceCode py"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>    (with_offers <span class="op">=</span> ikea.take(np.arange(<span class="dv">6</span>))</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>                       .merge(offers, left_on<span class="op">=</span><span class="st">&#39;category&#39;</span>,  </span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>                                      right_on<span class="op">=</span><span class="st">&#39;eligible_category&#39;</span>))</span></code></pre></div>
<p><br></p>
<h3 id="problem-11.1">Problem 11.1</h3>
<p>How many rows does <code>with_offers</code> have?</p>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading11_1">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse11_1" aria-expanded="true" aria-controls="collapse11_1">
Click to view the solution.
</button>
</h2>
<div id="collapse11_1" class="accordion-collapse collapse"
aria-labelledby="heading11_1" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer: </strong> 11</p>
<p>First, consider the DataFrame <code>ikea.take(np.arange(6))</code>,
which contains the first six rows of <code>ikea</code>. We know the
contents of these first six rows from the preview of the DataFrame at
the start of this exam. To merge with <code>offers</code>, we need to
look at the <code>'category'</code> of each of these six rows and see
how many rows of <code>offers</code> have the same value in the
<code>'eligible_category'</code> column.</p>
<p>The first row of <code>ikea.take(np.arange(6))</code> is a
<code>'bed'</code>. There are two <code>'bed'</code> offers, so that
will create two rows in the output DataFrame. Similarly, the second row
of <code>ikea.take(np.arange(6))</code> creates two rows in the output
DataFrame because there are two <code>'outdoor'</code> offers. The third
row creates just one row in the output, since there is only one
<code>'dresser'</code> offer. Continuing row-by-row in this way, we can
sum the number of rows created to get: <span class="math display">2+2+1+2+2+2 = 11.</span></p>
<p>Pandas Tutor is a really helpful tool to visualize the merge process.
Below is a color-coded visualization of this merge, generated by the
<a href="https://pandastutor.com/vis.html#code=import%20pandas%20as%20pd%0Aimport%20numpy%20as%20np%0Aimport%20io%0A%0Aikea%20%3D%20pd.DataFrame%28%29.assign%28product%3D%5B%22%C3%84PPLAR%C3%96%20Table%2B6%20armchairs,%20outdoor,%20brown%20stained%22,%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%22SUNDS%C3%96%20Table%2B2%20chairs,%20outdoor,%20gray/gray%22,%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%22GLADSTAD%20Upholstered%20bed,%202%20storage%20boxes,%20Kabusa%20light%20gray,%20Twin%22,%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%22HEMNES%20Daybed%20frame%20with%203%20drawers,%20white,%20Twin%22,%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%22HEMNES%206-drawer%20chest,%20white%20stain,%2042%201/2x51%205/8%22,%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%22LAPPLAND%20TV%20storage%20unit,%20white,%2072x15%203/8x57%207/8%22%5D,%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20category%3D%5B%22outdoor%22,%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%22outdoor%22,%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%22bed%22,%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%22bed%22,%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%22dresser%22,%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%22storage%22%5D,%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20price%3D%5B629,%20149,%20254,%20399,%20299,%20179%5D,%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20assembly_cost%3D%5B62,%2035,%2098,%2075,%2065,%2056%5D,%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20packages%3D%5B7,%203,%201,%201,%201,%201%5D%29.take%28%5B2,%200,%204,%205,%201,%203%5D%29.reset_index%28%29.drop%28columns%3D%22index%22%29%0Aoffers%20%3D%20pd.DataFrame%28%29.assign%28offer%3D%5B%22summer%20sale%22,%20%22summer%20sale%22,%20%22get%20organized%20promo%22,%20%22get%20organized%20promo%22,%20%22snooze%20sale%22,%20%22birthday%20coupon%22,%20%22birthday%20coupon%22,%20%22birthday%20coupon%22%5D,%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20eligible_category%20%3D%20%5B%22outdoor%22,%20%22grill%22,%20%22storage%22,%20%22dresser%22,%20%22bed%22,%20%22outdoor%22,%20%22storage%22,%20%22bed%22%5D,%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20percent_off%3D%5B15,%2015,%2010,%2010,%2020,%2015,%2015,%2015%5D%29%0Aikea.take%28np.arange%286%29%29.merge%28offers,%20left_on%3D'category',%20right_on%3D'eligible_category'%29%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%0A%0A&amp;d=2022-07-27&amp;lang=py&amp;v=v1">code
here</a>.</p>
<center><img src="../../assets/images/sp22-final/mergetutor.jpg" width="80%"/></center>
<hr/>
<h5>Difficulty: ⭐️⭐️⭐️⭐️</h5>
<p>
</p>
<p>The average score on this problem was 41%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<h3 id="problem-11.2">Problem 11.2</h3>
<p>How many rows of <code>with_offers</code> have a value of 20 in the
<code>'percent_off'</code> column?</p>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading11_2">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse11_2" aria-expanded="true" aria-controls="collapse11_2">
Click to view the solution.
</button>
</h2>
<div id="collapse11_2" class="accordion-collapse collapse"
aria-labelledby="heading11_2" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer: </strong> 2</p>
<p>There is just one offer with a value of 20 in the
<code>'percent_off'</code> column, and this corresponds to an offer on a
<code>'bed'</code>. Since there are two rows of
<code>ikea.take(np.arange(6))</code> with a <code>'category'</code> of
<code>'bed'</code>, each of these will match with the 20 percent-off
offer, creating two rows of <code>with_offers</code> with a value of 20
in the <code>'percent_off'</code> column.</p>
<p>The
<a href="https://pandastutor.com/vis.html#code=import%20pandas%20as%20pd%0Aimport%20numpy%20as%20np%0Aimport%20io%0A%0Aikea%20%3D%20pd.DataFrame%28%29.assign%28product%3D%5B%22%C3%84PPLAR%C3%96%20Table%2B6%20armchairs,%20outdoor,%20brown%20stained%22,%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%22SUNDS%C3%96%20Table%2B2%20chairs,%20outdoor,%20gray/gray%22,%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%22GLADSTAD%20Upholstered%20bed,%202%20storage%20boxes,%20Kabusa%20light%20gray,%20Twin%22,%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%22HEMNES%20Daybed%20frame%20with%203%20drawers,%20white,%20Twin%22,%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%22HEMNES%206-drawer%20chest,%20white%20stain,%2042%201/2x51%205/8%22,%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%22LAPPLAND%20TV%20storage%20unit,%20white,%2072x15%203/8x57%207/8%22%5D,%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20category%3D%5B%22outdoor%22,%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%22outdoor%22,%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%22bed%22,%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%22bed%22,%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%22dresser%22,%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%22storage%22%5D,%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20price%3D%5B629,%20149,%20254,%20399,%20299,%20179%5D,%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20assembly_cost%3D%5B62,%2035,%2098,%2075,%2065,%2056%5D,%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20packages%3D%5B7,%203,%201,%201,%201,%201%5D%29.take%28%5B2,%200,%204,%205,%201,%203%5D%29.reset_index%28%29.drop%28columns%3D%22index%22%29%0Aoffers%20%3D%20pd.DataFrame%28%29.assign%28offer%3D%5B%22summer%20sale%22,%20%22summer%20sale%22,%20%22get%20organized%20promo%22,%20%22get%20organized%20promo%22,%20%22snooze%20sale%22,%20%22birthday%20coupon%22,%20%22birthday%20coupon%22,%20%22birthday%20coupon%22%5D,%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20eligible_category%20%3D%20%5B%22outdoor%22,%20%22grill%22,%20%22storage%22,%20%22dresser%22,%20%22bed%22,%20%22outdoor%22,%20%22storage%22,%20%22bed%22%5D,%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20percent_off%3D%5B15,%2015,%2010,%2010,%2020,%2015,%2015,%2015%5D%29%0Aikea.take%28np.arange%286%29%29.merge%28offers,%20left_on%3D'category',%20right_on%3D'eligible_category'%29%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%0A%0A&amp;d=2022-07-27&amp;lang=py&amp;v=v1">visualization
from Pandas Tutor</a> below confirms our answer. The two rows with a
value of 20 in the <code>'percent_off'</code> column are both shown in
rows 0 and 2 of the output DataFrame.</p>
<center><img src="../../assets/images/sp22-final/mergetutor.jpg" width="80%"/></center>
<hr/>
<h5>Difficulty: ⭐️⭐️⭐️</h5>
<p>
</p>
<p>The average score on this problem was 70%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<h3 id="problem-11.3">Problem 11.3</h3>
<p>If you can use just one offer per product, you’d want to use the one
that saves you the most money, which we’ll call the best offer.</p>
<p><strong>True or False</strong>: The expression below evaluates to a
Series indexed by <code>'product'</code> with the name of the best offer
for each product that appears in the <code>with_offers</code>
DataFrame.</p>
<div class="sourceCode" id="cb14"><pre
class="sourceCode py"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>with_offers.groupby(<span class="st">&#39;product&#39;</span>).<span class="bu">max</span>().get(<span class="st">&#39;offer&#39;</span>)</span></code></pre></div>
<ul class="task-list">
<li><p><input type="radio" disabled="" /> True</p></li>
<li><p><input type="radio" disabled="" /> False</p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading11_3">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse11_3" aria-expanded="true" aria-controls="collapse11_3">
Click to view the solution.
</button>
</h2>
<div id="collapse11_3" class="accordion-collapse collapse"
aria-labelledby="heading11_3" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer: </strong> False</p>
<p>Recall that <code>groupby</code> applies the aggregation function
separately to each column. Applying the <code>.max()</code> aggregate on
the <code>'offer'</code> column for each group gives the name that is
latest in alphabetical order because it contains strings, whereas
applying the <code>.max()</code> aggregate on the
<code>'percent_off'</code> column gives the largest numerical value.
These don’t necessarily go together in <code>with_offers</code>.</p>
<p>In particular, the element of
<code>with_offers.groupby('product').max().get('offer')</code>
corresponding to the LAPPLAND TV storage unit will be
<code>'get_organized_promo'</code>. This happens because the two rows of
<code>with_offers</code> corresponding to the LAPPLAND TV storage unit
have values of <code>'get_organized_promo'</code> and
<code>'birthday coupon'</code>, but <code>'get_organized_promo'</code>
is alphabetically later, so it’s considered the max by
<code>.groupby</code>. However, the <code>'birthday coupon'</code> is
actually a better offer, since it’s 15 percent off, while the
<code>'get_organized_promo'</code> is only 10 percent off. The
expression does not actually find the best offer for each product, but
instead finds the latest alphabetical offer for each product.</p>
<p>We can see this directly by looking at the output of Pandas Tutor
below, generated by
<a href="https://pandastutor.com/vis.html#code=import%20pandas%20as%20pd%0Aimport%20numpy%20as%20np%0Aimport%20io%0A%0Aikea%20%3D%20pd.DataFrame%28%29.assign%28product%3D%5B%22%C3%84PPLAR%C3%96%20Table%2B6%20armchairs,%20outdoor,%20brown%20stained%22,%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%22SUNDS%C3%96%20Table%2B2%20chairs,%20outdoor,%20gray/gray%22,%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%22GLADSTAD%20Upholstered%20bed,%202%20storage%20boxes,%20Kabusa%20light%20gray,%20Twin%22,%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%22HEMNES%20Daybed%20frame%20with%203%20drawers,%20white,%20Twin%22,%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%22HEMNES%206-drawer%20chest,%20white%20stain,%2042%201/2x51%205/8%22,%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%22LAPPLAND%20TV%20storage%20unit,%20white,%2072x15%203/8x57%207/8%22%5D,%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20category%3D%5B%22outdoor%22,%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%22outdoor%22,%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%22bed%22,%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%22bed%22,%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%22dresser%22,%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%22storage%22%5D,%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20price%3D%5B629,%20149,%20254,%20399,%20299,%20179%5D,%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20assembly_cost%3D%5B62,%2035,%2098,%2075,%2065,%2056%5D,%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20packages%3D%5B7,%203,%201,%201,%201,%201%5D%29.take%28%5B2,%200,%204,%205,%201,%203%5D%29.reset_index%28%29.drop%28columns%3D%22index%22%29%0Aoffers%20%3D%20pd.DataFrame%28%29.assign%28offer%3D%5B%22summer%20sale%22,%20%22summer%20sale%22,%20%22get%20organized%20promo%22,%20%22get%20organized%20promo%22,%20%22snooze%20sale%22,%20%22birthday%20coupon%22,%20%22birthday%20coupon%22,%20%22birthday%20coupon%22%5D,%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20eligible_category%20%3D%20%5B%22outdoor%22,%20%22grill%22,%20%22storage%22,%20%22dresser%22,%20%22bed%22,%20%22outdoor%22,%20%22storage%22,%20%22bed%22%5D,%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20percent_off%3D%5B15,%2015,%2010,%2010,%2020,%2015,%2015,%2015%5D%29%0Awith_offers%20%3D%20ikea.take%28np.arange%286%29%29.merge%28offers,%20left_on%3D'category',%20right_on%3D'eligible_category'%29%0Awith_offers.groupby%28'product'%29.max%28%29.get%28'offer'%29%0A%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%0A%0A&amp;d=2022-07-27&amp;lang=py&amp;v=v1">this
code</a>.</p>
<center><img src="../../assets/images/sp22-final/maxtutor.jpg" width="80%"/></center>
<hr/>
<h5>Difficulty: ⭐️⭐️⭐️</h5>
<p>
</p>
<p>The average score on this problem was 69%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<h3 id="problem-11.4">Problem 11.4</h3>
<p>You want to add a column to <code>with_offers</code> containing the
price after the offer discount is applied.</p>
<div class="sourceCode" id="cb15"><pre
class="sourceCode py"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>with_offers <span class="op">=</span> with_offers.assign(after_price <span class="op">=</span> _________)</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>with_offers</span></code></pre></div>
<p>Which of the following could go in the blank? Select all that
apply.</p>
<ul class="task-list">
<li><p><input type="checkbox" disabled="" /> <code>with_offers.get('price') - with_offers.get('percent_off')/100</code></p></li>
<li><p><input type="checkbox" disabled="" /> <code>with_offers.get('price')*(100 - with_offers.get('percent_off'))/100</code></p></li>
<li><p><input type="checkbox" disabled="" /> <code>with_offers.get('price') - with_offers.get('price')*with_offers.get('percent_off')/100</code></p></li>
<li><p><input type="checkbox" disabled="" /> <code>with_offers.get('price')*(100 - with_offers.get('percent_off')/100)</code></p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading11_4">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse11_4" aria-expanded="true" aria-controls="collapse11_4">
Click to view the solution.
</button>
</h2>
<div id="collapse11_4" class="accordion-collapse collapse"
aria-labelledby="heading11_4" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer: </strong>
<code>with_offers.get('price')*(100 - with_offers.get('percent_off'))/100</code>,
<code>(with_offers.get('price') - with_offers.get('price')*with_offers.get('percent_off')/100)</code></p>
<p>Notice that all the answer choices use
<code>with_offers.get('price')</code>, which is a Series of prices, and
<code>with_offers.get('percent_off')</code>, which is a Series of
associated percentages off. Using Series arithmetic, which works
element-wise, the goal is to create a Series of prices after the
discount is applied.</p>
<p>For example, the first row of <code>with_offers</code> corresponds to
an item with a price of 254 dollars, and a discount of 20 percent off,
coming from the snooze sale. This means its price after the discount
should be 80 percent of the original value, which is <span class="math inline">254*0.8 = 203.2</span> dollars.</p>
<p>Let’s go through each answer in order, working with this example.</p>
<p>The first answer choice takes the price and subtracts the percent off
divided by 100. For our example, this would compute the discounted price
as <span class="math inline">254 - 20/100 = 253.8</span> dollars, which
is incorrect.</p>
<p>The second answer choice multiplies the price by the quantity 100
minus the percent off, then divides by 100. This works because when we
subtract the percent off from 100 and divide by 100, the result
represents the proportion or fraction of the cost we must pay, and so
multiplying by the price gives the price after the discount. For our
example, this comes out to <span class="math inline">254*(100-20)/100=
203.2</span> dollars, which is correct.</p>
<p>The third answer choice is also correct. This corresponds to taking
the original price and subtracting from it the dollar amount off, which
comes from multiplying the price by the percent off and dividing by 100.
For our example, this would be computed as <span class="math inline">254
- 254*20/100 = 203.2</span> dollars, which is correct.</p>
<p>The fourth answer multiplies the price by the quantity 100 minus the
percent off divided by 100. For our example, this would compute the
discounted price as <span class="math inline">254*(100 - 20/100) =
25349.2</span> dollars, a number that’s nearly one hundred times the
original price!</p>
<p>Therefore, only the second and third answer choices are correct.</p>
<hr/>
<h5>Difficulty: ⭐️⭐️</h5>
<p>
</p>
<p>The average score on this problem was 79%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<hr />
<h2 id="problem-12">Problem 12</h2>
<p>Fill in the blank in the code below so that
<code>chronological</code> is a DataFrame with the same rows as
<code>sungod</code>, but ordered chronologically by appearance on stage.
That is, earlier years should come before later years, and within a
single year, artists should appear in the DataFrame in the order they
appeared on stage at Sun God. Note that <code>groupby</code>
automatically sorts the index in ascending order.</p>
<div class="sourceCode" id="cb16"><pre
class="sourceCode py"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>chronological <span class="op">=</span> sungod.groupby(___________).<span class="bu">max</span>().reset_index()</span></code></pre></div>
<ul class="task-list">
<li><p><input type="radio" disabled="" /> <code>['Year', 'Artist', 'Appearance_Order']</code></p></li>
<li><p><input type="radio" disabled="" /> <code>['Year', 'Appearance_Order']</code></p></li>
<li><p><input type="radio" disabled="" /> <code>['Appearance_Order', 'Year']</code></p></li>
<li><p><input type="radio" disabled="" /> None of the above.</p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading12">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse12" aria-expanded="true" aria-controls="collapse12">
Click to view the solution.
</button>
</h2>
<div id="collapse12" class="accordion-collapse collapse"
aria-labelledby="heading12" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer: </strong>
<code>['Year', 'Appearance_Order']</code></p>
<p>The fact that <code>groupby</code> automatically sorts the index in
ascending order is important here. Since we want earlier years before
later years, we could group by <code>'Year'</code>, however if we
<em>just</em> group by year, all the artists who performed in a given
year will be aggregated together, which is not what we want. Within each
year, we want to organize the artists in ascending order of
<code>'Appearance_Order'</code>. In other words, we need to group by
<code>'Year'</code> with <code>'Appearance_Order'</code> as subgroups.
Therefore, the correct way to reorder the rows of <code>sungod</code> as
desired is
<code>sungod.groupby(['Year', 'Appearance_Order']).max().reset_index()</code>.
Note that we need to reset the index so that the resulting DataFrame has
<code>'Year'</code> and <code>'Appearance_Order'</code> as columns, like
in <code>sungod</code>.</p>
<hr/>
<h5>Difficulty: ⭐️⭐️</h5>
<p>
</p>
<p>The average score on this problem was 85%.</p>
</div>
</div>
</div>
</div>
<hr />
<h2 id="problem-13">Problem 13</h2>
<p>Another DataFrame called <code>music</code> contains a row for every
music artist that has ever released a song. The columns are:</p>
<ul>
<li><code>'Name'</code> (<code>str</code>): the name of the music
artist</li>
<li><code>'Genre'</code> (<code>str</code>): the primary genre of the
artist</li>
<li><code>'Top_Hit'</code> (<code>str</code>): the most popular song by
that artist, based on sales, radio play, and streaming</li>
<li><code>'Top_Hit_Year'</code> (<code>int</code>): the year in which
the top hit song was released</li>
</ul>
<p>You want to know how many musical genres have been represented at Sun
God since its inception in 1983. Which of the following expressions
produces a DataFrame called <code>merged</code> that could help
determine the answer?</p>
<ul class="task-list">
<li><p><input type="radio" disabled="" /> <code>merged = sungod.merge(music, left_on='Year', right_on='Top_Hit_Year')</code></p></li>
<li><p><input type="radio" disabled="" /> <code>merged = music.merge(sungod, left_on='Year', right_on='Top_Hit_Year')</code></p></li>
<li><p><input type="radio" disabled="" /> <code>merged = sungod.merge(music, left_on='Artist', right_on='Name')</code></p></li>
<li><p><input type="radio" disabled="" /> <code>merged = music.merge(sungod, left_on='Artist', right_on='Name')</code></p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading13">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse13" aria-expanded="true" aria-controls="collapse13">
Click to view the solution.
</button>
</h2>
<div id="collapse13" class="accordion-collapse collapse"
aria-labelledby="heading13" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer: </strong>
<code>merged = sungod.merge(music, left_on='Artist', right_on='Name')</code></p>
<p>The question we want to answer is about Sun God music artists’
genres. In order to answer, we’ll need a DataFrame consisting of rows of
artists that have performed at Sun God since its inception in 1983. If
we merge the <code>sungod</code> DataFrame with the <code>music</code>
DataFrame based on the artist’s name, we’ll end up with a DataFrame
containing one row for each artist that has ever performed at Sun God.
Since the column containing artists’ names is called
<code>'Artist'</code> in <code>sungod</code> and <code>'Name'</code> in
<code>music</code>, the correct syntax for this merge is
<code>merged = sungod.merge(music, left_on='Artist', right_on='Name')</code>.
Note that we could also interchange the left DataFrame with the right
DataFrame, as swapping the roles of the two DataFrames in a merge only
changes the ordering of rows and columns in the output, not the data
itself. This can be written in code as
<code>merged = music.merge(sungod, left_on='Name', right_on='Artist')</code>,
but this is not one of the answer choices.</p>
<hr/>
<h5>Difficulty: ⭐️⭐️</h5>
<p>
</p>
<p>The average score on this problem was 86%.</p>
</div>
</div>
</div>
</div>
<hr />
<h2 id="problem-14">Problem 14</h2>
<p>In the next few parts, consider the following answer choices.</p>
<ol type="A">
<li><p>The name of the country with the most cities.</p></li>
<li><p>The name of the country with the fewest cities.</p></li>
<li><p>The number of cities in the country with the most
cities.</p></li>
<li><p>The number of cities in the country with the fewest
cities.</p></li>
<li><p>The last city, alphabetically, in the first country,
alphabetically.</p></li>
<li><p>The first city, alphabetically, in the first country,
alphabetically.</p></li>
<li><p>Nothing, because it errors.</p></li>
</ol>
<p><br></p>
<h3 id="problem-14.1">Problem 14.1</h3>
<p>What does the following expression evaluate to?</p>
<div class="sourceCode" id="cb17"><pre
class="sourceCode py"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>sun.groupby(<span class="st">&quot;Country&quot;</span>).<span class="bu">max</span>().get(<span class="st">&quot;City&quot;</span>).iloc[<span class="dv">0</span>]</span></code></pre></div>
<ul class="task-list">
<li><p><input type="radio" disabled="" /> A</p></li>
<li><p><input type="radio" disabled="" /> B</p></li>
<li><p><input type="radio" disabled="" /> C</p></li>
<li><p><input type="radio" disabled="" /> D</p></li>
<li><p><input type="radio" disabled="" /> E</p></li>
<li><p><input type="radio" disabled="" /> F</p></li>
<li><p><input type="radio" disabled="" /> G</p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading14_1">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse14_1" aria-expanded="true" aria-controls="collapse14_1">
Click to view the solution.
</button>
</h2>
<div id="collapse14_1" class="accordion-collapse collapse"
aria-labelledby="heading14_1" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer</strong>: E. The last city, alphabetically, in the
first country, alphabetically.<br/>
</p>
<p>Let’s break down the code:</p>
<ul>
<li><p><code>sun.groupby("Country").max()</code>: This line of code
groups the <code>sun</code> DataFrame by the <code>"Country"</code>
column and then determines the <strong>maximum</strong> for every other
column within each country group. Since the values in the
<code>"City"</code> column are stored as strings, and the maximum of a
Series of strings is the last string alphabetically, the values in the
<code>"City"</code> column of this DataFrame will contain the last city,
alphabetically, of each country.</p></li>
<li><p><code>.get("City")</code>: <code>.get("City")</code> accesses the
<code>"City"</code> column.</p></li>
<li><p><code>.iloc[0]</code>: Finally, <code>.iloc[0]</code> selects the
<code>"City"</code> value from the first row. The first row corresponds
to the first country alphabetically because <code>groupby</code> sorted
the DataFrame by <code>"Country"</code> in ascending order. The value in
the <code>"City"</code> column that <code>.iloc[0]</code> selects, then,
is the name of the last city, alphabetically, in the first country,
alphabetically.</p></li>
</ul>
<hr/>
<h5>Difficulty: ⭐️⭐️⭐️⭐️</h5>
<p>
</p>
<p>The average score on this problem was 36%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<p><br></p>
<h3 id="problem-14.2">Problem 14.2</h3>
<p>What does the following expression evaluate to?</p>
<div class="sourceCode" id="cb18"><pre
class="sourceCode py"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>sun.groupby(<span class="st">&quot;Country&quot;</span>).<span class="bu">sum</span>().get(<span class="st">&quot;City&quot;</span>).iloc[<span class="dv">0</span>]</span></code></pre></div>
<ul class="task-list">
<li><p><input type="radio" disabled="" /> A</p></li>
<li><p><input type="radio" disabled="" /> B</p></li>
<li><p><input type="radio" disabled="" /> C</p></li>
<li><p><input type="radio" disabled="" /> D</p></li>
<li><p><input type="radio" disabled="" /> E</p></li>
<li><p><input type="radio" disabled="" /> F</p></li>
<li><p><input type="radio" disabled="" /> G</p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading14_2">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse14_2" aria-expanded="true" aria-controls="collapse14_2">
Click to view the solution.
</button>
</h2>
<div id="collapse14_2" class="accordion-collapse collapse"
aria-labelledby="heading14_2" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer</strong>: G. Nothing, because it errors.<br/>
</p>
<p>Let’s break down the code:</p>
<ul>
<li><p><code>sun.groupby("Country").sum()</code>: This groups the
<code>sun</code> DataFrame by the <code>"Country"</code> column and
computes the sum for each numeric column within each country group.
Since <code>"City"</code> is non-numeric, it will be dropped.</p></li>
<li><p><code>.get("City")</code>: This operation attempts to retrieve
the <code>"City"</code> column from the resulting DataFrame. However,
since the <code>"City"</code> column was dropped in the previous step,
this will raise a KeyError, indicating that the column is not present in
the DataFrame.</p></li>
</ul>
<hr/>
<h5>Difficulty: ⭐️⭐️⭐️</h5>
<p>
</p>
<p>The average score on this problem was 73%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<p><br></p>
<h3 id="problem-14.3">Problem 14.3</h3>
<p>What does the following expression evaluate to?</p>
<div class="sourceCode" id="cb19"><pre
class="sourceCode py"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>sun.groupby(<span class="st">&quot;Country&quot;</span>).count().sort_values(<span class="st">&quot;Jan&quot;</span>).index[<span class="op">-</span><span class="dv">1</span>]</span></code></pre></div>
<ul class="task-list">
<li><p><input type="radio" disabled="" /> A</p></li>
<li><p><input type="radio" disabled="" /> B</p></li>
<li><p><input type="radio" disabled="" /> C</p></li>
<li><p><input type="radio" disabled="" /> D</p></li>
<li><p><input type="radio" disabled="" /> E</p></li>
<li><p><input type="radio" disabled="" /> F</p></li>
<li><p><input type="radio" disabled="" /> G</p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading14_3">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse14_3" aria-expanded="true" aria-controls="collapse14_3">
Click to view the solution.
</button>
</h2>
<div id="collapse14_3" class="accordion-collapse collapse"
aria-labelledby="heading14_3" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer</strong>: A. The name of the country with the most
cities.<br/>
</p>
<p>Let’s break down the code:</p>
<ul>
<li><p><code>sun.groupby("Country").count()</code>: This groups the sun
DataFrame by the <code>"Country"</code> column. The
<code>.count()</code> method then returns the number of rows in each
group for each column. Since we’re grouping by <code>"Country"</code>,
and since the rows in <code>sun</code> correspond to cities, this is
counting the number of cities in each country.</p></li>
<li><p><code>.sort_values("Jan")</code>: The result of the previous
operation is a DataFrame with <code>"Country"</code> as the index and
the number of cities per country stored in every other column. The
<code>"City</code>, <code>"Jan"</code>, <code>"Feb"</code>,
<code>"Mar"</code>, etc. columns in the resulting DataFrame all contain
the same information. Sorting by <code>"Jan"</code> sorts the DataFrame
by the number of cities each country has in ascending order.</p></li>
<li><p><code>.index[-1]</code>: This retrieves the last index value from
the sorted DataFrame, which corresponds to the name of the country with
the most cities.</p></li>
</ul>
<hr/>
<h5>Difficulty: ⭐️⭐️⭐️</h5>
<p>
</p>
<p>The average score on this problem was 61%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<h3 id="problem-14.4">Problem 14.4</h3>
<p>What does the following expression evaluate to?</p>
<div class="sourceCode" id="cb20"><pre
class="sourceCode py"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>sun.groupby(<span class="st">&quot;Country&quot;</span>).count().sort_values(<span class="st">&quot;City&quot;</span>).get(<span class="st">&quot;City&quot;</span>).iloc[<span class="op">-</span><span class="dv">1</span>]</span></code></pre></div>
<ul class="task-list">
<li><p><input type="radio" disabled="" /> A</p></li>
<li><p><input type="radio" disabled="" /> B</p></li>
<li><p><input type="radio" disabled="" /> C</p></li>
<li><p><input type="radio" disabled="" /> D</p></li>
<li><p><input type="radio" disabled="" /> E</p></li>
<li><p><input type="radio" disabled="" /> F</p></li>
<li><p><input type="radio" disabled="" /> G</p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading14_4">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse14_4" aria-expanded="true" aria-controls="collapse14_4">
Click to view the solution.
</button>
</h2>
<div id="collapse14_4" class="accordion-collapse collapse"
aria-labelledby="heading14_4" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer</strong>: C. The number of cities in the country with
the most cities.<br/>
</p>
<p>Let’s break down the code:</p>
<ul>
<li><p><code>sun.groupby("Country").count()</code>: This groups the sun
DataFrame by the <code>"Country"</code> column. The
<code>.count()</code> method then returns the number of rows in each
group for each column. Since we’re grouping by <code>"Country"</code>,
and since the rows in <code>sun</code> correspond to cities, this is
counting the number of cities in each country.</p></li>
<li><p><code>.sort_values("City")</code>: The result of the previous
operation is a DataFrame with <code>"Country"</code> as the index and
the number of <code>"City"</code>s per <code>"Country"</code> stored in
every other column. The <code>"City</code>, <code>"Jan"</code>,
<code>"Feb"</code>, <code>"Mar"</code>, etc. columns in the resulting
DataFrame all contain the same information. Sorting by
<code>"City"</code> sorts the DataFrame by the number of cities each
country has in ascending order.</p></li>
<li><p><code>.get("City")</code>: This retrieves the <code>"City"</code>
column from the sorted DataFrame, which contains the number of cities in
each country.</p></li>
<li><p><code>.iloc[-1]</code>: This gets the last value from the
<code>"City"</code> column, which corresponds to the number of cities in
the country with the most cities.</p></li>
</ul>
<hr/>
<h5>Difficulty: ⭐️⭐️⭐️</h5>
<p>
</p>
<p>The average score on this problem was 57%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<hr />
<h2 id="problem-15">Problem 15</h2>
<p>Vanessa is a big Formula 1 racing fan, and wants to plan a trip to
Monaco, where the Monaco Grand Prix is held. Monaco is an example of a
“city-state” — that is, a city that is its own country. Singapore is
another example of a city-state.</p>
<p>We’ll say that a row of <code>sun</code> corresponds to a city-state
if its <code>"Country"</code> and <code>"City"</code> values are
equal.</p>
<p><br></p>
<h3 id="problem-15.1">Problem 15.1</h3>
<p>Fill in the blanks so that the expression below is equal to the total
number of sunshine hours in October of all city-states in
<code>sun</code>.</p>
<div class="sourceCode" id="cb21"><pre
class="sourceCode py"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>    sun[__(a)__].__(b)__</span></code></pre></div>
<p>What goes in blanks (a) and (b)?</p>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading15_1">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse15_1" aria-expanded="true" aria-controls="collapse15_1">
Click to view the solution.
</button>
</h2>
<div id="collapse15_1" class="accordion-collapse collapse"
aria-labelledby="heading15_1" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer</strong>: (a):
<code>sun.get("Country") == sun.get("City")</code>, (b):
<code>.get("Oct").sum()</code></p>
<p><strong>What goes in blank (a)?</strong>
<code>sun.get("Country") == sun.get("City")</code><br/>
This expression compares the <code>"Country"</code> column to the
<code>"City"</code> column for each row in the <code>sun</code>
DataFrame. It returns a Boolean Series where each value is
<code>True</code> if the corresponding <code>"Country"</code> and
<code>"City"</code> are the same (indicating a city-state) and
<code>False</code> otherwise.</p>
<hr/>
<h5>Difficulty: ⭐️⭐️</h5>
<p>
</p>
<p>The average score on this problem was 79%.</p>
<p><br/><br/></p>
<p><strong>What goes in blank (b)?</strong>
<code>.get("Oct").sum()</code><br/>
Here, we select the <code>"Oct"</code> column, which represents the
sunshine hours in October, and compute the sum of its values. By using
this after querying for city-states, we calculate the total sunshine
hours in October across all city-states in the <code>sun</code>
DataFrame.</p>
<hr/>
<h5>Difficulty: ⭐️⭐️</h5>
<p>
</p>
<p>The average score on this problem was 85%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<hr />
<p class="meta"><em>Source:</em> sp23-final — Q1</p>
<h2 id="problem-16">Problem 16</h2>
<p><br></p>
<h3 id="problem-16.1">Problem 16.1</h3>
<p>Complete the implementation of the function
<code>most_sunshine</code>, which takes in <code>country</code>, the
name of a country, and <code>month</code>, the name of a month
(e.g. <code>"Apr"</code>), and returns the name of the city (as a
string) in <code>country</code> with the most sunshine hours in
<code>month</code>, among the cities in <code>sun</code>. Assume there
are no ties.</p>
<div class="sourceCode" id="cb22"><pre
class="sourceCode py"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> most_sunshine(country, month):</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>        country_only <span class="op">=</span> __(a)__</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> country_only.__(b)__</span></code></pre></div>
<p>What goes in blanks (a) and (b)?</p>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading16_1">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse16_1" aria-expanded="true" aria-controls="collapse16_1">
Click to view the solution.
</button>
</h2>
<div id="collapse16_1" class="accordion-collapse collapse"
aria-labelledby="heading16_1" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer</strong>: (a):
<code>sun[sun.get("Country") == country]</code>, (b):
<code>sort_values(month).get("City").iloc[-1]</code> or
<code>sort_values(month, ascending=False).get("City").iloc[0]</code></p>
<p><strong>What goes in blank (a)?</strong>
<code>sun[sun.get("Country") == country]</code> To identify cities only
within the specified country, we need to query for the rows in the
<code>sun</code> DataFrame where the <code>"Country"</code> column
matches the given <code>country</code>. The expression
<code>sun.get("Country") == country</code> creates a Boolean Series,
where each entry is <code>True</code> if the corresponding row’s
<code>"Country"</code> column matches the provided <code>country</code>
and <code>False</code> otherwise. When this Boolean series is used to
index into <code>sun</code> DataFrame, it keeps only the rows for which
<code>sun.get("Country") == country</code> is <code>True</code>,
effectively giving us only the cities from the specified country.</p>
<hr/>
<h5>Difficulty: ⭐️⭐️</h5>
<p>
</p>
<p>The average score on this problem was 78%.</p>
<p><br/><br/></p>
<p><strong>What goes in blank (b)?</strong>
<code>sort_values(month).get("City").iloc[-1]</code> or
<code>sort_values(month, ascending=False).get("City").iloc[0]</code><br/>
To determine the city with the most sunshine hours in the specified
month, we sort the queried DataFrame (which only contains cities from
the specified country) based on the values in the <code>month</code>
column. There are two ways to achieve the desired result:</p>
<ul>
<li>Sort in ascending (increasing) order and then select the last item.
This is because after sorting in ascending order, the city with the most
sunshine hours will be at the bottom of the DataFrame. We use
<code>.iloc[-1]</code> to get the last item after selecting the
<code>"City"</code> column with <code>.get("City")</code>.</li>
<li>Sort in descending order and then select the first item. After
sorting in descending order, the city with the most sunshine hours will
be at the top of the DataFrame. We use <code>.iloc[0]</code> to get the
first item after selecting the <code>"City"</code> column with
<code>.get("City")</code>.</li>
</ul>
<p>Both methods will give us the name of the city with the most sunshine
hours in the specified month.</p>
<hr/>
<h5>Difficulty: ⭐️⭐️⭐️</h5>
<p>
</p>
<p>The average score on this problem was 52%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<p><br></p>
<h3 id="problem-16.2">Problem 16.2</h3>
<p>In this part only, assume that all <code>"City"</code> names in
<code>sun</code> are unique.</p>
<p>Consider the DataFrame <code>cities</code> defined below.</p>
<div class="sourceCode" id="cb23"><pre
class="sourceCode py"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>cities <span class="op">=</span> sun.groupby(<span class="st">&quot;City&quot;</span>).mean().reset_index()</span></code></pre></div>
<p>Fill in the blanks so that the DataFrame that results from the
sequence of steps described below is identical to
<code>cities</code>.</p>
<p>“Sort <code>sun</code> by <strong>(c)</strong> in
<strong>(d)</strong> order <strong>(e)</strong>.”</p>
<p>What goes in blank (c)?</p>
<ul class="task-list">
<li><p><input type="radio" disabled="" /> <code>"Country"</code></p></li>
<li><p><input type="radio" disabled="" /> <code>"City"</code></p></li>
<li><p><input type="radio" disabled="" /> <code>"Jan"</code></p></li>
<li><p><input type="radio" disabled="" /> <code>"Year"</code></p></li>
</ul>
<p><br></p>
<p>What goes in blank (d)?</p>
<ul class="task-list">
<li><p><input type="radio" disabled="" /> ascending</p></li>
<li><p><input type="radio" disabled="" /> descending</p></li>
</ul>
<p><br></p>
<p>What goes in blank (e)?</p>
<ul class="task-list">
<li><p><input type="radio" disabled="" /> and drop the <code>"Country"</code> column</p></li>
<li><p><input type="radio" disabled="" /> and drop the <code>"Country"</code> and <code>"City"</code>
columns</p></li>
<li><p><input type="radio" disabled="" /> and reset the index</p></li>
<li><p><input type="radio" disabled="" /> , drop the <code>"Country"</code> column, and reset the index</p></li>
<li><p><input type="radio" disabled="" /> , drop the <code>"Country"</code> and <code>"City"</code> columns,
and reset the index</p></li>
<li><p><input type="radio" disabled="" /> Nothing, leave blank (e) empty</p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading16_2">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse16_2" aria-expanded="true" aria-controls="collapse16_2">
Click to view the solution.
</button>
</h2>
<div id="collapse16_2" class="accordion-collapse collapse"
aria-labelledby="heading16_2" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer</strong>: (c): <code>"City"</code>, (d): ascending,
(e): drop the <code>"Country"</code> column, and reset the index</p>
<p>Let’s start by understanding the code provided in the question:<br/>
The <code>.groupby("City")</code> method groups the data in the
<code>sun</code> DataFrame by unique city names. Since every city name
in the DataFrame is unique, this means that each group will consist of
just one row corresponding to that city.</p>
<p>After grouping by city, the <code>.mean()</code> method computes the
average of each column for each group. Again, as each city name is
unique, this operation doesn’t aggregate multiple rows but merely
reproduces the original values for each city. (For example, the value in
the <code>"Jan"</code> column for the row with the index
<code>"Hamilton"</code> will just be 229.8, which we see in the first
row of the preview of <code>sun</code>.)</p>
<p>Finally, <code>.reset_index()</code> is used to reset the DataFrame’s
index. When using <code>.groupby</code>, the column we group by (in this
case, <code>"City"</code>) becomes the index. By resetting the index,
we’re making <code>"City"</code> a regular column again and setting the
index to 0, 1, 2, 3, …</p>
<p><br/></p>
<p><strong>What goes in blank (c)?</strong> <code>"City"</code><br/>
When we group on <code>"City"</code>, the index of the DataFrame is set
to <code>"City"</code> names, sorted in ascending alphabetical order
(this is always the behavior of <code>groupby</code>). Since all city
names are unique, the number of rows in
<code>sun.groupby("City").mean()</code> is the same as the number of
rows in <code>sun</code>, and so grouping on <code>"City"</code>
effectively sorts the DataFrame by <code>"City"</code> and sets the
index to <code>"City"</code>. To replicate the order in
<code>cities</code>, then, we must sort <code>sun</code> by the
<code>"City"</code> column in ascending order.</p>
<hr/>
<h5>Difficulty: ⭐️</h5>
<p>
</p>
<p>The average score on this problem was 97%.</p>
<p><br/><br/></p>
<p><strong>What goes in blank (d)?</strong> ascending<br/>
Addressed above.</p>
<hr/>
<h5>Difficulty: ⭐️⭐️</h5>
<p>
</p>
<p>The average score on this problem was 77%.</p>
<p><br/><br/></p>
<p><strong>What goes in blank (e)?</strong> , drop the
<code>"Country"</code> column, and reset the index<br/>
In the provided code, after grouping by <code>"City"</code> and
computing the mean, we reset the index. This means the
<code>"City"</code> column is no longer the index but a regular column,
and the DataFrame gets a fresh integer index. To replicate this
structure, we need to reset the index in our sorted DataFrame.
Additionally, when we applied the <code>.mean()</code> method after
grouping, any non-numeric columns (like <code>"Country"</code>) that we
can’t take the mean of are automatically excluded from the resulting
DataFrame. To match the structure of <code>cities</code>, then, we must
drop the <code>"Country"</code> column from our sorted DataFrame.</p>
<hr/>
<h5>Difficulty: ⭐️⭐️⭐️⭐️</h5>
<p>
</p>
<p>The average score on this problem was 46%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<p><br></p>
<h3 id="problem-16.3">Problem 16.3</h3>
<p>True or False: In the code below, <code>Z</code> is guaranteed to
evaluate to <code>True</code>.</p>
<div class="sourceCode" id="cb24"><pre
class="sourceCode py"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> sun.groupby([<span class="st">&quot;Country&quot;</span>, <span class="st">&quot;Year&quot;</span>]).mean().shape[<span class="dv">0</span>]</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> sun.groupby(<span class="st">&quot;Country&quot;</span>).mean().shape[<span class="dv">0</span>]</span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>z <span class="op">=</span> (x <span class="op">&gt;=</span> y)</span></code></pre></div>
<ul class="task-list">
<li><p><input type="radio" disabled="" /> True</p></li>
<li><p><input type="radio" disabled="" /> False</p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading16_3">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse16_3" aria-expanded="true" aria-controls="collapse16_3">
Click to view the solution.
</button>
</h2>
<div id="collapse16_3" class="accordion-collapse collapse"
aria-labelledby="heading16_3" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer</strong>: True<br/>
Let’s us look at each line of code separately:</p>
<ul>
<li><p><code>x = sun.groupby(["Country", "Year"]).mean().shape[0]</code>:
This line groups the <code>sun</code> DataFrame by both
<code>"Country"</code> and <code>"Year"</code>, then computes the mean.
As a result, each unique combination of <code>"Country"</code> and
<code>"Year"</code> will have its own row. For instance, if there are
three different values in the <code>"Year"</code> column for a
particular country, that country will appear three times in the
DataFrame <code>sun.groupby(["Country", "Year"]).mean()</code>.</p></li>
<li><p><code>y = sun.groupby("Country").mean().shape[0]</code>: When
grouping by <code>"Country"</code> alone, each unique country in the
<code>sun</code> DataFrame is represented by one row, independent of the
information in other columns.</p></li>
<li><p><code>z = (x &gt;= y)</code>: This comparison checks whether the
number of rows produced by grouping by both <code>"Country"</code> and
<code>"Year"</code> (which is <code>x</code>) is greater than or equal
to the number of rows produced by grouping only by
<code>"Country"</code> (which is <code>y</code>).</p></li>
</ul>
<p>Given our grouping logic:</p>
<ul>
<li><p>If every country in the <code>sun</code> DataFrame has only a
single unique value in the <code>"Year"</code> column (e.g. if the
<code>"Year"</code> value for all ciites in the United States was always
3035.9, and if the <code>"Year"</code> value for all cities in Nigeria
was always 1845.4, etc.), then the number of rows when grouping by both
<code>"Country"</code> and <code>"Year"</code> will be equal to the
number of rows when grouping by <code>"Country"</code> alone. In this
scenario, <code>x</code> will be equal to <code>y</code>.</p></li>
<li><p>If at least one country in the <code>sun</code> DataFrame has at
least two different values in the <code>"Year"</code> column (e.g. if
there are at least two cities in the United States with different values
in the <code>"Year"</code> column), then there will be more rows when
grouping by both <code>"Country"</code> and <code>"Year"</code> compared
to grouping by <code>"Country"</code> alone. This means <code>x</code>
will be greater than <code>y</code>.</p></li>
</ul>
<p>Considering the above scenarios, there’s no situation where the value
of <code>x</code> can be less than the value of <code>y</code>.
Therefore, <code>z</code> will always evaluate to <code>True</code>.</p>
<hr/>
<h5>Difficulty: ⭐️⭐️⭐️</h5>
<p>
</p>
<p>The average score on this problem was 70%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<p>In the next few parts, consider the following answer choices.</p>
<ol type="A">
<li><p>The name of the country with the most cities.</p></li>
<li><p>The name of the country with the fewest cities.</p></li>
<li><p>The number of cities in the country with the most
cities.</p></li>
<li><p>The number of cities in the country with the fewest
cities.</p></li>
<li><p>The last city, alphabetically, in the first country,
alphabetically.</p></li>
<li><p>The first city, alphabetically, in the first country,
alphabetically.</p></li>
<li><p>Nothing, because it errors.</p></li>
</ol>
<p><br></p>
<h3 id="problem-16.4">Problem 16.4</h3>
<p>What does the following expression evaluate to?</p>
<div class="sourceCode" id="cb25"><pre
class="sourceCode py"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>sun.groupby(<span class="st">&quot;Country&quot;</span>).<span class="bu">max</span>().get(<span class="st">&quot;City&quot;</span>).iloc[<span class="dv">0</span>]</span></code></pre></div>
<ul class="task-list">
<li><p><input type="radio" disabled="" /> A</p></li>
<li><p><input type="radio" disabled="" /> B</p></li>
<li><p><input type="radio" disabled="" /> C</p></li>
<li><p><input type="radio" disabled="" /> D</p></li>
<li><p><input type="radio" disabled="" /> E</p></li>
<li><p><input type="radio" disabled="" /> F</p></li>
<li><p><input type="radio" disabled="" /> G</p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading16_4">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse16_4" aria-expanded="true" aria-controls="collapse16_4">
Click to view the solution.
</button>
</h2>
<div id="collapse16_4" class="accordion-collapse collapse"
aria-labelledby="heading16_4" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer</strong>: E. The last city, alphabetically, in the
first country, alphabetically.<br/>
</p>
<p>Let’s break down the code:</p>
<ul>
<li><p><code>sun.groupby("Country").max()</code>: This line of code
groups the <code>sun</code> DataFrame by the <code>"Country"</code>
column and then determines the <strong>maximum</strong> for every other
column within each country group. Since the values in the
<code>"City"</code> column are stored as strings, and the maximum of a
Series of strings is the last string alphabetically, the values in the
<code>"City"</code> column of this DataFrame will contain the last city,
alphabetically, of each country.</p></li>
<li><p><code>.get("City")</code>: <code>.get("City")</code> accesses the
<code>"City"</code> column.</p></li>
<li><p><code>.iloc[0]</code>: Finally, <code>.iloc[0]</code> selects the
<code>"City"</code> value from the first row. The first row corresponds
to the first country alphabetically because <code>groupby</code> sorted
the DataFrame by <code>"Country"</code> in ascending order. The value in
the <code>"City"</code> column that <code>.iloc[0]</code> selects, then,
is the name of the last city, alphabetically, in the first country,
alphabetically.</p></li>
</ul>
<hr/>
<h5>Difficulty: ⭐️⭐️⭐️⭐️</h5>
<p>
</p>
<p>The average score on this problem was 36%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<p><br></p>
<h3 id="problem-16.5">Problem 16.5</h3>
<p>What does the following expression evaluate to?</p>
<div class="sourceCode" id="cb26"><pre
class="sourceCode py"><code class="sourceCode python"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>sun.groupby(<span class="st">&quot;Country&quot;</span>).<span class="bu">sum</span>().get(<span class="st">&quot;City&quot;</span>).iloc[<span class="dv">0</span>]</span></code></pre></div>
<ul class="task-list">
<li><p><input type="radio" disabled="" /> A</p></li>
<li><p><input type="radio" disabled="" /> B</p></li>
<li><p><input type="radio" disabled="" /> C</p></li>
<li><p><input type="radio" disabled="" /> D</p></li>
<li><p><input type="radio" disabled="" /> E</p></li>
<li><p><input type="radio" disabled="" /> F</p></li>
<li><p><input type="radio" disabled="" /> G</p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading16_5">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse16_5" aria-expanded="true" aria-controls="collapse16_5">
Click to view the solution.
</button>
</h2>
<div id="collapse16_5" class="accordion-collapse collapse"
aria-labelledby="heading16_5" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer</strong>: G. Nothing, because it errors.<br/>
</p>
<p>Let’s break down the code:</p>
<ul>
<li><p><code>sun.groupby("Country").sum()</code>: This groups the
<code>sun</code> DataFrame by the <code>"Country"</code> column and
computes the sum for each numeric column within each country group.
Since <code>"City"</code> is non-numeric, it will be dropped.</p></li>
<li><p><code>.get("City")</code>: This operation attempts to retrieve
the <code>"City"</code> column from the resulting DataFrame. However,
since the <code>"City"</code> column was dropped in the previous step,
this will raise a KeyError, indicating that the column is not present in
the DataFrame.</p></li>
</ul>
<hr/>
<h5>Difficulty: ⭐️⭐️⭐️</h5>
<p>
</p>
<p>The average score on this problem was 73%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<p><br></p>
<h3 id="problem-16.6">Problem 16.6</h3>
<p>What does the following expression evaluate to?</p>
<div class="sourceCode" id="cb27"><pre
class="sourceCode py"><code class="sourceCode python"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a>sun.groupby(<span class="st">&quot;Country&quot;</span>).count().sort_values(<span class="st">&quot;Jan&quot;</span>).index[<span class="op">-</span><span class="dv">1</span>]</span></code></pre></div>
<ul class="task-list">
<li><p><input type="radio" disabled="" /> A</p></li>
<li><p><input type="radio" disabled="" /> B</p></li>
<li><p><input type="radio" disabled="" /> C</p></li>
<li><p><input type="radio" disabled="" /> D</p></li>
<li><p><input type="radio" disabled="" /> E</p></li>
<li><p><input type="radio" disabled="" /> F</p></li>
<li><p><input type="radio" disabled="" /> G</p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading16_6">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse16_6" aria-expanded="true" aria-controls="collapse16_6">
Click to view the solution.
</button>
</h2>
<div id="collapse16_6" class="accordion-collapse collapse"
aria-labelledby="heading16_6" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer</strong>: A. The name of the country with the most
cities.<br/>
</p>
<p>Let’s break down the code:</p>
<ul>
<li><p><code>sun.groupby("Country").count()</code>: This groups the sun
DataFrame by the <code>"Country"</code> column. The
<code>.count()</code> method then returns the number of rows in each
group for each column. Since we’re grouping by <code>"Country"</code>,
and since the rows in <code>sun</code> correspond to cities, this is
counting the number of cities in each country.</p></li>
<li><p><code>.sort_values("Jan")</code>: The result of the previous
operation is a DataFrame with <code>"Country"</code> as the index and
the number of cities per country stored in every other column. The
<code>"City</code>, <code>"Jan"</code>, <code>"Feb"</code>,
<code>"Mar"</code>, etc. columns in the resulting DataFrame all contain
the same information. Sorting by <code>"Jan"</code> sorts the DataFrame
by the number of cities each country has in ascending order.</p></li>
<li><p><code>.index[-1]</code>: This retrieves the last index value from
the sorted DataFrame, which corresponds to the name of the country with
the most cities.</p></li>
</ul>
<hr/>
<h5>Difficulty: ⭐️⭐️⭐️</h5>
<p>
</p>
<p>The average score on this problem was 61%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<p><br></p>
<h3 id="problem-16.7">Problem 16.7</h3>
<p>What does the following expression evaluate to?</p>
<div class="sourceCode" id="cb28"><pre
class="sourceCode py"><code class="sourceCode python"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a>sun.groupby(<span class="st">&quot;Country&quot;</span>).count().sort_values(<span class="st">&quot;City&quot;</span>).get(<span class="st">&quot;City&quot;</span>).iloc[<span class="op">-</span><span class="dv">1</span>]</span></code></pre></div>
<ul class="task-list">
<li><p><input type="radio" disabled="" /> A</p></li>
<li><p><input type="radio" disabled="" /> B</p></li>
<li><p><input type="radio" disabled="" /> C</p></li>
<li><p><input type="radio" disabled="" /> D</p></li>
<li><p><input type="radio" disabled="" /> E</p></li>
<li><p><input type="radio" disabled="" /> F</p></li>
<li><p><input type="radio" disabled="" /> G</p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading16_7">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse16_7" aria-expanded="true" aria-controls="collapse16_7">
Click to view the solution.
</button>
</h2>
<div id="collapse16_7" class="accordion-collapse collapse"
aria-labelledby="heading16_7" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer</strong>: C. The number of cities in the country with
the most cities.<br/>
</p>
<p>Let’s break down the code:</p>
<ul>
<li><p><code>sun.groupby("Country").count()</code>: This groups the sun
DataFrame by the <code>"Country"</code> column. The
<code>.count()</code> method then returns the number of rows in each
group for each column. Since we’re grouping by <code>"Country"</code>,
and since the rows in <code>sun</code> correspond to cities, this is
counting the number of cities in each country.</p></li>
<li><p><code>.sort_values("City")</code>: The result of the previous
operation is a DataFrame with <code>"Country"</code> as the index and
the number of <code>"City"</code>s per <code>"Country"</code> stored in
every other column. The <code>"City</code>, <code>"Jan"</code>,
<code>"Feb"</code>, <code>"Mar"</code>, etc. columns in the resulting
DataFrame all contain the same information. Sorting by
<code>"City"</code> sorts the DataFrame by the number of cities each
country has in ascending order.</p></li>
<li><p><code>.get("City")</code>: This retrieves the <code>"City"</code>
column from the sorted DataFrame, which contains the number of cities in
each country.</p></li>
<li><p><code>.iloc[-1]</code>: This gets the last value from the
<code>"City"</code> column, which corresponds to the number of cities in
the country with the most cities.</p></li>
</ul>
<hr/>
<h5>Difficulty: ⭐️⭐️⭐️</h5>
<p>
</p>
<p>The average score on this problem was 57%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<hr />
<p class="meta"><em>Source:</em> sp23-final — Q2</p>
<h2 id="problem-17">Problem 17</h2>
<p>Vanessa is a big Formula 1 racing fan, and wants to plan a trip to
Monaco, where the Monaco Grand Prix is held. Monaco is an example of a
“city-state” — that is, a city that is its own country. Singapore is
another example of a city-state.</p>
<p>We’ll say that a row of <code>sun</code> corresponds to a city-state
if its <code>"Country"</code> and <code>"City"</code> values are
equal.</p>
<p><br></p>
<h3 id="problem-17.1">Problem 17.1</h3>
<p>Fill in the blanks so that the expression below is equal to the total
number of sunshine hours in October of all city-states in
<code>sun</code>.</p>
<div class="sourceCode" id="cb29"><pre
class="sourceCode py"><code class="sourceCode python"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a>    sun[__(a)__].__(b)__</span></code></pre></div>
<p>What goes in blanks (a) and (b)?</p>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading17_1">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse17_1" aria-expanded="true" aria-controls="collapse17_1">
Click to view the solution.
</button>
</h2>
<div id="collapse17_1" class="accordion-collapse collapse"
aria-labelledby="heading17_1" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer</strong>: (a):
<code>sun.get("Country") == sun.get("City")</code>, (b):
<code>.get("Oct").sum()</code></p>
<p><strong>What goes in blank (a)?</strong>
<code>sun.get("Country") == sun.get("City")</code><br/>
This expression compares the <code>"Country"</code> column to the
<code>"City"</code> column for each row in the <code>sun</code>
DataFrame. It returns a Boolean Series where each value is
<code>True</code> if the corresponding <code>"Country"</code> and
<code>"City"</code> are the same (indicating a city-state) and
<code>False</code> otherwise.</p>
<hr/>
<h5>Difficulty: ⭐️⭐️</h5>
<p>
</p>
<p>The average score on this problem was 79%.</p>
<p><br/><br/></p>
<p><strong>What goes in blank (b)?</strong>
<code>.get("Oct").sum()</code><br/>
Here, we select the <code>"Oct"</code> column, which represents the
sunshine hours in October, and compute the sum of its values. By using
this after querying for city-states, we calculate the total sunshine
hours in October across all city-states in the <code>sun</code>
DataFrame.</p>
<hr/>
<h5>Difficulty: ⭐️⭐️</h5>
<p>
</p>
<p>The average score on this problem was 85%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<h3 id="problem-17.2">Problem 17.2</h3>
<p>Fill in the blanks below so that the expression below is also equal
to the total number of sunshine hours in October of all city-states in
<code>sun</code>.</p>
<p><em>Note: What goes in blank (b) is the same as what goes in blank
(b) above.</em></p>
<div class="sourceCode" id="cb30"><pre
class="sourceCode py"><code class="sourceCode python"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a>sun.get([<span class="st">&quot;Country&quot;</span>]).merge(__(c)__).__(b)__</span></code></pre></div>
<p>What goes in blank (c)?</p>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading17_2">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse17_2" aria-expanded="true" aria-controls="collapse17_2">
Click to view the solution.
</button>
</h2>
<div id="collapse17_2" class="accordion-collapse collapse"
aria-labelledby="heading17_2" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer</strong>:
<code>sun, left_on="Country", right_on="City"</code><br/>
</p>
<p>Let’s break down the code:</p>
<ul>
<li><p><code>sun.get(["Country"])</code>: This extracts just the
<code>"Country"</code> column from the <code>sun</code> DataFrame, as a
DataFrame. (It’s extracted as a DataFrame since we passed a list to
<code>.get</code> instead of a single string.)</p></li>
<li><p><code>.merge(sun, left_on="Country", right_on="City")</code>:
Here, we’re using the <code>.merge</code> method to merge a version of
<code>sun</code> with just the <code>"Country"</code> column (which is
our <em>left</em> DataFrame) with the entire <code>sun</code> DataFrame
(which is our <em>right</em> DataFrame). The merge is done by matching
<code>"Country"</code>s from the left DataFrame with
<code>"City"</code>s from the right DataFrame. This way, rows in the
resulting DataFrame correspond to city-states, as it only contains
entries where a country’s name is the same as a city’s name.</p></li>
<li><p><code>.get("Oct").sum()</code>: After merging, we use
<code>.get("Oct")</code> to retrieve the <code>"Oct"</code> column,
which represents the sunshine hours in October. Finally,
<code>.sum()</code> computes the total number of sunshine hours in
October for all the identified city-states.</p></li>
</ul>
<hr/>
<h5>Difficulty: ⭐️⭐️⭐️</h5>
<p>
</p>
<p>The average score on this problem was 50%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<hr />
<p class="meta"><em>Source:</em> sp23-midterm — Q5</p>
<h2 id="problem-18">Problem 18</h2>
<p>Teresa and Sophia are bored while waiting in line at Bistro and
decide to start flipping a UCSD-themed coin, with a picture of King
Triton’s face as the heads side and a picture of his mermaid-like tail
as the tails side.</p>
<center><img src='../../assets/images/sp23-midterm/king_triton.png' width=200></center>
<p><br></p>
<p>Teresa flips the coin 21 times and sees 13 heads and 8 tails. She
stores this information in a DataFrame named <code>teresa</code> that
has 21 rows and 2 columns, such that:</p>
<ul>
<li><p>The <code>"flips"</code> column contains <code>"Heads"</code> 13
times and <code>"Tails"</code> 8 times.</p></li>
<li><p>The <code>"Wolftown"</code> column contains <code>"Teresa"</code>
21 times.</p></li>
</ul>
<p>Then, Sophia flips the coin 11 times and sees 4 heads and 7 tails.
She stores this information in a DataFrame named <code>sophia</code>
that has 11 rows and 2 columns, such that:</p>
<ul>
<li><p>The <code>"flips"</code> column contains <code>"Heads"</code> 4
times and <code>"Tails"</code> 7 times.</p></li>
<li><p>The <code>"Makai"</code> column contains <code>"Sophia"</code> 11
times.</p></li>
</ul>
<p><br></p>
<h3 id="problem-18.1">Problem 18.1</h3>
<p>How many rows are in the following DataFrame? Give your answer as an
integer.</p>
<div class="sourceCode" id="cb31"><pre
class="sourceCode py"><code class="sourceCode python"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a>    teresa.merge(sophia, on<span class="op">=</span><span class="st">&quot;flips&quot;</span>)</span></code></pre></div>
<p><em>Hint: The answer is less than 200.</em></p>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading18_1">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse18_1" aria-expanded="true" aria-controls="collapse18_1">
Click to view the solution.
</button>
</h2>
<div id="collapse18_1" class="accordion-collapse collapse"
aria-labelledby="heading18_1" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer</strong>: 108</p>
<p>Since we used the argument <code>on="flips</code>, rows from
<code>teresa</code> and <code>sophia</code> will be combined whenever
they have matching values in their <code>"flips"</code> columns.</p>
<p>For the <code>teresa</code> DataFrame:</p>
<ul>
<li>There are 13 rows with <code>"Heads"</code> in the
<code>"flips"</code> column.</li>
<li>There are 8 rows with <code>"Tails"</code> in the
<code>"flips"</code> column.</li>
</ul>
<p>For the <code>sophia</code> DataFrame:</p>
<ul>
<li>There are 4 rows with <code>"Heads"</code> in the
<code>"flips"</code> column.</li>
<li>There are 7 rows with <code>"Tails"</code> in the
<code>"flips"</code> column.</li>
</ul>
<p>The merged DataFrame will also only have the values
<code>"Heads"</code> and <code>"Tails"</code> in its
<code>"flips"</code> column. - The 13 <code>"Heads"</code> rows from
<code>teresa</code> will each pair with the 4 <code>"Heads"</code> rows
from <code>sophia</code>. This results in <span class="math inline">13
\cdot 4 = 52</span> rows with <code>"Heads"</code> - The 8
<code>"Tails"</code> rows from <code>teresa</code> will each pair with
the 7 <code>"Tails"</code> rows from <code>sophia</code>. This results
in <span class="math inline">8 \cdot 7 = 56</span> rows with
<code>"Tails"</code>.</p>
<p>Then, the total number of rows in the merged DataFrame is <span class="math inline">52 + 56 = 108</span>.</p>
<hr/>
<h5>Difficulty: ⭐️⭐️⭐️</h5>
<p>
</p>
<p>The average score on this problem was 54%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<p><br></p>
<h3 id="problem-18.2">Problem 18.2</h3>
<p>Let <span class="math inline">A</span> be your answer to the previous
part. Now, suppose that:</p>
<ul>
<li><p><code>teresa</code> contains an additional row, whose
<code>"flips"</code> value is <code>"Total"</code> and whose
<code>"Wolftown"</code> value is 21.</p></li>
<li><p><code>sophia</code> contains an additional row, whose
<code>"flips"</code> value is <code>"Total"</code> and whose
<code>"Makai"</code> value is 11.</p></li>
</ul>
<p>Suppose we again merge <code>teresa</code> and <code>sophia</code> on
the <code>"flips"</code> column. In terms of <span
class="math inline">A</span>, how many rows are in the new merged
DataFrame?</p>
<ul class="task-list">
<li><p><input type="radio" disabled="" /> <span class="math inline">A</span></p></li>
<li><p><input type="radio" disabled="" /> <span class="math inline">A+1</span></p></li>
<li><p><input type="radio" disabled="" /> <span class="math inline">A+2</span></p></li>
<li><p><input type="radio" disabled="" /> <span class="math inline">A+4</span></p></li>
<li><p><input type="radio" disabled="" /> <span class="math inline">A+231</span></p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading18_2">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse18_2" aria-expanded="true" aria-controls="collapse18_2">
Click to view the solution.
</button>
</h2>
<div id="collapse18_2" class="accordion-collapse collapse"
aria-labelledby="heading18_2" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer</strong>: <span class="math inline">A+1</span></p>
<p>The additional row in each DataFrame has a unique
<code>"flips"</code> value of <code>"Total"</code>. When we merge on the
<code>"flips"</code> column, this unique value will only create a single
new row in the merged DataFrame, as it pairs the <code>"Total"</code>
from <code>teresa</code> with the <code>"Total"</code> from
<code>sophia</code>. The rest of the rows are the same as in the
previous merge, and as such, they will contribute the same number of
rows, <span class="math inline">A</span>, to the merged DataFrame. Thus,
the total number of rows in the new merged DataFrame will be <span class="math inline">A</span> (from the original matching rows) plus 1
(from the new <code>"Total"</code> rows), which sums up to <span class="math inline">A+1</span>.</p>
<hr/>
<h5>Difficulty: ⭐️⭐️⭐️⭐️</h5>
<p>
</p>
<p>The average score on this problem was 46%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<hr />
<p class="meta"><em>Source:</em> sp24-final — Q2</p>
<h2 id="problem-19">Problem 19</h2>
<p>Michelle and Abel are each touring apartments for where they might
live next year. Michelle wants to be close to UCSD so she can attend
classes easily. Abel is graduating and wants to live close to the beach
so he can surf. Each person makes their own DataFrame (called
<code>michelle</code> and <code>abel</code> respectively), to keep track
of all the apartments that they toured. Both <code>michelle</code> and
<code>abel</code> came from querying <code>apts</code>, so both
DataFrames have the same columns and structure as <code>apts</code>.</p>
<p>Here are some details about the apartments they toured.</p>
<ul>
<li>Michelle toured <strong>one bedroom and studio</strong> apartments
at 12 different complexes, or 24 apartments total.</li>
<li>Abel toured <strong>one bedroom and two bedroom</strong> apartments
at 20 different complexes, or 40 apartments total.</li>
<li>There are 8 complexes that are near both UCSD and the beach, and
both Michelle and Abel toured these complexes.</li>
</ul>
<p>We’ll assume for this problem only that there is just one apartment
of each size available at each complex, so that if they both tour a one
bedroom apartment at the same complex, it is the exact same apartment
with the same <code>"Apartment ID"</code>.</p>
<p><br></p>
<h3 id="problem-19.1">Problem 19.1</h3>
<p>What does the following expression evaluate to?</p>
<div style="text-align: center;">
<p><pre><code class="python">michelle.merge(abel, left_index=True, right_index=True).shape[0]</code></pre></p>
</div>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading19_1">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse19_1" aria-expanded="true" aria-controls="collapse19_1">
Click to view the solution.
</button>
</h2>
<div id="collapse19_1" class="accordion-collapse collapse"
aria-labelledby="heading19_1" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer:</strong> <span class="math inline">8</span></p>
<p>This expression uses the indices of <code>michelle</code> and
<code>abel</code> to merge. Since both use the index of
<code>"Apartment ID"</code> and we are assuming that there is only one
apartment of each size available at each complex, we only need to see
how many unique apartments <code>michelle</code> and <code>abel</code>
share. Since there are 8 complexes that they both visited, only the one
bedroom apartments in these complexes will be displayed in the resulting
merged DataFrame. Therefore, we will only have 8 apartments, or 8
rows.</p>
<hr/>
<h5>Difficulty: ⭐️⭐️⭐️⭐️</h5>
<p>
</p>
<p>The average score on this problem was 48%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<h3 id="problem-19.2">Problem 19.2</h3>
<p>What does the following expression evaluate to?</p>
<div style="text-align: center;">
<p><pre><code class="python"> michelle.merge(abel, on=“Bed”).shape[0]
</code></pre></p>
</div>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading19_2">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse19_2" aria-expanded="true" aria-controls="collapse19_2">
Click to view the solution.
</button>
</h2>
<div id="collapse19_2" class="accordion-collapse collapse"
aria-labelledby="heading19_2" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer:</strong> <span class="math inline">240</span></p>
<p>This expression merges on the <code>"Bed"</code> column, so we need
to look at the data in this column for the two DataFrames. Within this
column, <code>michelle</code> and <code>abel</code> share only one
specific type of value: <code>"One"</code>. With the details that are
given, <code>michelle</code> has 12 rows containing this value while
<code>abel</code> has 20 rows containing this value. Since we are
merging on this row, each row in <code>abel</code> that contains the
<code>"One"</code> value will be matched with a row in
<code>michelle</code> that also contains the value, meaning one row in
<code>michelle</code> will turn into twelve after the merge.</p>
<p>Thus, to compute the total number of rows from this merge expression,
we multiply the number of rows in <code>michelle</code> with the number
of rows in <code>abel</code> that fit the cross-criteria of
<code>"Bed"</code>. Numerically, this would be <span class="math inline">12 \cdot 20 = 240</span>.</p>
<hr/>
<h5>Difficulty: ⭐️⭐️⭐️⭐️</h5>
<p>
</p>
<p>The average score on this problem was 33%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<h3 id="problem-19.3">Problem 19.3</h3>
<p>What does the following expression evaluate to?</p>
<div style="text-align: center;">
<p><pre><code class="python">
michelle.merge(abel, on=“Complex”).shape[0] </code></pre></p>
</div>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading19_3">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse19_3" aria-expanded="true" aria-controls="collapse19_3">
Click to view the solution.
</button>
</h2>
<div id="collapse19_3" class="accordion-collapse collapse"
aria-labelledby="heading19_3" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer:</strong> <span class="math inline">32</span></p>
<p>To approach this question, we first need to determine how many
complexes Michelle and Abel have in common: 8. We also know that each
complex was toured twice by both Michelle and Abel, so there are two
copies of each complex in the <code>michelle</code> and
<code>abel</code> DataFrames. Therefore, when we merge the DataFrames,
the two copies of each complex will match with each other, effectively
creating four copies for each complex from the original two. Since this
is done for each complex, we have <span class="math inline">8 \cdot (2
\cdot 2) = 32</span>.</p>
<hr/>
<h5>Difficulty: ⭐️⭐️⭐️⭐️⭐️</h5>
<p>
</p>
<p>The average score on this problem was 19%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<h3 id="problem-19.4">Problem 19.4</h3>
<p>What does the following expression evaluate to?</p>
<div style="text-align: center;">
<p><pre><code class="python"> abel.merge(abel, on=“Bed”).shape[0]
</code></pre></p>
</div>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading19_4">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse19_4" aria-expanded="true" aria-controls="collapse19_4">
Click to view the solution.
</button>
</h2>
<div id="collapse19_4" class="accordion-collapse collapse"
aria-labelledby="heading19_4" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer:</strong> <span class="math inline">800</span></p>
<p>Since this question deals purely with the <code>abel</code>
DataFrame, we need to fully understand what is inside it. There are 40
apartments (or rows): 20 one bedrooms and 20 two bedrooms. When we
self-merge on the <code>"Bed"</code> column, it is imperative to know
that every one bedroom apartment will be matched with the 20 other one
bedroom apartments (including itself)! This also goes for the two
bedroom apartments. Therefore, we have <span class="math inline">20
\cdot 20 + 20 \cdot 20 = 800</span>.</p>
<hr/>
<h5>Difficulty: ⭐️⭐️⭐️⭐️⭐️</h5>
<p>
</p>
<p>The average score on this problem was 28%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<hr />
<p class="meta"><em>Source:</em> sp24-final — Q3</p>
<h2 id="problem-20">Problem 20</h2>
<p>We wish to compare the average rent for studio apartments in
different complexes.</p>
<p><br></p>
<h3 id="problem-20.1">Problem 20.1</h3>
<p>Our goal is to create a DataFrame <code>studio_avg</code> where each
complex with studio apartments appears once. The DataFrame should
include a column named <code>"Rent"</code> that contains the average
rent for all studio apartments in that complex. For each of the
following strategies, determine if the code provided works as intended,
gives an incorrect answer, or errors.</p>
<ol type="i">
<li></li>
</ol>
<div class="sourceCode" id="cb32"><pre
class="sourceCode py"><code class="sourceCode python"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a>studio <span class="op">=</span> apts[apts.get(<span class="st">&quot;Bed&quot;</span>) <span class="op">==</span> <span class="st">&quot;Studio&quot;</span>]</span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>studio_avg <span class="op">=</span> studio.groupby(<span class="st">&quot;Complex&quot;</span>).mean().reset_index()</span></code></pre></div>
<ul class="task-list">
<li><p><input type="radio" disabled="" /> Works as intended</p></li>
<li><p><input type="radio" disabled="" /> Gives an incorrect answer</p></li>
<li><p><input type="radio" disabled="" /> Errors</p></li>
</ul>
<ol start="2" type="i">
<li></li>
</ol>
<div class="sourceCode" id="cb33"><pre
class="sourceCode py"><code class="sourceCode python"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a>studio_avg <span class="op">=</span> apts.groupby(<span class="st">&quot;Complex&quot;</span>).<span class="bu">min</span>().reset_index()</span></code></pre></div>
<ul class="task-list">
<li><p><input type="radio" disabled="" /> Works as intended</p></li>
<li><p><input type="radio" disabled="" /> Gives an incorrect answer</p></li>
<li><p><input type="radio" disabled="" /> Errors</p></li>
</ul>
<ol start="3" type="i">
<li></li>
</ol>
<div class="sourceCode" id="cb34"><pre
class="sourceCode py"><code class="sourceCode python"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a>grouped <span class="op">=</span> apts.groupby([<span class="st">&quot;Bed&quot;</span>, <span class="st">&quot;Complex&quot;</span>]).mean().reset_index()</span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>studio_avg <span class="op">=</span> grouped[grouped.get(<span class="st">&quot;Bed&quot;</span>) <span class="op">==</span> <span class="st">&quot;Studio&quot;</span>]</span></code></pre></div>
<ul class="task-list">
<li><p><input type="radio" disabled="" /> Works as intended</p></li>
<li><p><input type="radio" disabled="" /> Gives an incorrect answer</p></li>
<li><p><input type="radio" disabled="" /> Errors</p></li>
</ul>
<ol start="4" type="i">
<li></li>
</ol>
<div class="sourceCode" id="cb35"><pre
class="sourceCode py"><code class="sourceCode python"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a>grouped <span class="op">=</span> apts.groupby(<span class="st">&quot;Complex&quot;</span>).mean().reset_index()</span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a>studio_avg <span class="op">=</span> grouped[grouped.get(<span class="st">&quot;Bed&quot;</span>) <span class="op">==</span> <span class="st">&quot;Studio&quot;</span>]</span></code></pre></div>
<ul class="task-list">
<li><p><input type="radio" disabled="" /> Works as intended</p></li>
<li><p><input type="radio" disabled="" /> Gives an incorrect answer</p></li>
<li><p><input type="radio" disabled="" /> Errors</p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading20_1">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse20_1" aria-expanded="true" aria-controls="collapse20_1">
Click to view the solution.
</button>
</h2>
<div id="collapse20_1" class="accordion-collapse collapse"
aria-labelledby="heading20_1" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer:</strong></p>
<ul>
<li><strong>(i) Works as intended</strong></li>
<li><strong>(ii) Gives an incorrect answer</strong></li>
<li><strong>(iii) Works as intended</strong></li>
<li><strong>(iv) Errors</strong></li>
</ul>
<ol type="i">
<li><code>studio</code> is set to a DataFrame that is queried from the
<code>apts</code> DataFrame so that it contains only rows that have the
<code>"Studio"</code> value in <code>"Bed"</code>. Then, with
<code>studio</code>, it groups by the <code>"Complex"</code> and
aggregates by the mean. Finally, it resets its index. Since we have a
DataFrame that only has <code>"Studio"</code>s , grouping by the
<code>"Complex"</code> will take the mean of every numerical column -
including the rent - in the DataFrame per <code>"Complex"</code>,
effectively reaching our goal.</li>
</ol>
<hr/>
<h5>Difficulty: ⭐️</h5>
<p>
</p>
<p>The average score on this problem was 96%.</p>
<p><br/><br/></p>
<ol start="2" type="i">
<li><code>studio_avg</code> is created by grouping
<code>"Complex"</code> and aggregating by the minimum. However, as the
question asks for the <strong>average rent</strong>, getting the minimum
rent of every complex does not reach the conclusion the question asks
for.</li>
</ol>
<hr/>
<h5>Difficulty: ⭐️</h5>
<p>
</p>
<p>The average score on this problem was 95%.</p>
<p><br/><br/></p>
<ol start="3" type="i">
<li><code>grouped</code> is made through first grouping by both the
<code>"Bed"</code> and <code>"Complex"</code> columns then taking the
mean and resetting the index. Since we are grouping by both of these
columns, we separate each type of <code>"Bed"</code> by the
<code>"Complex"</code> it belongs to while aggregating by the mean for
every numerical column. After resetting the index, we are left with a
DataFrame that contains the mean of every <code>"Bed"</code> and
<code>"Complex"</code> combination. A sample of the DataFrame might look
like this:</li>
</ol>
<table>
<thead>
<tr>
<th>Bed</th>
<th>Complex</th>
<th>Rent</th>
<th>…</th>
</tr>
</thead>
<tbody>
<tr>
<td>One</td>
<td>Costa Verde Village</td>
<td>3200</td>
<td>…</td>
</tr>
<tr>
<td>One</td>
<td>Westwood</td>
<td>3000</td>
<td>…</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
</tr>
</tbody>
</table>
<center>(<em>Note: This is not an accurate representation of the DataFrame's true values at all!</em>)</center>
<p>Then, when we assign <code>studio_avg</code>, we take this DataFrame
and only get the rows in which <code>grouped</code>’s <code>"Bed"</code>
column contains <code>"Studio"</code>. As we already
<code>.groupby()</code>’d and aggregated by the mean for each
<code>"Bed"</code> and <code>"Complex"</code> pair, we arrive at the
solution the question requests for.</p>
<hr/>
<h5>Difficulty: ⭐️⭐️</h5>
<p>
</p>
<p>The average score on this problem was 84%.</p>
<p><br/><br/></p>
<ol start="4" type="i">
<li>For this <code>grouped</code>, we only <code>.groupby()</code> the
<code>"Complex"</code> column, aggregate by the mean, and reset index.
Then, we attempt to assign <code>studio_avg</code> to the resulting
DataFrame of a query from our <code>grouped</code> DataFrame. However,
this wouldn’t work at all because when we grouped by
<code>"Complex"</code> and aggregated by the mean to create
<code>grouped</code>, the <code>.groupby()</code> removed our
<code>"Bed"</code> column since it isn’t numerical. Therefore, when we
attempt to query by <code>"Bed"</code>, babypandas cannot locate such
column since it was removed - resulting in an error.</li>
</ol>
<hr/>
<h5>Difficulty: ⭐️⭐️⭐️</h5>
<p>
</p>
<p>The average score on this problem was 60%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<h3 id="problem-20.2">Problem 20.2</h3>
<p>Consider the DataFrame <code>alternate_approach</code> defined as
follows</p>
<div class="sourceCode" id="cb36"><pre
class="sourceCode py"><code class="sourceCode python"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a>grouped <span class="op">=</span> apts.groupby([<span class="st">&quot;Bed&quot;</span>, <span class="st">&quot;Complex&quot;</span>]).mean().reset_index()</span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a>alternate_approach <span class="op">=</span> grouped.groupby(<span class="st">&quot;Complex&quot;</span>).<span class="bu">min</span>()</span></code></pre></div>
<p>Suppose that the <code>"Rent"</code> column of
<code>alternate_approach</code> has all the same values as the
<code>"Rent"</code> column of <code>studio_avg</code>, where
<code>studio_avg</code> is the DataFrame described in part (a). Which of
the following are valid conclusions about <code>apts</code>? Select all
that apply.</p>
<ul class="task-list">
<li><p><input type="checkbox" disabled="" /> No complexes have studio apartments.</p></li>
<li><p><input type="checkbox" disabled="" /> Every complex has at least one studio apartment.</p></li>
<li><p><input type="checkbox" disabled="" /> Every complex has exactly one studio apartment.</p></li>
<li><p><input type="checkbox" disabled="" /> Some complexes have only studio apartments.</p></li>
<li><p><input type="checkbox" disabled="" /> In every complex, the average price of a studio apartment is less
than or equal to the average price of a one bedroom apartment.</p></li>
<li><p><input type="checkbox" disabled="" /> In every complex, the single cheapest apartment is a studio
apartment.</p></li>
<li><p><input type="checkbox" disabled="" /> None of these.</p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading20_2">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse20_2" aria-expanded="true" aria-controls="collapse20_2">
Click to view the solution.
</button>
</h2>
<div id="collapse20_2" class="accordion-collapse collapse"
aria-labelledby="heading20_2" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer:</strong> Options 2 and 5</p>
<p><code>alternate approach</code> first groups by <code>"Bed"</code>
and <code>"Complex"</code> , takes the mean of all the columns, and
resets the index such that <code>"Bed"</code> and <code>"Complex"</code>
are no longer indexes. Now there is one row per <code>"Bed"</code> and
<code>"Complex"</code> combination that exists in <code>apts</code> and
all columns contain the mean value for each of these <code>"Bed"</code>
and <code>"Complex"</code> combinations. Then it groups by
<code>"Complex"</code> again, taking the minimum value of all columns.
The output is a DataFrame indexed by <code>"Complex"</code> where the
<code>"Rent"</code>column contains the minimum rent (from of all the
average prices for each type of <code>"Bed"</code>).</p>
<ul>
<li>Option 1 is incorrect. This is not necessarily true. The
<code>"Rent"</code> column in <code>alternate_approach</code>in contains
the minimum of all the average prices for each type of
<code>"Bed"</code> and the <code>"Rent"</code> column in
<code>"studio_avg"</code> contains the average rent for studios in each
type of complex. Even though they contain the same values, this does not
mean that no studios exist in any complexes. If this were the case,
<code>studio_avg</code> would be an empty DataFrame and
<code>alternate_approach</code> would not be.</li>
<li>Option 2 is correct. If these columns are the same, that means that
for each complex, there must at least one studio apartment. If this was
not the case and there were complexes with no studio apartments,
complexes that may appear in <code>alternate_approach</code> would not
appear in <code>studio_avg</code>.</li>
<li>Option 3 is incorrect. This is not necessarily true. Complexes can
have more than one studio. <code>studio_avg</code> has the average of
all these studios for each complex and <code>alternate_approach</code>
will have the minimum rent (from all the average prices for each type of
bedroom). Just because the columns are the same does not mean that there
is only one studio per complex.</li>
<li>Option 4 is incorrect. This is not necessarily true. Just because
the columns are the same does not mean that complexes only have studios.
Perhaps studios just have the minimum rent on average across all
complexes as explored in Option 5 below.</li>
<li>Option 5 is correct. <code>studio_avg</code> contains the average
price for a studio in each complex. <code>alternate_approach</code>
contains the minimum rent from the average rents of all types of
bedrooms for each complex. Since these columns are the same, this means
that the average price of a studio must be lower (or equal to) the
average price of a one bedroom (or any other type of bedroom) for all
the rent values in <code>alternate_approach</code> to align with all the
values in <code>studio_avg</code>.</li>
<li>Option 6 is incorrect. As shown above, there are correct answers to
this question.</li>
</ul>
<hr/>
<h5>Difficulty: ⭐️⭐️⭐️</h5>
<p>
</p>
<p>The average score on this problem was 73%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<h3 id="problem-20.3">Problem 20.3</h3>
<p>Which data visualization should we use to compare the average prices
of studio apartments across complexes?</p>
<ul class="task-list">
<li><p><input type="radio" disabled="" /> Scatter plot</p></li>
<li><p><input type="radio" disabled="" /> Line chart</p></li>
<li><p><input type="radio" disabled="" /> Bar chart</p></li>
<li><p><input type="radio" disabled="" /> Histogram</p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading20_3">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse20_3" aria-expanded="true" aria-controls="collapse20_3">
Click to view the solution.
</button>
</h2>
<div id="collapse20_3" class="accordion-collapse collapse"
aria-labelledby="heading20_3" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer:</strong> Bar chart</p>
<p>Each complex is a categorical data type, so we should use a bar chart
to compare average prices.</p>
<ul>
<li>Scatter plots are between two numerical variables.</li>
<li>Line charts are typically used to depict changes throughout
time.</li>
<li>Histograms are used to depict frequency of distribution.</li>
</ul>
<hr/>
<h5>Difficulty: ⭐️⭐️</h5>
<p>
</p>
<p>The average score on this problem was 85%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<hr />
<p class="meta"><em>Source:</em> sp24-midterm — Q6</p>
<h2 id="problem-21">Problem 21</h2>
<p>Suppose Charlie and Norah each have separate DataFrames for their
contacts, called <code>charlie</code> and <code>norah</code>,
respectively. These DataFrames have the same column names and format as
your DataFrame, <code>contacts</code>.</p>
<p>As illustrated in the diagram below, Charlie has 172 contacts in
total, whereas Norah has 88 contacts. 12 of these contacts are shared,
meaning they appear in both <code>charlie</code> and
<code>norah</code>.</p>
<center><img src="../../assets/images/sp24-midterm/venn_diagram.png" width=400></center>
<p><br></p>
<h3 id="problem-21.1">Problem 21.1</h3>
<p>What does the following expression evaluate to?</p>
<div class="sourceCode" id="cb37"><pre
class="sourceCode py"><code class="sourceCode python"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a>charlie.merge(norah, left_index<span class="op">=</span><span class="va">True</span>, right_index<span class="op">=</span><span class="va">True</span>).shape[<span class="dv">0</span>]    </span></code></pre></div>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading21_1">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse21_1" aria-expanded="true" aria-controls="collapse21_1">
Click to view the solution.
</button>
</h2>
<div id="collapse21_1" class="accordion-collapse collapse"
aria-labelledby="heading21_1" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer:</strong> <span class="math inline">12</span></p>
<p>The code merges DataFrames <code>charlie</code> and
<code>norah</code> on their indexes, so the resulting DataFrame will
contain one row for every match between their indexes (‘Person’ since
they follow the same format as DataFrame <code>contact</code>). From the
Venn Diagram, we know that Charlie and Norah have 12 contacts in common,
so the resulting DataFrame will contain 12 rows: one row for each shared
contact.</p>
<p>Thus,
<code>charlie.merge(norah, left_index=True, right_index=True).shape[0]</code>
returns the row number of the resulting DataFrame, which is 12.</p>
<hr/>
<h5>Difficulty: ⭐️⭐️⭐️</h5>
<p>
</p>
<p>The average score on this problem was 66%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<h3 id="problem-21.2">Problem 21.2</h3>
<p>One day, when updating her phone’s operating system, Norah
accidentally duplicates the 12 contacts she has in common with Charlie.
Now, the <code>norah</code> DataFrame has 100 rows.</p>
<p>What does the following expression evaluate to?</p>
<div class="sourceCode" id="cb38"><pre
class="sourceCode py"><code class="sourceCode python"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a>norah.merge(norah, left_index<span class="op">=</span><span class="va">True</span>, right_index<span class="op">=</span><span class="va">True</span>).shape[<span class="dv">0</span>]   </span></code></pre></div>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading21_2">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse21_2" aria-expanded="true" aria-controls="collapse21_2">
Click to view the solution.
</button>
</h2>
<div id="collapse21_2" class="accordion-collapse collapse"
aria-labelledby="heading21_2" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer:</strong> <span class="math inline">24 \cdot 2 + 76 =
124</span></p>
<p>Since Norah duplicates 12 contacts, the <code>norah</code> DataFrame
now has 76 unique rows + 12 rows + 12 duplicated rows. Note that the
above code is now merging norah with itself on indexes.</p>
<p>After merging, the resulting DataFrame will contain 76 unique rows,
as there is only one match for each unique row. As for the duplicated
rows, each row can match twice, and we have 24 rows. Thus the resulting
DataFrame’s row number <span class="math inline">= 76 + 2 \cdot 24 =
124</span>.</p>
<p>For better understanding, imagine we have a smaller DataFrame
<code>nor</code> with only one contact Jim. After duplication, it will
have two identical rows of Jim. For easier explanation, let’s denote the
original row Jim1, and duplicated row Jim2. When merging Nor with
itself, Jim1 can be matched with Jim1 and Jim2, and Jim2 can be matched
with Jim1 and Jim2, resulting $= 2 = 4 $ number of rows.</p>
<hr/>
<h5>Difficulty: ⭐️⭐️⭐️⭐️⭐️</h5>
<p>
</p>
<p>The average score on this problem was 3%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<hr />
<p class="meta"><em>Source:</em> sp24-midterm — Q8</p>
<h2 id="problem-22">Problem 22</h2>
<p>You wonder if any of your friends have the same birthday, for example
two people both born on April 3rd. Fill in the blanks below so that the
given expression evaluates to the largest number of people in
<code>contacts</code> who share the same birthday.</p>
<p><strong>Note:</strong> People do not need to be born in the same year
to share a birthday!</p>
<div class="sourceCode" id="cb39"><pre
class="sourceCode py"><code class="sourceCode python"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a>contacts.groupby(___(a)___).___(b)___.get(<span class="st">&quot;Phone&quot;</span>).___(c)___</span></code></pre></div>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading22">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse22" aria-expanded="true" aria-controls="collapse22">
Click to view the solution.
</button>
</h2>
<div id="collapse22" class="accordion-collapse collapse"
aria-labelledby="heading22" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<ul>
<li>(a): <code>["Month", "Day"]</code></li>
<li>(b): <code>count()</code></li>
<li>(c): <code>max()</code></li>
</ul>
<p><code>.groupby(["Month", "Day"]).count()</code> groups the DataFrame
contacts by each unique combination of ‘Month’ and ‘Day’ (birthday) and
then counts the number of rows in each group (i.e. number of people born
on that date).</p>
<p><code>.get('Phone')</code> gets a series which contains the counts of
people born on each date, and <code>.max()</code> finds the largest
number of people sharing the same birthday.</p>
<hr/>
<h5>Difficulty: ⭐️⭐️⭐️</h5>
<p>
</p>
<p>The average score on this problem was 72%.</p>
</div>
</div>
</div>
</div>
<hr />
<p class="meta"><em>Source:</em> sp25-midterm — Q5</p>
<h2 id="problem-23">Problem 23</h2>
<p>Suppose we have another DataFrame called <code>trade_partners</code>
that has a row for every country that the United States trades with.
<code>trade_partners</code> is indexed by <code>"Country"</code> and has
two columns:</p>
<ul>
<li><p>The <code>"Proportion"</code> column contains <code>float</code>s
representing the proportion of US imports coming from each
country.</p></li>
<li><p>The <code>"Continent"</code> column contains the name of the
continent where the country is located.</p></li>
</ul>
<p>All countries in <code>tariffs</code> are included in
<code>trade_partners</code> (including <code>"European Union"</code>),
but not all countries in <code>trade_partners</code> are included in
<code>tariffs</code>. The first three rows of
<code>trade_partners</code> are shown below.</p>
<center><img src="../../assets/images/sp25-midterm/trade_partners.jpg" width=300></center>
<p><br></p>
<h3 id="problem-23.1">Problem 23.1</h3>
<p>Write one line of code to merge <code>tariffs</code> with
<code>trade_partners</code> and store the result in
<code>merged</code>.</p>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading23_1">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse23_1" aria-expanded="true" aria-controls="collapse23_1">
Click to view the solution.
</button>
</h2>
<div id="collapse23_1" class="accordion-collapse collapse"
aria-labelledby="heading23_1" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer:</strong>
<code>merged = tariffs.merge(trade_partners, left_on="Country", right_index=True)</code></p>
<p><code>tariffs</code> and <code>trade_partners</code> are both
dataframes which correspond to the US’s relationship with other
Countries. Since both dataframes contain one row for each country we
need to merge them with the column which corresponds to the country
name. In <code>tariffs</code> that would be the <code>Country</code>
column and in <code>trade_partners</code> that is the index.</p>
<hr/>
<h5>Difficulty: ⭐️⭐️</h5>
<p>
</p>
<p>The average score on this problem was 80%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<h3 id="problem-23.2">Problem 23.2</h3>
<p>How many rows does <code>merged</code> have?</p>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading23_2">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse23_2" aria-expanded="true" aria-controls="collapse23_2">
Click to view the solution.
</button>
</h2>
<div id="collapse23_2" class="accordion-collapse collapse"
aria-labelledby="heading23_2" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer:</strong> <span class="math inline">50</span></p>
<p>Since each DataFrame has exactly one row per country, the merged
result will also have one row for every country they share. And because
every country in <code>tariffs</code> appears in
<code>trade_partners</code> (though not vice versa), the merged
DataFrame will contain exactly as many rows as there are countries in
<code>tariffs</code> (which is 50).</p>
<hr/>
<h5>Difficulty: ⭐️⭐️</h5>
<p>
</p>
<p>The average score on this problem was 83%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<h3 id="problem-23.3">Problem 23.3</h3>
<p>In which of the following DataFrames does the
<code>"Proportion"</code> column sum to <span
class="math inline">1</span>? Select all that apply.</p>
<ul class="task-list">
<li><p><input type="checkbox" disabled="" /> <code>trade_partners</code></p></li>
<li><p><input type="checkbox" disabled="" /> <code>trade_partners.groupby("Continent").mean()</code></p></li>
<li><p><input type="checkbox" disabled="" /> <code>trade_partners.groupby("Continent").sum()</code></p></li>
<li><p><input type="checkbox" disabled="" /> <code>merged</code></p></li>
<li><p><input type="checkbox" disabled="" /> None of the above.</p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading23_3">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse23_3" aria-expanded="true" aria-controls="collapse23_3">
Click to view the solution.
</button>
</h2>
<div id="collapse23_3" class="accordion-collapse collapse"
aria-labelledby="heading23_3" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer:</strong> <code>trade_partners</code> and
<code>trade_partners.groupby("Continent").sum()</code></p>
<p>Solving this problem is best done by working through each answer
choice and eliminating the incorrect ones. In the problem statement, we
are told that the <code>Proportion</code> column contains floats
representing the proportion of US imports coming from each country.
Since the <code>Proportion</code> column contains proportions, the sum
of that column should equal one. Therefore, the first answer choice is a
correct option. Moving on to the second choice, grouping by the
continent and taking the mean proportion of each continent results in
the proportion column containing mean proportions of groups. Since we
are no longer working with all of the proportions and instead averages,
we can not guarantee the sum of the <code>Proportion</code> column is
one. However, because the third answer choice takes the sum of the
proportions in each Continent, all of the proportions are still
accounted for. As a result, the sum of the proportions column in the new
dataframe would still add to one. Finally, as we determined in the
previous part of the question, the <code>merged</code> dataframe
contains all of the rows in <code>tariffs</code>, but not all of the
rows in <code>trade_partners</code>. Per the problem description the
rows in the <code>Proportion</code> column of
<code>trade_partners</code> should sum to one, since some of those rows
are omitted in <code>merged</code>, it is impossible for the
<code>Proportion</code> column in merged to sum to one.</p>
<hr/>
<h5>Difficulty: ⭐️⭐️</h5>
<p>
</p>
<p>The average score on this problem was 88%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<h3 id="problem-23.4">Problem 23.4</h3>
<p>Write one line of code that would produce an appropriate data
visualization showing the <strong>median reciprocal tariff for each
continent</strong>.</p>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading23_4">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse23_4" aria-expanded="true" aria-controls="collapse23_4">
Click to view the solution.
</button>
</h2>
<div id="collapse23_4" class="accordion-collapse collapse"
aria-labelledby="heading23_4" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer:</strong>
<code>merged.groupby("Continent").median().plot(kind="barh", y="Reciprocal Tariff");</code></p>
<p>This question calls for a visualization which shows the median
reciprocal tariff for each continent. The first part of solving this
problem involves correctly identifying what dataframe to use when
plotting the data. In this case, the problem asks for a link between
<code>Reciprocal Tariff</code>, a column in the <code>tariffs</code>
dataframe, and <code>Continent</code>, a column in the
<code>trade_partners</code> dataframe. Therefore, the
<code>merged</code> dataframe must be used to create the plot. Within
the <code>merged</code> dataframe, the question calls for median
reciprocal tariffs for each continent. Currently, the
<code>merged</code> dataframe has one row for each country rather than
continent. Thus, before plotting the data, the <code>merged</code>
dataframe must be grouped by <code>Continent</code> and aggregated by
the <code>median()</code> to get the median
<code>Reciprocal Tariff</code> for each continent. From there, all that
is left is plotting the data. Since there exists one categorical
variable, <code>Continent</code>, and one numerical variable,
<code>Reciprocal Tariff</code>, a bar chart is appropriate here.
Finally, because the dataframe is already indexed by continent after the
groupby statement, all that needs to be specified within the
<code>plot</code> function is the y variable, in this case,
<code>Reciprocal Tariff</code>.</p>
<hr/>
<h5>Difficulty: ⭐️⭐️⭐️</h5>
<p>
</p>
<p>The average score on this problem was 68%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<hr />
<p class="meta"><em>Source:</em> su24-final — Q1</p>
<h2 id="problem-24">Problem 24</h2>
<p><br></p>
<h3 id="problem-24.1">Problem 24.1</h3>
<p>Fill in the blanks so that the expression below evaluates to the
<em>proportion</em> of stages won by the country with the most stage
wins.</p>
<div class="sourceCode" id="cb40"><pre
class="sourceCode py"><code class="sourceCode python"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a>    stages.groupby(__(i)__).__(ii)__.get(<span class="st">&quot;Type&quot;</span>).__(iii)__ <span class="op">/</span> stages.shape[<span class="dv">0</span>]</span></code></pre></div>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading24_1">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse24_1" aria-expanded="true" aria-controls="collapse24_1">
Click to view the solution.
</button>
</h2>
<div id="collapse24_1" class="accordion-collapse collapse"
aria-labelledby="heading24_1" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer:</strong></p>
<ul>
<li><p><strong>(i)</strong>: <code>"Winner Country"</code><br/>
To calculate the number of stages won by each country, we need to group
the data by the <code>Winner Country</code>. This will allow us to
compute the counts for each group.</p></li>
<li><p><strong>(ii)</strong>: <code>count()</code><br/>
Once the data is grouped, we use the <code>.count()</code> method to
calculate the number of stages won by each country.</p></li>
<li><p><strong>(iii)</strong>: <code>max()</code><br/>
Finds the maximum number of stages won by a single country. Finally, we
divide the maximum stage wins by the total number of stages
(<code>stages.shape[0]</code>) to calculate the proportion of stages won
by the top country.</p></li>
</ul>
<hr/>
<h5>Difficulty: ⭐️</h5>
<p>
</p>
<p>The average score on this problem was 90%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<h3 id="problem-24.2">Problem 24.2</h3>
<p>The distance of a stage alone does not encapsulate its difficulty, as
riders feel more tired as the tour goes on. Because of this, we want to
consider “real distance” a measurement of the length of a stage that
takes into account how far into the tour the riders are. The “real
distance” is calculated with the following process:</p>
<ol type="i">
<li><p>Add one to the stage number.</p></li>
<li><p>Take the square root of the result of (i).</p></li>
<li><p>Multiply the result of (ii) by the raw distance of the
stage.</p></li>
</ol>
<p>Complete the implementation of the function
<code>real_distance</code>, which takes in <code>stages</code> (a
DataFrame), <code>stage</code> (a string, the name of the column
containing stage numbers), and <code>distance</code> (a string, the name
of the column containing stage distances). <code>real_distance</code>
returns a Series containing all of the “real distances” of the stages,
as calculated above.</p>
<div class="sourceCode" id="cb41"><pre
class="sourceCode py"><code class="sourceCode python"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> real_distance(stages, stage, distance):</span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a>         ________</span></code></pre></div>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading24_2">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse24_2" aria-expanded="true" aria-controls="collapse24_2">
Click to view the solution.
</button>
</h2>
<div id="collapse24_2" class="accordion-collapse collapse"
aria-labelledby="heading24_2" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer:</strong>
<code>return stages.get(distance) * np.sqrt(stages.get(stage) + 1)</code></p>
<ul>
<li><p><strong>(i)</strong>: First, We need to add one to the stage
number. The <code>stage</code> parameter specifies the name of the
column containing the stage numbers. <code>stages.get(stage)</code>
retrieves this column as a Series, and we can directly add 1 to each
element in the series by <code>stages.get(stage) + 1</code></p></li>
<li><p><strong>(ii)</strong>: Then, to take the square root of the
result of (i), we can use
<code>np.sqrt(stages.get(stage) + 1)</code></p></li>
<li><p><strong>(iii)</strong>: Finally, we want to multiply the result
of (ii) by the raw distance of the stage. The <code>distance</code>
parameter specifies the name of the column containing the raw distances
of each stage. <code>stages.get(distance)</code> retrieves this column
as a pandas Series, and we can directly multiply it by
<code>np.sqrt(stages.get(stage) + 1)</code>.</p></li>
</ul>
<hr/>
<h5>Difficulty: ⭐️⭐️</h5>
<p>
</p>
<p>The average score on this problem was 89%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<h3 id="problem-24.3">Problem 24.3</h3>
<p>Sometimes, stages are repeated in different editions of the Tour de
France, meaning that there are some pairs of <code>"Origin"</code> and
<code>"Destination"</code> that appear more than once in
<code>stages</code>. Fill in the blanks so that the expression below
evaluates how often the most common <code>"Origin"</code> and
<code>"Destination"</code> pair in the <code>stages</code> DataFrame
appears.</p>
<div class="sourceCode" id="cb42"><pre
class="sourceCode py"><code class="sourceCode python"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a>stages.groupby(__(i)__).__(ii)__.sort_values(by <span class="op">=</span> <span class="st">&quot;Date&quot;</span>).get(<span class="st">&quot;Type&quot;</span>).iloc[__(iii)__]</span></code></pre></div>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading24_3">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse24_3" aria-expanded="true" aria-controls="collapse24_3">
Click to view the solution.
</button>
</h2>
<div id="collapse24_3" class="accordion-collapse collapse"
aria-labelledby="heading24_3" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer:</strong></p>
<ul>
<li><p><strong>(i)</strong>:
<code>["Origin", "Destination"]</code><br/>
To analyze the frequency of stages with the same origin and destination,
we need to group the data by the columns
<code>["Origin", "Destination"]</code>. This groups the stages into
unique pairs of origin and destination.</p></li>
<li><p><strong>(ii)</strong>: <code>count()</code><br/>
After grouping, we apply the <code>.count()</code> method to calculate
how many times each pair of <code>["Origin", "Destination"]</code>
appears in the dataset. The result is the frequency of each
pair.</p></li>
<li><p><strong>(iii)</strong>: <code>-1</code><br/>
After obtaining the frequencies, we sort the resulting groups by their
counts in ascending order (this is the default behavior of
<code>.sort_values()</code>). The most common pair will then be the last
entry in the sorted result. Using <code>.get("Type")</code> extracts the
series of counts, and <code>.iloc[-1]</code> retrieves the count of the
most common pair, which is at the last position of the sorted
series.</p></li>
</ul>
<hr/>
<h5>Difficulty: ⭐️⭐️</h5>
<p>
</p>
<p>The average score on this problem was 84%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<h3 id="problem-24.4">Problem 24.4</h3>
<p>Fill in the blanks so that the value of <code>mystery_three</code> is
the <code>"Destination"</code> of the longest stage before Stage 12.</p>
<div class="sourceCode" id="cb43"><pre
class="sourceCode py"><code class="sourceCode python"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a>    mystery <span class="op">=</span> stages[stages.get(__(i)__) <span class="op">&lt;</span> <span class="dv">12</span>]</span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a>    mystery_two <span class="op">=</span> mystery.sort_values(by <span class="op">=</span> <span class="st">&quot;Distance&quot;</span>, ascending <span class="op">=</span> __(ii)__)</span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a>    mystery_three <span class="op">=</span> mystery_two.get(__(iii)__).iloc[<span class="op">-</span><span class="dv">1</span>]</span></code></pre></div>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading24_4">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse24_4" aria-expanded="true" aria-controls="collapse24_4">
Click to view the solution.
</button>
</h2>
<div id="collapse24_4" class="accordion-collapse collapse"
aria-labelledby="heading24_4" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer:</strong></p>
<ul>
<li><p><strong>(i)</strong>: <code>"Stage"</code><br/>
To filter the DataFrame to include only rows corresponding to stages
before Stage 12, we use the <code>"Stage"</code> column. The condition
<code>stages.get("Stage") &lt; 12</code> creates a boolean mask that
selects only the rows where the stage number is less than 12.</p></li>
<li><p><strong>(ii)</strong>: <code>True</code><br/>
To find the longest stage, the rows need to be sorted by the
<code>"Distance"</code> column. Setting <code>ascending=True</code>
ensures that shorter stages come first and the longest stage appears
last in the sorted DataFrame.</p></li>
<li><p><strong>(iii)</strong>: <code>"Destination"</code><br/>
After sorting, we want to retrieve the <code>"Destination"</code> of the
longest stage. Using <code>.get("Destination")</code> retrieves the
<code>"Destination"</code> column, and <code>.iloc[-1]</code> accesses
the last row in the sorted DataFrame, corresponding to the longest stage
before Stage 12.</p></li>
</ul>
<hr/>
<h5>Difficulty: ⭐️</h5>
<p>
</p>
<p>The average score on this problem was 92%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<hr />
<p class="meta"><em>Source:</em> su24-midterm — Q5</p>
<h2 id="problem-25">Problem 25</h2>
<p><br></p>
<h3 id="problem-25.1">Problem 25.1</h3>
<p>Fill in the blanks so that the sentence below correctly describes the
meaning of <code>mystery</code>.</p>
<p>“The __(i)__ __(ii)__ of the __(iii)__ __(iv)__ .”</p>
<div class="sourceCode" id="cb44"><pre
class="sourceCode py"><code class="sourceCode python"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a>mystery <span class="op">=</span> kart.groupby(<span class="st">&quot;Region&quot;</span>).mean().get(<span class="st">&quot;Ranking&quot;</span>).<span class="bu">min</span>()</span></code></pre></div>
<p>What goes in (i)?</p>
<ul class="task-list">
<li><p><input type="radio" disabled="" /> average</p></li>
<li><p><input type="radio" disabled="" /> median</p></li>
<li><p><input type="radio" disabled="" /> lowest</p></li>
<li><p><input type="radio" disabled="" /> highest</p></li>
</ul>
<p>What goes in (ii)?</p>
<ul class="task-list">
<li><p><input type="radio" disabled="" /> university</p></li>
<li><p><input type="radio" disabled="" /> team</p></li>
<li><p><input type="radio" disabled="" /> region</p></li>
<li><p><input type="radio" disabled="" /> ranking</p></li>
</ul>
<p>What goes in (iii)?</p>
<ul class="task-list">
<li><p><input type="radio" disabled="" /> average</p></li>
<li><p><input type="radio" disabled="" /> median</p></li>
<li><p><input type="radio" disabled="" /> worst</p></li>
<li><p><input type="radio" disabled="" /> best</p></li>
</ul>
<p>What goes in (iv)?</p>
<ul class="task-list">
<li><p><input type="radio" disabled="" /> university</p></li>
<li><p><input type="radio" disabled="" /> team</p></li>
<li><p><input type="radio" disabled="" /> region</p></li>
<li><p><input type="radio" disabled="" /> ranking</p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading25_1">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse25_1" aria-expanded="true" aria-controls="collapse25_1">
Click to view the solution.
</button>
</h2>
<div id="collapse25_1" class="accordion-collapse collapse"
aria-labelledby="heading25_1" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer:</strong></p>
<ul>
<li><strong>(i)</strong> average</li>
<li><strong>(ii)</strong> ranking</li>
<li><strong>(iii)</strong> best</li>
<li><strong>(iv)</strong> region</li>
</ul>
<p><code>mystery</code> groups by the <code>"Region"</code>, calculates
the mean values and retrieves the <code>"Ranking"</code> column. So we
have the average ranking for all the regions. Now we retrieve the
minimum value of this column. Note that in this context, a lower average
ranking indicates a better team. Hence, we get “the average ranking of
the best region”.</p>
<hr/>
<h5>Difficulty: ⭐️⭐️⭐️</h5>
<p>
</p>
<p>The average score on this problem was 67%. </p>
<hr/>
<h5>Difficulty:
⭐️</h5>
<p>The average score on this problem was 95%. </p>
<hr/>
<h5>Difficulty:
⭐️⭐️⭐️⭐️⭐️</h5>
<p>The average score on this problem was 14%.
</p>
<hr/>
<h5>Difficulty: ⭐️</h5>
<p>The average score on this problem was
95%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<h3 id="problem-25.2">Problem 25.2</h3>
<p>Fill in the blank in the code snippet below so that
<code>my_bool</code> is <code>True</code> if there is at least one
university with two teams in the same division, and <code>False</code>
if there are no universities with two teams in the same division. Your
answer must include the use of <code>.groupby()</code> in order to
receive credit.</p>
<div class="sourceCode" id="cb45"><pre
class="sourceCode py"><code class="sourceCode python"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a>my_df <span class="op">=</span> ______</span></code></pre></div>
<div class="sourceCode" id="cb46"><pre
class="sourceCode py"><code class="sourceCode python"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a>my_bool <span class="op">=</span> my_df.get(<span class="st">&quot;Team&quot;</span>).<span class="bu">max</span>() <span class="op">&gt;</span> <span class="dv">1</span></span></code></pre></div>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading25_2">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse25_2" aria-expanded="true" aria-controls="collapse25_2">
Click to view the solution.
</button>
</h2>
<div id="collapse25_2" class="accordion-collapse collapse"
aria-labelledby="heading25_2" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer:</strong>
<code>kart.groupby(["University", "Division"]).count()</code></p>
<p>In the second line of code, we get the column <code>“Team”</code> and
check whether its maximum value is greater than 1. In other words, it is
checking whether there are any universities with multiple teams in a
division. This means that our input DataFrame needs to have a numeric
column <code>"Team"</code> that denotes the number of teams for each
university for each division. This means we need to use
<code>groupby()</code>. Since we want this information for each
university within each division, we need to groupby both
<code>“University”</code> and <code>“Division”</code>. Then, because we
want the number of teams within each division within each university,
you want to apply the <code>count()</code> aggregate. Now all the
columns in this DataFrame contain the number of teams per division per
university since count notes the number of observations in each
category.</p>
<p>From here, <code>my_bool</code> can take this transformed DataFrame,
get the <code>“Team”</code> column that contains the number of teams per
division per university and check if any of them are greater than 1 (by
simply getting the maximum value of this column) and checking whether it
is greater than 1.</p>
<hr/>
<h5>Difficulty: ⭐️⭐️⭐️</h5>
<p>
</p>
<p>The average score on this problem was 57%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<hr />
<p class="meta"><em>Source:</em> su24-midterm — Q7</p>
<h2 id="problem-26">Problem 26</h2>
<p>The DataFrame <code>div_one</code>, shown below to the
<strong>left</strong>, contains the six Division 1 teams from
<code>kart</code>, with just the <code>"Team"</code> and
<code>"Region"</code> columns selected.</p>
<p>The DataFrame <code>coach</code>, shown below to the
<strong>right</strong>, contains some additional information about the
coaches of the teams in <code>div_one</code>, with a piece of info
missing.</p>
<center>
<table>
<tr>
<td><img src='../../assets/images/su24-midterm/div_one.png' height=250></td>
<td><img src='../../assets/images/su24-midterm/coaches.png' height=250></td>
</tr>
</table>
</center>
<p><br></p>
<h3 id="problem-26.1">Problem 26.1</h3>
<p>Fill in the blank in the <code>Region</code> column with either
<code>South</code>, <code>West</code>, <code>East</code>, or
<code>Midwest</code> so that the DataFrame
<code>div_one.merge(coach, on="Region")</code> has:</p>
<ul>
<li>8 rows: ____<br />
</li>
<li>9 rows: ____<br />
</li>
<li>10 rows: ____<br />
</li>
<li>11 rows: ____</li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading26_1">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse26_1" aria-expanded="true" aria-controls="collapse26_1">
Click to view the solution.
</button>
</h2>
<div id="collapse26_1" class="accordion-collapse collapse"
aria-labelledby="heading26_1" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer:</strong></p>
<ul>
<li>8 rows: South<br/>
</li>
<li>9 rows: East<br/>
</li>
<li>10 rows: West<br/>
</li>
<li>11 rows: Midwest</li>
</ul>
<p>To determine the number of rows after merging two DataFrames
(<code>div_one</code> and <code>coach</code>) on the column
<code>"Region"</code>, we need to calculate how many matches occur for
each region. When performing the merge, each row from
<code>div_one</code> will be combined with every matching row in
<code>coach</code>. The total number of rows in the resulting DataFrame
will depend on how many times each region value in <code>div_one</code>
has matching rows in <code>coach</code>.</p>
<ol type="1">
<li><strong>South (8 rows):</strong>
<ul>
<li><code>div_one</code> has 3 rows with Midwest, and 1 row with
East.<br/>
</li>
<li><code>coach</code> has 2 rows with Midwest, and 2 rows with
East.<br/>
</li>
<li>For each Midwest row in <code>div_one</code>, it matches with both
Midwest rows in <code>coach</code>, resulting in <code>3×2=6</code>
matches.<br/>
</li>
<li>The single East row in <code>div_one</code> matches with the 2 East
rows in <code>coach</code>, contributing <code>1×2=2</code>
matches.<br/>
</li>
<li><strong>Total for South:</strong>
<code>3 * 2(Midwest) + 1 * 2(East) = 8</code> rows.</li>
</ul></li>
<li><strong>East (9 rows):</strong>
<ul>
<li><code>div_one</code> has 3 rows with Midwest, and 1 row with
East.<br/>
</li>
<li><code>coach</code> has 2 rows with Midwest, and 3 rows with
East.<br/>
</li>
<li>For each Midwest row in <code>div_one</code>, it matches with both
Midwest rows in <code>coach</code>, giving <code>3×2=6</code>
matches.<br/>
</li>
<li>The single East row in <code>div_one</code> matches with the 3 East
rows in <code>coach</code>, contributing <code>1×3=3</code>
matches.<br/>
</li>
<li><strong>Total for East:</strong>
<code>3 * 2(Midwest) + 1 * 3(East) = 9</code> rows.</li>
</ul></li>
<li><strong>West (10 rows):</strong>
<ul>
<li><code>div_one</code> has 3 rows with Midwest, 1 row with East, and 2
rows with West.<br/>
</li>
<li><code>coach</code> has 2 rows with Midwest, 2 rows with East, and 1
row with West.<br/>
</li>
<li>For each Midwest row in <code>div_one</code>, it matches with both
Midwest rows in <code>coach</code>, resulting in <code>3×2=6</code>
matches.<br/>
</li>
<li>The single East row in <code>div_one</code> matches with the 2 East
rows in <code>coach</code>, contributing <code>1×2=2</code>
matches.<br/>
</li>
<li>The 2 West rows in <code>div_one</code> each match with the single
West row in <code>coach</code>, contributing <code>2×1=2</code>
matches.<br/>
</li>
<li><strong>Total for West:</strong>
<code>3 * 2(Midwest) + 1 * 2(East) + 2 * 1(West) = 10</code> rows.</li>
</ul></li>
<li><strong>Midwest (11 rows):</strong>
<ul>
<li><code>div_one</code> has 3 rows with Midwest, and 1 row with
East.<br/>
</li>
<li><code>coach</code> has 3 rows with Midwest, and 2 rows with
East.<br/>
</li>
<li>For each Midwest row in <code>div_one</code>, it matches with all
three Midwest rows in <code>coach</code>, resulting in
<code>3×3=9</code> matches.<br/>
</li>
<li>The single East row in <code>div_one</code> matches with the 2 East
rows in <code>coach</code>, contributing <code>1×2=2</code>
matches.<br/>
</li>
<li><strong>Total for Midwest:</strong>
<code>3 * 3(Midwest) + 1 * 2(East) = 11</code> rows.</li>
</ul></li>
</ol>
<hr/>
<h5>Difficulty: ⭐️⭐️⭐️</h5>
<p>
</p>
<p>The average score on this problem was 61%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<h3 id="problem-26.2">Problem 26.2</h3>
<p>What is the value of the following Python expression?</p>
<div class="sourceCode" id="cb47"><pre
class="sourceCode py"><code class="sourceCode python"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a>coach.merge(coach, on<span class="op">=</span><span class="st">&quot;Coach&quot;</span>).merge(coach, on<span class="op">=</span><span class="st">&quot;Coach&quot;</span>).shape[<span class="dv">0</span>]</span></code></pre></div>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading26_2">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse26_2" aria-expanded="true" aria-controls="collapse26_2">
Click to view the solution.
</button>
</h2>
<div id="collapse26_2" class="accordion-collapse collapse"
aria-labelledby="heading26_2" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer:</strong> 12</p>
<p><strong>First Merge:</strong> The expression starts by merging the
coach DataFrame with itself on the “Coach” column. Each row in coach
that has the same coach will match with every other row (including
itself) that has the same coach.</p>
<ul>
<li>Matching process:
<ul>
<li>Coach Jason (rows 0 and 2): Matches with each other, creating 2×2=4
matches.</li>
<li>Coach Jack (row 1): Since this row only matches with itself, it
creates 1×1=1 match.</li>
<li>Coach Ashley (row 3): Also creates 1×1=1 match.</li>
<li>Coach Nick (row 4): Again, 1×1=1 match.</li>
<li>Coach Zoe (row 5): Another 1×1=1 match.</li>
</ul></li>
</ul>
<p>Total rows from this merge: 4+1+1+1+1=8 rows.</p>
<p><strong>Second Merge:</strong> Now we take the result of the first
merge (which has 8 rows) and merge it again with the original coach
DataFrame on the “Coach” column.</p>
<ul>
<li>Matching process:
<ul>
<li>Coach Jason 4 rows (from the first merge): each of these rows will
match with the 2 rows for “Coach Jason” in the original coach DataFrame.
This results in 4×2=8 matches.</li>
<li>Coach Jack, Coach Ashley, Coach Nick, and Coach Zoe(all have single
row): each will match with their corresponding rows in the original
coach DataFrame. Since each has 1×1=1 match, we add 4 more rows in
total.</li>
</ul></li>
</ul>
<p>Total rows from this merge: 8+1+1+1+1=12 rows.</p>
<p><strong>Result:</strong><br/>
The expression returns the number of rows in the final merged
DataFrame.<br/>
Result: The final DataFrame has 12 rows.</p>
<hr/>
<h5>Difficulty: ⭐️⭐️⭐️⭐️⭐️</h5>
<p>
</p>
<p>The average score on this problem was 19%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<hr />
<h2 id="problem-27">Problem 27</h2>
<p>You are given a table called books that contains columns
<code>'author'</code> (<code>str</code>), <code>'title'</code>
(<code>str</code>), <code>'num_chapters'</code> (<code>int</code>), and
<code>'publication_year'</code> (<code>int</code>). <br></p>
<h3 id="problem-27.1">Problem 27.1</h3>
<p>What will be the output of the following code?
<code>books.groupby(“publication_year”).mean().shape[1]</code></p>
<ul class="task-list">
<li><p><input type="radio" disabled="" /> <code>1</code></p></li>
<li><p><input type="radio" disabled="" /> <code>2</code></p></li>
<li><p><input type="radio" disabled="" /> <code>3</code></p></li>
<li><p><input type="radio" disabled="" /> <code>4</code></p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading27_1">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse27_1" aria-expanded="true" aria-controls="collapse27_1">
Click to view the solution.
</button>
</h2>
<div id="collapse27_1" class="accordion-collapse collapse"
aria-labelledby="heading27_1" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer: </strong> <code>1</code></p>
<p>The output will return 1. Notice that the final function call is to
<code>.shape[1]</code>. We know that <code>.shape[1]</code> is a call to
see how many columns are in the resulting data frame. When we group by
publication year, there is only one column that will be aggregated by
the groupby call (which is the <code>'num_chapters'</code> column). The
other columns are string, and therefore, will not be aggregated in the
groupby call (since you can’t take the mean of a string). Consequently
<code>.shape[1]</code> will only result one column for the mean of the
<code>'num_chapters'</code> column.</p>
<hr/>
<h5>Difficulty: ⭐️⭐️⭐️</h5>
<p>
</p>
<p>The average score on this problem was 67%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<hr />
<h2 id="problem-28">Problem 28</h2>
<p>You are given a table called books that contains columns
<code>'author'</code> (<code>str</code>), <code>'title'</code>
(<code>str</code>), <code>'num_chapters'</code> (<code>int</code>), and
<code>'publication_year'</code> (<code>int</code>). <br></p>
<h3 id="problem-28.1">Problem 28.1</h3>
<p>What will be the output of the following code?
<code>books.groupby(“publication_year”).mean().shape[1]</code></p>
<ul class="task-list">
<li><p><input type="radio" disabled="" /> <code>1</code></p></li>
<li><p><input type="radio" disabled="" /> <code>2</code></p></li>
<li><p><input type="radio" disabled="" /> <code>3</code></p></li>
<li><p><input type="radio" disabled="" /> <code>4</code></p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading28_1">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse28_1" aria-expanded="true" aria-controls="collapse28_1">
Click to view the solution.
</button>
</h2>
<div id="collapse28_1" class="accordion-collapse collapse"
aria-labelledby="heading28_1" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer: </strong> <code>1</code></p>
<p>The output will return 1. Notice that the final function call is to
<code>.shape[1]</code>. We know that <code>.shape[1]</code> is a call to
see how many columns are in the resulting data frame. When we group by
publication year, there is only one column that will be aggregated by
the groupby call (which is the <code>'num_chapters'</code> column). The
other columns are string, and therefore, will not be aggregated in the
groupby call (since you can’t take the mean of a string). Consequently
<code>.shape[1]</code> will only result one column for the mean of the
<code>'num_chapters'</code> column.</p>
<hr/>
<h5>Difficulty: ⭐️⭐️⭐️</h5>
<p>
</p>
<p>The average score on this problem was 67%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<h3 id="problem-28.2">Problem 28.2</h3>
<p>Which of the following strategies would work to compute the absolute
difference in the average number of chapters per book for authors “Dean
Koontz” and “Charles Dickens”?</p>
<ul class="task-list">
<li><p><input type="radio" disabled="" /> group by <code>'author'</code>, aggregate with <code>.mean()</code>,
use <code>get</code> on <code>'num_chapters'</code> column compute the
absolute value of the difference between
<code>iloc["Charles Dickens"]</code> and
<code>iloc["Dean Koontz"]</code></p></li>
<li><p><input type="radio" disabled="" /> do two queries to get two separate tables (one for each of “Dean
Koontz” and “Charles Dickens”), use <code>get</code> on the
<code>'num_chapters'</code> column of each table, use the Series method
<code>.mean()</code> on each, compute the absolute value of the
difference in these two means</p></li>
<li><p><input type="radio" disabled="" /> group by both <code>'author'</code> and <code>'title'</code>,
aggregate with <code>.mean()</code>, use get on
<code>'num_chapters'</code> column, use <code>loc</code> twice to find
values in that column corresponding to “Dean Koontz” and “Charles
Dickens”, compute the absolute value of the difference in these two
values</p></li>
<li><p><input type="radio" disabled="" /> query using a compound condition to get all books corresponding to
“Dean Koontz” or “Charles Dickens”, group by <code>'author'</code>,
aggregate with <code>.mean()</code>, compute absolute value of the
difference in <code>index[0]</code> and <code>index[1]</code></p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading28_2">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse28_2" aria-expanded="true" aria-controls="collapse28_2">
Click to view the solution.
</button>
</h2>
<div id="collapse28_2" class="accordion-collapse collapse"
aria-labelledby="heading28_2" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer: </strong> do two queries to get two separate tables
(one for each of “Dean Koontz” and “Charles Dickens”), use
<code>get</code> on the <code>'num_chapters'</code> column of each
table, use the Series method <code>.mean()</code> on each, compute the
absolute value of the difference in these two means</p>
<p>Logically, we want to somehow separate data for author “Dean Koontz”
and “Charles Dickens”. (If we don’t we’ll be taking a mean that includes
the chapters of books from both authors.) To achieve this separation, we
can create two separate tables with a query that specifies a value on
the <code>'author'</code> column. Now having two separate tables, we can
aggregate on the <code>'num_chapters'</code> (the column of interest).
To get the <code>'num_chapters'</code> column we can use the
<code>get</code> method. To actually acquire the mean of the
<code>'num_chapters'</code> column we can evoke the <code>.mean()</code>
call. </p>
<hr/>
<h5>Difficulty: ⭐️⭐️</h5>
<p>The average score on this problem
was 80%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<h3 id="problem-28.3">Problem 28.3</h3>
<p>Which of the following will produce the same value as the total
number of books in the table?</p>
<ul class="task-list">
<li><p><input type="radio" disabled="" /> <code>books.groupby('Title').count().shape[0]</code></p></li>
<li><p><input type="radio" disabled="" /> <code>books.groupby('Author').count().shape[0]</code></p></li>
<li><p><input type="radio" disabled="" /> <code>books.groupby(['Author, 'Title']).count().shape[0]</code></p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading28_3">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse28_3" aria-expanded="true" aria-controls="collapse28_3">
Click to view the solution.
</button>
</h2>
<div id="collapse28_3" class="accordion-collapse collapse"
aria-labelledby="heading28_3" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer: </strong>
<code>books.groupby(['Author, 'Title']).count().shape[0]</code></p>
<p>The key in this question is to understand that different authors can
create books with the same name. The first two options check for each
unique book title (the first response) and check for each unique other
(the second response). To ensure we have all unique author and title
pairs we must group based on both <code>'Author'</code> and
<code>'Title'</code>. To actually get the number of rows we can take
<code>.shape[0]</code>. </p>
<hr/>
<h5>Difficulty: ⭐️⭐️⭐️</h5>
<p>The average
score on this problem was 56%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<hr />
<h2 id="problem-29">Problem 29</h2>
<p>If we merge a table with <code>n</code> rows with a table with
<code>m</code> rows, how many rows does the resulting table have?</p>
<ul class="task-list">
<li><p><input type="radio" disabled="" /> <code>n</code></p></li>
<li><p><input type="radio" disabled="" /> <code>m</code></p></li>
<li><p><input type="radio" disabled="" /> <code>max(m,n)</code></p></li>
<li><p><input type="radio" disabled="" /> <code>m * n</code></p></li>
<li><p><input type="radio" disabled="" /> not enough information to tell</p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading29">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse29" aria-expanded="true" aria-controls="collapse29">
Click to view the solution.
</button>
</h2>
<div id="collapse29" class="accordion-collapse collapse"
aria-labelledby="heading29" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer: </strong> not enough information to tell</p>
<p>The question does not provide enough information to know the
resulting table size with certainty. When merging two tables together,
the tables can be merged with a inner, left, right, and outer join. Each
of these joins will produce a different amount of rows. Since the
question does not provide the type of join, it is impossible to tell the
resulting table size.</p>
<hr/>
<h5>Difficulty: ⭐️⭐️⭐️</h5>
<p>
</p>
<p>The average score on this problem was 74%.</p>
</div>
</div>
</div>
</div>
<hr />
<h2 id="problem-30">Problem 30</h2>
<p>Give an example of a dataset and a question you would want to answer
about that dataset which you would answer by grouping with subgroups
(using multiple columns in the <code>groupby</code> command). Explain
how you would use the <code>groupby</code> command to answer your
question.</p>
<p>Creative responses that are different than ones we’ve already seen in
this class will earn the most credit.</p>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading30">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse30" aria-expanded="true" aria-controls="collapse30">
Click to view the solution.
</button>
</h2>
<div id="collapse30" class="accordion-collapse collapse"
aria-labelledby="heading30" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer: </strong> There are many possible correct answers.
Below are some student responses that earned full credit, lightly edited
for clarity.</p>
<hr/>
<p><i> Consider the dataset of Olympic medals (Bronze, Silver, Gold)
that a country won for a specific sport, with columns
<code>'sport'</code>, <code>'country'</code>,
<code>'medals'</code>.</i></p>
<p><i> Question: In which sport did the US win the most medals?</i></p>
<p><i>We can group by country and then subgroup by sport. We can then
use a combination of <code>reset_index()</code> and
<code>sort_values(by = 'medals')</code> and then use <code>.get</code>
and <code>.iloc[-1]</code> to get the our answer to the
question.</i></p>
<hr/>
<p><i> Given a data set of cell phone purchase volume at every
electronics store, we might want to find the difference in popularity of
Samsung phones and iPhones in every state. I would use the
<code>groupby</code> command to first group by state, followed by phone
brand, and then aggregate with the <code>sum()</code> method. The
resulting table would show the total iPhone and Samsung phone sales
separately for each state which I could then use to calculate the
difference in proportion of each brand’s sales volumes.</i></p>
<hr/>
<p><i> You are given a table called <code>cars</code> with columns:
<code>'brands'</code> (Toyota, Honda, etc.), <code>'model'</code>
(Prius, Accord, etc.), <code>'price'</code> of the car, and
<code>'fuel_type'</code> (gas, hybrid, electric). Since you are
environmentally friendly you only want cars that are electric, but you
want to find the cheapest one. Find the brand that has the cheapest
average price for an electric car.</i></p>
<p><i>You want to <code>groupby</code> on both <code>'brands'</code> and
<code>'fuel_type'</code> and use the aggregate command
<code>mean()</code> to find the average price per fuel type for each
brand. Then you would find only the electric fuel types and sort values
to find the cheapest. </i></p>
<hr/>
<h5>Difficulty: ⭐️⭐️</h5>
<p>
</p>
<p>The average score on this problem was 81%.</p>
</div>
</div>
</div>
</div>
<hr />
<h2 id="problem-31">Problem 31</h2>
<p><br></p>
<h3 id="problem-31.1">Problem 31.1</h3>
<p>Consider the function <code>unknown</code>, defined below.</p>
<div class="sourceCode" id="cb48"><pre
class="sourceCode py"><code class="sourceCode python"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> unknown(df):</span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a>    grouped <span class="op">=</span> plum.groupby(<span class="st">&#39;Opp&#39;</span>).<span class="bu">max</span>().get([<span class="st">&#39;Date&#39;</span>, <span class="st">&#39;PTS&#39;</span>])</span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.array(grouped.reset_index().index)[df]</span></code></pre></div>
<p>What does <code>unknown(3)</code> evaluate to?</p>
<ul class="task-list">
<li><p><input type="radio" disabled="" /> <code>'2021-06-05'</code></p></li>
<li><p><input type="radio" disabled="" /> <code>'WAS'</code></p></li>
<li><p><input type="radio" disabled="" /> The date on which Kelsey Plum scored the most points</p></li>
<li><p><input type="radio" disabled="" /> The three-letter code of the opponent on which Kelsey Plum scored the
most points</p></li>
<li><p><input type="radio" disabled="" /> The number 0</p></li>
<li><p><input type="radio" disabled="" /> The number 3</p></li>
<li><p><input type="radio" disabled="" /> An error</p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading31_1">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse31_1" aria-expanded="true" aria-controls="collapse31_1">
Click to view the solution.
</button>
</h2>
<div id="collapse31_1" class="accordion-collapse collapse"
aria-labelledby="heading31_1" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer:</strong> The number 3</p>
<p><code>plum.groupby('Opp').max()</code> finds the largest value in the
<code>'Date'</code>, <code>'Home'</code>, <code>'Won'</code>,
<code>'PTS'</code>, <code>'AST'</code>, and <code>'TOV'</code> columns
for each unique <code>'Opp'</code> (independently for each column).
<code>grouped = plum.groupby('Opp').max().get(['Date', 'PTS'])</code>
keeps only the <code>'Date'</code> and <code>'PTS'</code> columns. Note
that in <code>grouped</code>, the index is <code>'Opp'</code>, the
column we grouped on.</p>
<p>When <code>grouped.reset_index()</code> is called, the index is
switched back to the default of 0, 1, 2, 3, 4, and so on. Then,
<code>grouped.reset_index().index</code> is an <code>Index</code>
containing the numbers <code>[0, 1, 2, 3, 4, ...]</code>, and
<code>np.array(grouped.reset_index().index)</code> is
<code>np.array([0, 1, 2, 3, 4, ...])</code>. In this array, the number
at position <code>i</code> is just <code>i</code>, so the number at
position <code>df</code> is <code>df</code>. Here, <code>df</code> is
the argument to <code>unknown</code>, and we were asked for the value of
<code>unknown(3)</code>, so the correct answer is the number at position
3 in <code>np.array([0, 1, 2, 3, 4, ...])</code> which is 3.</p>
<p>Note that if we asked for <code>unknown(50)</code> (or
<code>unknown(k)</code>, where <code>k</code> is any integer above 30),
the answer would be “An error”, since <code>grouped</code> could not
have had 51 rows. <code>plum</code> has 31 rows, so <code>grouped</code>
has at most 31 rows (but likely less, since Kelsey Plum’s team likely
played the same opponent multiple times).</p>
<hr/>
<h5>Difficulty: ⭐️⭐️⭐️</h5>
<p>
</p>
<p>The average score on this problem was 72%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<h3 id="problem-31.2">Problem 31.2</h3>
<p>For your convenience, we show the first few rows of <code>plum</code>
again below.</p>
<center><img src='../../assets/images/wi22-final/plum.png' width=40%></center>
<p>Suppose that Plum’s team, the Las Vegas Aces, won at least one game
in Las Vegas and lost at least one game in Las Vegas. Also, suppose they
won at least one game in an opponent’s arena and lost at least one game
in an opponent’s arena.</p>
<p>Consider the DataFrame <code>home_won</code>, defined below.</p>
<div class="sourceCode" id="cb49"><pre
class="sourceCode py"><code class="sourceCode python"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a>home_won <span class="op">=</span> plum.groupby([<span class="st">&#39;Home&#39;</span>, <span class="st">&#39;Won&#39;</span>]).mean().reset_index()</span></code></pre></div>
<ol type="1">
<li><p>How many rows does <code>home_won</code> have?</p></li>
<li><p>How many columns does <code>home_won</code> have?</p></li>
</ol>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading31_2">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse31_2" aria-expanded="true" aria-controls="collapse31_2">
Click to view the solution.
</button>
</h2>
<div id="collapse31_2" class="accordion-collapse collapse"
aria-labelledby="heading31_2" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer:</strong> 4 rows and 5 columns.</p>
<p><code>plum.groupby(['Home', 'Won']).mean()</code> contains one row
for every unique combination of <code>'Home'</code> and
<code>'Won'</code>. There are two values of <code>'Home'</code> -
<code>True</code> and <code>False</code> – and two values of
<code>'Won'</code> – <code>True</code> and <code>False</code> – leading
to 4 combinations. We can assume that there was at least one row in
<code>plum</code> for each of these 4 combinations due to the assumption
given in the problem:</p>
<p><em>Suppose that Plum’s team, the Las Vegas Aces, won at least one
game in Las Vegas and lost at least one game in Las Vegas. Also, suppose
they won at least one game in an opponent’s arena and lost at least one
game in an opponent’s arena.</em></p>
<p><code>plum</code> started with 7 columns: <code>'Date'</code>,
<code>'Opp'</code>, <code>'Home'</code>, <code>'Won'</code>,
<code>'PTS'</code>, <code>'AST'</code>, and <code>'TOV'</code>. After
grouping by <code>['Home', 'Won']</code> and using <code>.mean()</code>,
<code>'Home'</code> and <code>'Won'</code> become the index. The
resulting DataFrame contains all of the columns that the
<code>.mean()</code> aggregation method can work on. We cannot take the
mean of <code>'Date'</code> and <code>'Opp'</code>, because those
columns are strings, so
<code>plum.groupby(['Home', 'Won']).mean()</code> contains a
<code>MultiIndex</code> with 2 “columns” – <code>'Home'</code> and
<code>'Won'</code> – and 3 regular columns – <code>'PTS'</code>
<code>'AST'</code>, and <code>'TOV'</code>. Then, when using
<code>.reset_index()</code>, <code>'Home'</code> and <code>'Won'</code>
are restored as regular columns, meaning that
<code>plum.groupby(['Home', 'Won']).mean().reset_index()</code> has
<span class="math inline">2 + 3 = 5</span> columns.</p>
<hr/>
<h5>Difficulty: ⭐️⭐️</h5>
<p>
</p>
<p>The average score on this problem was 78%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<h3 id="problem-31.3">Problem 31.3</h3>
<p>Consider the DataFrame <code>home_won</code> once again.</p>
<div class="sourceCode" id="cb50"><pre
class="sourceCode py"><code class="sourceCode python"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a>home_won <span class="op">=</span> plum.groupby([<span class="st">&#39;Home&#39;</span>, <span class="st">&#39;Won&#39;</span>]).mean().reset_index()</span></code></pre></div>
<p>Now consider the DataFrame <code>puzzle</code>, defined below. Note
that the only difference between <code>home_won</code> and
<code>puzzle</code> is the use of <code>.count()</code> instead of
<code>.mean()</code>.</p>
<div class="sourceCode" id="cb51"><pre
class="sourceCode py"><code class="sourceCode python"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a>puzzle <span class="op">=</span> plum.groupby([<span class="st">&#39;Home&#39;</span>, <span class="st">&#39;Won&#39;</span>]).count().reset_index()</span></code></pre></div>
<p>How do the number of rows and columns in <code>home_won</code>
compare to the number of rows and columns in <code>puzzle</code>?</p>
<ul class="task-list">
<li><p><input type="radio" disabled="" /> <code>home_won</code> and <code>puzzle</code> have the same number of
rows and columns</p></li>
<li><p><input type="radio" disabled="" /> <code>home_won</code> and <code>puzzle</code> have the same number of
rows, but a different number of columns</p></li>
<li><p><input type="radio" disabled="" /> <code>home_won</code> and <code>puzzle</code> have the same number of
columns, but a different number of rows</p></li>
<li><p><input type="radio" disabled="" /> <code>home_won</code> and <code>puzzle</code> have both a different
number of rows and a different number of columns</p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading31_3">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse31_3" aria-expanded="true" aria-controls="collapse31_3">
Click to view the solution.
</button>
</h2>
<div id="collapse31_3" class="accordion-collapse collapse"
aria-labelledby="heading31_3" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer: </strong> <code>home_won</code> and
<code>puzzle</code> have the same number of rows, but a different number
of columns</p>
<p>All that changed between <code>home_won</code> and
<code>puzzle</code> is the aggregation method. The aggregation method
has no influence on the number of rows in the output DataFrame, as there
is still one row for each of the 4 unique combinations of
<code>'Home'</code> and <code>'Won'</code>.</p>
<p>However, <code>puzzle</code> has 7 columns, instead of 5. In the
solution to the above subpart, we noticed that we could not use
<code>.mean()</code> on the <code>'Date'</code> and <code>'Opp'</code>
columns, since they contained strings. However, we can use
<code>.count()</code> (since <code>.count()</code> just determines the
number of non-NA values in each group), and so the <code>'Date'</code>
and <code>'Opp'</code> columns are not “lost” when aggregating. Hence,
<code>puzzle</code> has 2 more columns than <code>home_won</code>.</p>
<hr/>
<h5>Difficulty: ⭐️⭐️</h5>
<p>
</p>
<p>The average score on this problem was 85%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<hr />
<h2 id="problem-32">Problem 32</h2>
<p><br></p>
<h3 id="problem-32.1">Problem 32.1</h3>
<p>There is exactly one team in the WNBA that Plum’s team did not win
any games against during the 2021 season. Fill in the blanks below so
that <code>never_beat</code> evaluates to a string containing the
three-letter code of that team.</p>
<div class="sourceCode" id="cb52"><pre
class="sourceCode py"><code class="sourceCode python"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a>never_beat <span class="op">=</span> plum.groupby(__(a)__).<span class="bu">sum</span>().__(b)__</span></code></pre></div>
<ol type="1">
<li><p>What goes in blank (a)?</p></li>
<li><p>What goes in blank (b)?</p></li>
</ol>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading32_1">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse32_1" aria-expanded="true" aria-controls="collapse32_1">
Click to view the solution.
</button>
</h2>
<div id="collapse32_1" class="accordion-collapse collapse"
aria-labelledby="heading32_1" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer:</strong></p>
<ol type="1">
<li><p><code>'Opp'</code></p></li>
<li><p><code>sort_values('Won').index[0]</code></p></li>
</ol>
<p>The key insight here is that the values in the <code>'Won'</code>
column are Boolean, and when Boolean values are used in arithmetic they
are treated as 1s (<code>True</code>) and 0s (<code>False</code>). The
<code>sum</code> of several <code>'Won'</code> values is the same as the
number of wins.</p>
<p>If we group <code>plum</code> by <code>'Opp'</code> and use
<code>.sum()</code>, the resulting <code>'Won'</code> column contains
the number of wins that Plum’s team had against each unique opponent. If
we sort this DataFrame by <code>'Won'</code> in increasing order (which
is the default behavior of <code>sort_values</code>), the row at the top
will correspond to the <code>'Opp'</code> that Plum’s team had no wins
against. Since we grouped by <code>'Opp'</code>, team names are stored
in the index, so <code>.index[0]</code> will give us the name of the
desired team.</p>
<hr/>
<h5>Difficulty: ⭐️⭐️⭐️</h5>
<p>
</p>
<p>The average score on this problem was 67%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<hr />
<h2 id="problem-33">Problem 33</h2>
<p><br></p>
<h3 id="problem-33.1">Problem 33.1</h3>
<p>What type of visualization is best suited for visualizing the trend
in the number of points Kelsey Plum scored per game in 2021?</p>
<ul class="task-list">
<li><p><input type="radio" disabled="" /> Histogram</p></li>
<li><p><input type="radio" disabled="" /> Bar chart</p></li>
<li><p><input type="radio" disabled="" /> Line chart</p></li>
<li><p><input type="radio" disabled="" /> Scatter plot</p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading33_1">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse33_1" aria-expanded="true" aria-controls="collapse33_1">
Click to view the solution.
</button>
</h2>
<div id="collapse33_1" class="accordion-collapse collapse"
aria-labelledby="heading33_1" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer: </strong> Line chart</p>
<p>Here, there are two quantitative variables (number of points and game
number), and one of them involves some element of time (game number).
Line charts are appropriate when one quantitative variable is time.</p>
<hr/>
<h5>Difficulty: ⭐️⭐️</h5>
<p>
</p>
<p>The average score on this problem was 75%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<h3 id="problem-33.2">Problem 33.2</h3>
<p>Fill in the blanks below so that <code>total_june</code> evaluates to
the total number of points Kelsey Plum scored in June.</p>
<div class="sourceCode" id="cb53"><pre
class="sourceCode py"><code class="sourceCode python"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a>june_only <span class="op">=</span> plum[__(a)__]</span>
<span id="cb53-2"><a href="#cb53-2" aria-hidden="true" tabindex="-1"></a>total_june <span class="op">=</span> june_only.__(b)__</span></code></pre></div>
<ol type="1">
<li><p>What goes in blank (a)?</p></li>
<li><p>What goes in blank (b)?</p></li>
</ol>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading33_2">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse33_2" aria-expanded="true" aria-controls="collapse33_2">
Click to view the solution.
</button>
</h2>
<div id="collapse33_2" class="accordion-collapse collapse"
aria-labelledby="heading33_2" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer:</strong></p>
<ol type="1">
<li><p><code>plum.get('Date').str.contains('-06-')</code></p></li>
<li><p><code>get('PTS').sum()</code></p></li>
</ol>
<p>To find the total number of points Kelsey Plum scored in June, one
approach is to first create a DataFrame with only the rows for June.
During the month of June, the <code>'Date'</code> values contain
<code>'-06-'</code> (since June is the 6th month), so
<code>plum.get('Date').str.contains('-06-')</code> is a Series
containing <code>True</code> only for the June rows and
<code>june_only = plum[plum.get('Date').str.contains('-06-')]</code> is
a DataFrame containing only the June rows.</p>
<p>Then, all we need is the sum of the <code>'PTS'</code> column, which
is given by <code>june_only.get('PTS').sum()</code>.</p>
<hr/>
<h5>Difficulty: ⭐️</h5>
<p>
</p>
<p>The average score on this problem was 90%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<h3 id="problem-33.3">Problem 33.3</h3>
<p>For your convenience, we show the first few rows of <code>plum</code>
again below.</p>
<center><img src='../../assets/images/wi22-final/plum.png' width=40%></center>
<p>There is exactly one team in the WNBA that Plum’s team did not win
any games against during the 2021 season. Fill in the blanks below so
that <code>never_beat</code> evaluates to a string containing the
three-letter code of that team.</p>
<div class="sourceCode" id="cb54"><pre
class="sourceCode py"><code class="sourceCode python"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a>never_beat <span class="op">=</span> plum.groupby(__(a)__).<span class="bu">sum</span>().__(b)__</span></code></pre></div>
<ol type="1">
<li><p>What goes in blank (a)?</p></li>
<li><p>What goes in blank (b)?</p></li>
</ol>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading33_3">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse33_3" aria-expanded="true" aria-controls="collapse33_3">
Click to view the solution.
</button>
</h2>
<div id="collapse33_3" class="accordion-collapse collapse"
aria-labelledby="heading33_3" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer:</strong></p>
<ol type="1">
<li><p><code>'Opp'</code></p></li>
<li><p><code>sort_values('Won').index[0]</code></p></li>
</ol>
<p>The key insight here is that the values in the <code>'Won'</code>
column are Boolean, and when Boolean values are used in arithmetic they
are treated as 1s (<code>True</code>) and 0s (<code>False</code>). The
<code>sum</code> of several <code>'Won'</code> values is the same as the
number of wins.</p>
<p>If we group <code>plum</code> by <code>'Opp'</code> and use
<code>.sum()</code>, the resulting <code>'Won'</code> column contains
the number of wins that Plum’s team had against each unique opponent. If
we sort this DataFrame by <code>'Won'</code> in increasing order (which
is the default behavior of <code>sort_values</code>), the row at the top
will correspond to the <code>'Opp'</code> that Plum’s team had no wins
against. Since we grouped by <code>'Opp'</code>, team names are stored
in the index, so <code>.index[0]</code> will give us the name of the
desired team.</p>
<hr/>
<h5>Difficulty: ⭐️⭐️⭐️</h5>
<p>
</p>
<p>The average score on this problem was 67%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<hr />
<h2 id="problem-34">Problem 34</h2>
<p><br></p>
<h3 id="problem-34.1">Problem 34.1</h3>
<p>The DataFrame <code>plum</code> contains Kelsey Plum’s stats for all
games the Las Vegas Aces played in 2021. The first few rows of
<code>plum</code> are shown below (though the full DataFrame has 31
rows, not 5):</p>
<center><img src='../../assets/images/wi22-final/plum.png' width=40%></center>
<p>Each row in <code>plum</code> corresponds to a single game. For each
game, we have:</p>
<ul>
<li><code>'Date'</code> (<code>str</code>), the date on which the game
was played</li>
<li><code>'Opp'</code> (<code>str</code>), the three-letter code of the
opponent team</li>
<li><code>'Home'</code> (<code>bool</code>), <code>True</code> if the
game was played in Las Vegas (“home”) and <code>False</code> if it was
played at the opponent’s arena (“away”)</li>
<li><code>'Won'</code> (<code>bool</code>), <code>True</code> if the Las
Vegas Aces won the game and <code>False</code> if they lost</li>
<li><code>'PTS'</code> (<code>int</code>), the number of points Kelsey
Plum scored in the game</li>
<li><code>'AST'</code> (<code>int</code>), the number of assists
(passes) Kelsey Plum made in the game</li>
<li><code>'TOV'</code> (<code>int</code>), the number of turnovers
Kelsey Plum made in the game (a turnover is when you lose the ball –
turnovers are bad!)</li>
</ul>
<p>Suppose that Plum’s team, the Las Vegas Aces, won at least one game
in Las Vegas and lost at least one game in Las Vegas. Also, suppose they
won at least one game in an opponent’s arena and lost at least one game
in an opponent’s arena.</p>
<p>Consider the DataFrame <code>home_won</code>, defined below.</p>
<div class="sourceCode" id="cb55"><pre
class="sourceCode py"><code class="sourceCode python"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a>home_won <span class="op">=</span> plum.groupby([<span class="st">&#39;Home&#39;</span>, <span class="st">&#39;Won&#39;</span>]).mean().reset_index()</span></code></pre></div>
<ol type="1">
<li><p>How many rows does <code>home_won</code> have?</p></li>
<li><p>How many columns does <code>home_won</code> have?</p></li>
</ol>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading34_1">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse34_1" aria-expanded="true" aria-controls="collapse34_1">
Click to view the solution.
</button>
</h2>
<div id="collapse34_1" class="accordion-collapse collapse"
aria-labelledby="heading34_1" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer:</strong> 4 rows and 5 columns.</p>
<p><code>plum.groupby(['Home', 'Won']).mean()</code> contains one row
for every unique combination of <code>'Home'</code> and
<code>'Won'</code>. There are two values of <code>'Home'</code> -
<code>True</code> and <code>False</code> – and two values of
<code>'Won'</code> – <code>True</code> and <code>False</code> – leading
to 4 combinations. We can assume that there was at least one row in
<code>plum</code> for each of these 4 combinations due to the assumption
given in the problem:</p>
<p><em>Suppose that Plum’s team, the Las Vegas Aces, won at least one
game in Las Vegas and lost at least one game in Las Vegas. Also, suppose
they won at least one game in an opponent’s arena and lost at least one
game in an opponent’s arena.</em></p>
<p><code>plum</code> started with 7 columns: <code>'Date'</code>,
<code>'Opp'</code>, <code>'Home'</code>, <code>'Won'</code>,
<code>'PTS'</code>, <code>'AST'</code>, and <code>'TOV'</code>. After
grouping by <code>['Home', 'Won']</code> and using <code>.mean()</code>,
<code>'Home'</code> and <code>'Won'</code> become the index. The
resulting DataFrame contains all of the columns that the
<code>.mean()</code> aggregation method can work on. We cannot take the
mean of <code>'Date'</code> and <code>'Opp'</code>, because those
columns are strings, so
<code>plum.groupby(['Home', 'Won']).mean()</code> contains a
<code>MultiIndex</code> with 2 “columns” – <code>'Home'</code> and
<code>'Won'</code> – and 3 regular columns – <code>'PTS'</code>
<code>'AST'</code>, and <code>'TOV'</code>. Then, when using
<code>.reset_index()</code>, <code>'Home'</code> and <code>'Won'</code>
are restored as regular columns, meaning that
<code>plum.groupby(['Home', 'Won']).mean().reset_index()</code> has
<span class="math inline">2 + 3 = 5</span> columns.</p>
<hr/>
<h5>Difficulty: ⭐️⭐️</h5>
<p>
</p>
<p>The average score on this problem was 78%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<hr />
<h2 id="problem-35">Problem 35</h2>
<p><br></p>
<h3 id="problem-35.1">Problem 35.1</h3>
<p>What type of visualization is best suited for visualizing the trend
in the number of points Kelsey Plum scored per game in 2021?</p>
<ul class="task-list">
<li><p><input type="radio" disabled="" /> Histogram</p></li>
<li><p><input type="radio" disabled="" /> Bar chart</p></li>
<li><p><input type="radio" disabled="" /> Line chart</p></li>
<li><p><input type="radio" disabled="" /> Scatter plot</p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading35_1">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse35_1" aria-expanded="true" aria-controls="collapse35_1">
Click to view the solution.
</button>
</h2>
<div id="collapse35_1" class="accordion-collapse collapse"
aria-labelledby="heading35_1" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer: </strong> Line chart</p>
<p>Here, there are two quantitative variables (number of points and game
number), and one of them involves some element of time (game number).
Line charts are appropriate when one quantitative variable is time.</p>
<hr/>
<h5>Difficulty: ⭐️⭐️</h5>
<p>
</p>
<p>The average score on this problem was 75%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<h3 id="problem-35.2">Problem 35.2</h3>
<p>Fill in the blanks below so that <code>total_june</code> evaluates to
the total number of points Kelsey Plum scored in June.</p>
<div class="sourceCode" id="cb56"><pre
class="sourceCode py"><code class="sourceCode python"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a>june_only <span class="op">=</span> plum[__(a)__]</span>
<span id="cb56-2"><a href="#cb56-2" aria-hidden="true" tabindex="-1"></a>total_june <span class="op">=</span> june_only.__(b)__</span></code></pre></div>
<ol type="1">
<li><p>What goes in blank (a)?</p></li>
<li><p>What goes in blank (b)?</p></li>
</ol>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading35_2">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse35_2" aria-expanded="true" aria-controls="collapse35_2">
Click to view the solution.
</button>
</h2>
<div id="collapse35_2" class="accordion-collapse collapse"
aria-labelledby="heading35_2" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer:</strong></p>
<ol type="1">
<li><p><code>plum.get('Date').str.contains('-06-')</code></p></li>
<li><p><code>get('PTS').sum()</code></p></li>
</ol>
<p>To find the total number of points Kelsey Plum scored in June, one
approach is to first create a DataFrame with only the rows for June.
During the month of June, the <code>'Date'</code> values contain
<code>'-06-'</code> (since June is the 6th month), so
<code>plum.get('Date').str.contains('-06-')</code> is a Series
containing <code>True</code> only for the June rows and
<code>june_only = plum[plum.get('Date').str.contains('-06-')]</code> is
a DataFrame containing only the June rows.</p>
<p>Then, all we need is the sum of the <code>'PTS'</code> column, which
is given by <code>june_only.get('PTS').sum()</code>.</p>
<hr/>
<h5>Difficulty: ⭐️</h5>
<p>
</p>
<p>The average score on this problem was 90%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<h3 id="problem-35.3">Problem 35.3</h3>
<p>Consider the function <code>unknown</code>, defined below.</p>
<div class="sourceCode" id="cb57"><pre
class="sourceCode py"><code class="sourceCode python"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> unknown(df):</span>
<span id="cb57-2"><a href="#cb57-2" aria-hidden="true" tabindex="-1"></a>    grouped <span class="op">=</span> plum.groupby(<span class="st">&#39;Opp&#39;</span>).<span class="bu">max</span>().get([<span class="st">&#39;Date&#39;</span>, <span class="st">&#39;PTS&#39;</span>])</span>
<span id="cb57-3"><a href="#cb57-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.array(grouped.reset_index().index)[df]</span></code></pre></div>
<p>What does <code>unknown(3)</code> evaluate to?</p>
<ul class="task-list">
<li><p><input type="radio" disabled="" /> <code>'2021-06-05'</code></p></li>
<li><p><input type="radio" disabled="" /> <code>'WAS'</code></p></li>
<li><p><input type="radio" disabled="" /> The date on which Kelsey Plum scored the most points</p></li>
<li><p><input type="radio" disabled="" /> The three-letter code of the opponent on which Kelsey Plum scored the
most points</p></li>
<li><p><input type="radio" disabled="" /> The number 0</p></li>
<li><p><input type="radio" disabled="" /> The number 3</p></li>
<li><p><input type="radio" disabled="" /> An error</p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading35_3">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse35_3" aria-expanded="true" aria-controls="collapse35_3">
Click to view the solution.
</button>
</h2>
<div id="collapse35_3" class="accordion-collapse collapse"
aria-labelledby="heading35_3" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer:</strong> The number 3</p>
<p><code>plum.groupby('Opp').max()</code> finds the largest value in the
<code>'Date'</code>, <code>'Home'</code>, <code>'Won'</code>,
<code>'PTS'</code>, <code>'AST'</code>, and <code>'TOV'</code> columns
for each unique <code>'Opp'</code> (independently for each column).
<code>grouped = plum.groupby('Opp').max().get(['Date', 'PTS'])</code>
keeps only the <code>'Date'</code> and <code>'PTS'</code> columns. Note
that in <code>grouped</code>, the index is <code>'Opp'</code>, the
column we grouped on.</p>
<p>When <code>grouped.reset_index()</code> is called, the index is
switched back to the default of 0, 1, 2, 3, 4, and so on. Then,
<code>grouped.reset_index().index</code> is an <code>Index</code>
containing the numbers <code>[0, 1, 2, 3, 4, ...]</code>, and
<code>np.array(grouped.reset_index().index)</code> is
<code>np.array([0, 1, 2, 3, 4, ...])</code>. In this array, the number
at position <code>i</code> is just <code>i</code>, so the number at
position <code>df</code> is <code>df</code>. Here, <code>df</code> is
the argument to <code>unknown</code>, and we were asked for the value of
<code>unknown(3)</code>, so the correct answer is the number at position
3 in <code>np.array([0, 1, 2, 3, 4, ...])</code> which is 3.</p>
<p>Note that if we asked for <code>unknown(50)</code> (or
<code>unknown(k)</code>, where <code>k</code> is any integer above 30),
the answer would be “An error”, since <code>grouped</code> could not
have had 51 rows. <code>plum</code> has 31 rows, so <code>grouped</code>
has at most 31 rows (but likely less, since Kelsey Plum’s team likely
played the same opponent multiple times).</p>
<hr/>
<h5>Difficulty: ⭐️⭐️⭐️</h5>
<p>
</p>
<p>The average score on this problem was 72%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<h3 id="problem-35.4">Problem 35.4</h3>
<p>For your convenience, we show the first few rows of <code>plum</code>
again below.</p>
<center><img src='../../assets/images/wi22-final/plum.png' width=40%></center>
<p>Suppose that Plum’s team, the Las Vegas Aces, won at least one game
in Las Vegas and lost at least one game in Las Vegas. Also, suppose they
won at least one game in an opponent’s arena and lost at least one game
in an opponent’s arena.</p>
<p>Consider the DataFrame <code>home_won</code>, defined below.</p>
<div class="sourceCode" id="cb58"><pre
class="sourceCode py"><code class="sourceCode python"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a>home_won <span class="op">=</span> plum.groupby([<span class="st">&#39;Home&#39;</span>, <span class="st">&#39;Won&#39;</span>]).mean().reset_index()</span></code></pre></div>
<ol type="1">
<li><p>How many rows does <code>home_won</code> have?</p></li>
<li><p>How many columns does <code>home_won</code> have?</p></li>
</ol>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading35_4">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse35_4" aria-expanded="true" aria-controls="collapse35_4">
Click to view the solution.
</button>
</h2>
<div id="collapse35_4" class="accordion-collapse collapse"
aria-labelledby="heading35_4" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer:</strong> 4 rows and 5 columns.</p>
<p><code>plum.groupby(['Home', 'Won']).mean()</code> contains one row
for every unique combination of <code>'Home'</code> and
<code>'Won'</code>. There are two values of <code>'Home'</code> -
<code>True</code> and <code>False</code> – and two values of
<code>'Won'</code> – <code>True</code> and <code>False</code> – leading
to 4 combinations. We can assume that there was at least one row in
<code>plum</code> for each of these 4 combinations due to the assumption
given in the problem:</p>
<p><em>Suppose that Plum’s team, the Las Vegas Aces, won at least one
game in Las Vegas and lost at least one game in Las Vegas. Also, suppose
they won at least one game in an opponent’s arena and lost at least one
game in an opponent’s arena.</em></p>
<p><code>plum</code> started with 7 columns: <code>'Date'</code>,
<code>'Opp'</code>, <code>'Home'</code>, <code>'Won'</code>,
<code>'PTS'</code>, <code>'AST'</code>, and <code>'TOV'</code>. After
grouping by <code>['Home', 'Won']</code> and using <code>.mean()</code>,
<code>'Home'</code> and <code>'Won'</code> become the index. The
resulting DataFrame contains all of the columns that the
<code>.mean()</code> aggregation method can work on. We cannot take the
mean of <code>'Date'</code> and <code>'Opp'</code>, because those
columns are strings, so
<code>plum.groupby(['Home', 'Won']).mean()</code> contains a
<code>MultiIndex</code> with 2 “columns” – <code>'Home'</code> and
<code>'Won'</code> – and 3 regular columns – <code>'PTS'</code>
<code>'AST'</code>, and <code>'TOV'</code>. Then, when using
<code>.reset_index()</code>, <code>'Home'</code> and <code>'Won'</code>
are restored as regular columns, meaning that
<code>plum.groupby(['Home', 'Won']).mean().reset_index()</code> has
<span class="math inline">2 + 3 = 5</span> columns.</p>
<hr/>
<h5>Difficulty: ⭐️⭐️</h5>
<p>
</p>
<p>The average score on this problem was 78%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<h3 id="problem-35.5">Problem 35.5</h3>
<p>Consider the DataFrame <code>home_won</code> once again.</p>
<div class="sourceCode" id="cb59"><pre
class="sourceCode py"><code class="sourceCode python"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a>home_won <span class="op">=</span> plum.groupby([<span class="st">&#39;Home&#39;</span>, <span class="st">&#39;Won&#39;</span>]).mean().reset_index()</span></code></pre></div>
<p>Now consider the DataFrame <code>puzzle</code>, defined below. Note
that the only difference between <code>home_won</code> and
<code>puzzle</code> is the use of <code>.count()</code> instead of
<code>.mean()</code>.</p>
<div class="sourceCode" id="cb60"><pre
class="sourceCode py"><code class="sourceCode python"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true" tabindex="-1"></a>puzzle <span class="op">=</span> plum.groupby([<span class="st">&#39;Home&#39;</span>, <span class="st">&#39;Won&#39;</span>]).count().reset_index()</span></code></pre></div>
<p>How do the number of rows and columns in <code>home_won</code>
compare to the number of rows and columns in <code>puzzle</code>?</p>
<ul class="task-list">
<li><p><input type="radio" disabled="" /> <code>home_won</code> and <code>puzzle</code> have the same number of
rows and columns</p></li>
<li><p><input type="radio" disabled="" /> <code>home_won</code> and <code>puzzle</code> have the same number of
rows, but a different number of columns</p></li>
<li><p><input type="radio" disabled="" /> <code>home_won</code> and <code>puzzle</code> have the same number of
columns, but a different number of rows</p></li>
<li><p><input type="radio" disabled="" /> <code>home_won</code> and <code>puzzle</code> have both a different
number of rows and a different number of columns</p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading35_5">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse35_5" aria-expanded="true" aria-controls="collapse35_5">
Click to view the solution.
</button>
</h2>
<div id="collapse35_5" class="accordion-collapse collapse"
aria-labelledby="heading35_5" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer: </strong> <code>home_won</code> and
<code>puzzle</code> have the same number of rows, but a different number
of columns</p>
<p>All that changed between <code>home_won</code> and
<code>puzzle</code> is the aggregation method. The aggregation method
has no influence on the number of rows in the output DataFrame, as there
is still one row for each of the 4 unique combinations of
<code>'Home'</code> and <code>'Won'</code>.</p>
<p>However, <code>puzzle</code> has 7 columns, instead of 5. In the
solution to the above subpart, we noticed that we could not use
<code>.mean()</code> on the <code>'Date'</code> and <code>'Opp'</code>
columns, since they contained strings. However, we can use
<code>.count()</code> (since <code>.count()</code> just determines the
number of non-NA values in each group), and so the <code>'Date'</code>
and <code>'Opp'</code> columns are not “lost” when aggregating. Hence,
<code>puzzle</code> has 2 more columns than <code>home_won</code>.</p>
<hr/>
<h5>Difficulty: ⭐️⭐️</h5>
<p>
</p>
<p>The average score on this problem was 85%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<h3 id="problem-35.6">Problem 35.6</h3>
<p>For your convenience, we show the first few rows of <code>plum</code>
again below.</p>
<center><img src='../../assets/images/wi22-final/plum.png' width=40%></center>
<p>There is exactly one team in the WNBA that Plum’s team did not win
any games against during the 2021 season. Fill in the blanks below so
that <code>never_beat</code> evaluates to a string containing the
three-letter code of that team.</p>
<div class="sourceCode" id="cb61"><pre
class="sourceCode py"><code class="sourceCode python"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a>never_beat <span class="op">=</span> plum.groupby(__(a)__).<span class="bu">sum</span>().__(b)__</span></code></pre></div>
<ol type="1">
<li><p>What goes in blank (a)?</p></li>
<li><p>What goes in blank (b)?</p></li>
</ol>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading35_6">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse35_6" aria-expanded="true" aria-controls="collapse35_6">
Click to view the solution.
</button>
</h2>
<div id="collapse35_6" class="accordion-collapse collapse"
aria-labelledby="heading35_6" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer:</strong></p>
<ol type="1">
<li><p><code>'Opp'</code></p></li>
<li><p><code>sort_values('Won').index[0]</code></p></li>
</ol>
<p>The key insight here is that the values in the <code>'Won'</code>
column are Boolean, and when Boolean values are used in arithmetic they
are treated as 1s (<code>True</code>) and 0s (<code>False</code>). The
<code>sum</code> of several <code>'Won'</code> values is the same as the
number of wins.</p>
<p>If we group <code>plum</code> by <code>'Opp'</code> and use
<code>.sum()</code>, the resulting <code>'Won'</code> column contains
the number of wins that Plum’s team had against each unique opponent. If
we sort this DataFrame by <code>'Won'</code> in increasing order (which
is the default behavior of <code>sort_values</code>), the row at the top
will correspond to the <code>'Opp'</code> that Plum’s team had no wins
against. Since we grouped by <code>'Opp'</code>, team names are stored
in the index, so <code>.index[0]</code> will give us the name of the
desired team.</p>
<hr/>
<h5>Difficulty: ⭐️⭐️⭐️</h5>
<p>
</p>
<p>The average score on this problem was 67%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<h3 id="problem-35.7">Problem 35.7</h3>
<p>Recall that <code>plum</code> has 31 rows, one corresponding to each
of the 31 games Kelsey Plum’s team played in the 2021 WNBA season.</p>
<p>Fill in the blank below so that <code>win_bool</code> evaluates to
<code>True</code>.</p>
<div class="sourceCode" id="cb62"><pre
class="sourceCode py"><code class="sourceCode python"><span id="cb62-1"><a href="#cb62-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> modify_series(s):</span>
<span id="cb62-2"><a href="#cb62-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> __(a)__</span>
<span id="cb62-3"><a href="#cb62-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb62-4"><a href="#cb62-4" aria-hidden="true" tabindex="-1"></a>n_wins <span class="op">=</span> plum.get(<span class="st">&#39;Won&#39;</span>).<span class="bu">sum</span>()</span>
<span id="cb62-5"><a href="#cb62-5" aria-hidden="true" tabindex="-1"></a>win_bool <span class="op">=</span> n_wins <span class="op">==</span> (<span class="dv">31</span> <span class="op">+</span> modify_series(plum.get(<span class="st">&#39;Won&#39;</span>)))</span></code></pre></div>
<p>What goes in blank (a)?</p>
<ul class="task-list">
<li><p><input type="radio" disabled="" /> <code>-s.sum()</code></p></li>
<li><p><input type="radio" disabled="" /> <code>-(s == False).sum()</code></p></li>
<li><p><input type="radio" disabled="" /> <code>len(s) - s.sum()</code></p></li>
<li><p><input type="radio" disabled="" /> <code>not s.sum()</code></p></li>
<li><p><input type="radio" disabled="" /> <code>-s[s.get('Won') == False].sum()</code></p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading35_7">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse35_7" aria-expanded="true" aria-controls="collapse35_7">
Click to view the solution.
</button>
</h2>
<div id="collapse35_7" class="accordion-collapse collapse"
aria-labelledby="heading35_7" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer:</strong> <code>-(s == False).sum()</code></p>
<p><code>n_wins</code> equals the number of wins that Plum’s team had.
Recall that her team played 31 games in total. In order for
<code>(31 + modify_series(plum.get('Won')))</code> to be equal to her
team’s number of wins, <code>modify_series(plum.get('Won'))</code> must
be equal to her team’s number of losses, multiplied by -1.</p>
<p>To see this algebraically, let
<code>modified = modify_series(plum.get('Won'))</code>. Then:</p>
<p><span class="math display">31 + \text{modified} = \text{wins}</span>
<span class="math display"> \text{modified} = \text{wins} - 31 = -(31 -
\text{wins}) = -(\text{losses})</span></p>
<p>The function <code>modified_series(s)</code> takes in a Series
containing the wins and losses for each of Plum’s team’s games and needs
to return the number of losses multiplied by -1. <code>s.sum()</code>
returns the number of wins, and <code>(s == False).sum()</code> returns
the number of losses. Then, <code>-(s == False).sum()</code> returns the
number of losses multiplied by -1, as desired.</p>
<hr/>
<h5>Difficulty: ⭐️⭐️</h5>
<p>
</p>
<p>The average score on this problem was 76%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<hr />
<h2 id="problem-36">Problem 36</h2>
<p>Suppose we have access to another DataFrame, <code>new_york</code>,
that contains the latitude and longitude of every single skyscraper in
New York City that is also in <code>sky</code>. The first few rows of
<code>new_york</code> are shown below.</p>
<center><img src='../../assets/images/wi22-midterm/ny.png' width=40%></center>
<p>Below, we define a new DataFrame, <code>sky_with_location</code>,
that merges together both <code>sky</code> and
<code>new_york</code>.</p>
<div class="sourceCode" id="cb63"><pre
class="sourceCode py"><code class="sourceCode python"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true" tabindex="-1"></a>sky_with_location <span class="op">=</span> sky.merge(new_york, left_index<span class="op">=</span><span class="va">True</span>, right_on<span class="op">=</span><span class="st">&#39;name&#39;</span>)</span></code></pre></div>
<p>Given that:</p>
<ul>
<li><code>sky</code> has <span class="math inline">s</span> rows,</li>
<li><code>new_york</code> has <span class="math inline">n</span> rows,
and</li>
<li>building names are spelled and formatted the exact same way in both
<code>sky</code> and <code>new_york</code>, i.e. that there are no typos
in either DataFrame,</li>
</ul>
<p>select the true statement below.</p>
<ul class="task-list">
<li><p><input type="radio" disabled="" /> <code>sky_with_location</code> has exactly <span class="math inline">s</span> rows.</p></li>
<li><p><input type="radio" disabled="" /> <code>sky_with_location</code> has exactly <span class="math inline">n</span> rows.</p></li>
<li><p><input type="radio" disabled="" /> <code>sky_with_location</code> has exactly <span class="math inline">s - n</span> rows.</p></li>
<li><p><input type="radio" disabled="" /> <code>sky_with_location</code> has exactly <span class="math inline">s + n</span> rows.</p></li>
<li><p><input type="radio" disabled="" /> <code>sky_with_location</code> has exactly <span class="math inline">s \times n</span> rows.</p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading36">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse36" aria-expanded="true" aria-controls="collapse36">
Click to view the solution.
</button>
</h2>
<div id="collapse36" class="accordion-collapse collapse"
aria-labelledby="heading36" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer:</strong> <code>sky_with_location</code> has exactly
<span class="math inline">n</span> rows.</p>
<p>Here, we are merging <code>sky</code> and <code>new_york</code> on
skyscraper names (stored in the index in <code>sky</code> and in the
<code>'name'</code> column in <code>new_york</code>). The resulting
DataFrame, <code>sky_with_location</code>, will have one row for each
“match” between skyscrapers in <code>sky</code> and
<code>new_york</code>. Since skyscraper names are presumably unique,
<code>sky_with_location</code> will have one row for each skyscraper
that is in both <code>sky</code> and <code>new_york</code>.</p>
<p>The skyscrapers that are in both <code>sky</code> and
<code>new_york</code> are just the skyscrapers in <code>new_york</code>,
since all of the non-New York skyscrapers in <code>sky</code> won’t be
in <code>new_york</code>. As such, <code>sky_with_location</code> has
the same number of rows as <code>new_york</code>. <code>new_york</code>
has <span class="math inline">n</span> rows, so
<code>sky_with_location</code> also has <span class="math inline">n</span> rows.</p>
<hr/>
<h5>Difficulty: ⭐️⭐️⭐️</h5>
<p>
</p>
<p>The average score on this problem was 64%.</p>
</div>
</div>
</div>
</div>
<hr />
<p class="meta"><em>Source:</em> wi23-final — Q15</p>
<h2 id="problem-37">Problem 37</h2>
<p>At a recent game night, you played several new board games and liked
them so much that you now want to buy copies for yourself.</p>
<p>The DataFrame <code>stores</code> is shown below in full. Each row
represents a game you want to buy and a local board game store where
that game is available for purchase. If a game is not available at a
certain store, there will be no row corresponding to that store and that
game.</p>
<center><img src='../../assets/images/wi23-final/stores.jpg' width=20%></center>
<p><br></p>
<h3 id="problem-37.1">Problem 37.1</h3>
<p>The DataFrame <code>prices</code> has five rows. Below we merge
<code>stores</code> with <code>prices</code> and display the output in
full.</p>
<div class="sourceCode" id="cb64"><pre
class="sourceCode py"><code class="sourceCode python"><span id="cb64-1"><a href="#cb64-1" aria-hidden="true" tabindex="-1"></a>merged <span class="op">=</span> stores.merge(prices, on<span class="op">=</span><span class="st">&quot;Game&quot;</span>)</span>
<span id="cb64-2"><a href="#cb64-2" aria-hidden="true" tabindex="-1"></a>merged</span></code></pre></div>
<center><img src='../../assets/images/wi23-final/merged.jpg' width=25%></center>
<p><br></p>
<p>In the space below, specify what the DataFrame <code>prices</code>
<strong>could</strong> look like. The column labels should go in the top
row, and the row labels (index) should go in the leftmost row. You may
not need to use all the columns provided, but you are told that
<code>prices</code> has five rows, so you should use all rows
provided.</p>
<p><strong>Note:</strong> There are several correct answers to this
question.</p>
<center><img src='../../assets/images/wi23-final/blank_df.jpg' width=40%></center>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading37_1">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse37_1" aria-expanded="true" aria-controls="collapse37_1">
Click to view the solution.
</button>
</h2>
<div id="collapse37_1" class="accordion-collapse collapse"
aria-labelledby="heading37_1" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer:</strong></p>
<center><img src="../../assets/images/wi23-final/filled_prices.jpg" width="40%"/></center>
<p>We can use the <code>merged</code> DataFrame to figure out the prices
that correlate to each game in <code>stores</code>. We see in
<code>merged</code> the price for <em>Tickets to Ride</em> should be
47.99, so we create a row for that game. We repeat this process to find
the remaining rows. Since we know that <code>prices</code> have 5 rows
we then make a game and price up. Note that in the solution above the
last row (index 4) has <code>“Sushi Go”</code> and <code>9.99</code>.
These can be any game or any price that is not listed in indexes 0 to 4.
This is because <code>prices</code> has 5 rows and when we use
<code>.merge()</code> since the game <code>“Sushi Go”</code> is not in
<code>stores</code> it will not be added.</p>
<hr/>
<h5>Difficulty: ⭐️⭐️</h5>
<p>
</p>
<p>The average score on this problem was 84%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<p>Suppose <code>merged</code> now contains all the available games and
their corresponding prices at each store (in particular, a given game is
sold for the same price at all stores). You want to buy as many games as
possible but you only want to go to one store. Which store should you go
to maximize the number of games you can buy?</p>
<p>Fill in the blanks so that <code>where_to_go</code> evaluates to the
name of the store you should buy your games from.</p>
<div class="sourceCode" id="cb65"><pre
class="sourceCode py"><code class="sourceCode python"><span id="cb65-1"><a href="#cb65-1" aria-hidden="true" tabindex="-1"></a>where_to_go <span class="op">=</span> (merged.groupby(<span class="st">&quot;Store&quot;</span>).__(a)__.sort_values(by<span class="op">=</span><span class="st">&quot;Price&quot;</span>, ascending<span class="op">=</span><span class="va">False</span>).__(b)__)</span></code></pre></div>
<p><br></p>
<h3 id="problem-37.2">Problem 37.2</h3>
<p>What goes in blank (a)?</p>
<ul class="task-list">
<li><p><input type="radio" disabled="" /> min()</p></li>
<li><p><input type="radio" disabled="" /> max()</p></li>
<li><p><input type="radio" disabled="" /> count()</p></li>
<li><p><input type="radio" disabled="" /> mean()</p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading37_2">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse37_2" aria-expanded="true" aria-controls="collapse37_2">
Click to view the solution.
</button>
</h2>
<div id="collapse37_2" class="accordion-collapse collapse"
aria-labelledby="heading37_2" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer:</strong> <code>count()</code></p>
<p>The problem asks us which store would allow us to buy as many games
as possible. The provided code is
<code>merge.groupby(“Store”).__a__</code>. We want to use the aggregate
method that allows us to find the number of games in each store. The
aggregation method for this would be <code>count()</code>.</p>
<hr/>
<h5>Difficulty: ⭐️⭐️</h5>
<p>
</p>
<p>The average score on this problem was 87%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<h3 id="problem-37.3">Problem 37.3</h3>
<p>What goes in blank (b)?</p>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading37_3">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse37_3" aria-expanded="true" aria-controls="collapse37_3">
Click to view the solution.
</button>
</h2>
<div id="collapse37_3" class="accordion-collapse collapse"
aria-labelledby="heading37_3" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer:</strong> <code>index[0]</code></p>
<p>Recall <code>groupby()</code> will cause the unique values from the
column <code>“Store”</code> to be in the index. The remaining part of
the code sorts the DataFrame so that the store with the most games is at
the top. This means the row at index 0 has the store and most number of
games inside of the DataFrame. To grab the element at the 1st index we
simply do <code>index[0]</code>.</p>
<hr/>
<h5>Difficulty: ⭐️⭐️⭐️</h5>
<p>
</p>
<p>The average score on this problem was 53%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<h3 id="problem-37.4">Problem 37.4</h3>
<p>Suppose you go to the store <code>where_to_go</code> and buy one copy
of each of the available games that you enjoyed at game night. How much
money will you spend? Write <strong>one line of code</strong> that
evaluates to the answer, using the <code>merged</code> DataFrame and no
others.</p>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading37_4">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse37_4" aria-expanded="true" aria-controls="collapse37_4">
Click to view the solution.
</button>
</h2>
<div id="collapse37_4" class="accordion-collapse collapse"
aria-labelledby="heading37_4" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer:</strong>
<code>merged[merged.get(“Store”) == where_to_go].get(“Price”).sum()</code></p>
<p>We want to figure out how much money we would spend if we went to
<code>where_to_go</code>, which is the store where we can buy as many
games as possible. We can simply query the merged DataFrame to only
contain the rows where the store is equal to <code>where_to_go</code>.
We then can simply get the <code>“Price”</code> column and add all of
the values up by doing <code>.sum()</code> on the Series.</p>
<hr/>
<h5>Difficulty: ⭐️⭐️⭐️</h5>
<p>
</p>
<p>The average score on this problem was 74%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<hr />
<p class="meta"><em>Source:</em> wi23-midterm — Q9</p>
<h2 id="problem-38">Problem 38</h2>
<p><br></p>
<h3 id="problem-38.1">Problem 38.1</h3>
<p>The DataFrame directors contains historical information about the
director of the National Hurricane Center (NHC). A preview of directors
is shown below.</p>
<center><img src='../../assets/images/wi23-midterm/q9_wi23-midterm.png' width=30%></center>
<p><br></p>
<p>We would like to merge <code>storms</code> with
<code>directors</code> to produce a DataFrame with the same information
as <code>storms</code> plus one additional column with the name of the
director who was leading the NHC at the time of each storm. However,
when we try to merge with the command shown below, Python fails to
produce the desired DataFrame.</p>
<div class="sourceCode" id="cb66"><pre
class="sourceCode py"><code class="sourceCode python"><span id="cb66-1"><a href="#cb66-1" aria-hidden="true" tabindex="-1"></a>directors.merge(storms, left_on<span class="op">=</span><span class="st">&quot;Tenure&quot;</span>, right_on<span class="op">=</span><span class="st">&quot;Year&quot;</span>)</span></code></pre></div>
<p>Which of the following is a problem with our attempted merge?
<strong>Select all that apply.</strong></p>
<ul class="task-list">
<li><p><input type="checkbox" disabled="" /> We cannot merge these two DataFrames because they have two completely
different sets of column names.</p></li>
<li><p><input type="checkbox" disabled="" /> We want to add information about the directors to storms, so we need
to use storms as our left DataFrame. The command should start with
<code>storms.merge(directors)</code>.</p></li>
<li><p><input type="checkbox" disabled="" /> The <code>directors</code> DataFrame does not contain enough
information to determine who was the director of the NHC at the time of
each storm.</p></li>
<li><p><input type="checkbox" disabled="" /> The <code>"Tenure"</code> column of directors contains a different
data type than the <code>"Year"</code> column of storms.</p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading38_1">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse38_1" aria-expanded="true" aria-controls="collapse38_1">
Click to view the solution.
</button>
</h2>
<div id="collapse38_1" class="accordion-collapse collapse"
aria-labelledby="heading38_1" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer:</strong> Option 3 and Option 4</p>
<p>Recall that
<code>left_df.merge(right_df, left_on='column_a', right_on='column_b')</code>
merges <code>left_df</code> to the <code>right_df</code> and specifies
which columns from the DataFrame to use as keys by using
<code>left_on=</code> and <code>right_on=</code>. This means that
<code>column_a</code> becomes the key for the left DataFrame and
<code>column_b</code> becomes the key for the right DataFrame. That
means the column names do not need to be the same. The important part of
this is <code>'column_a'</code> and <code>'column_b'</code> should be
the same data type and contain the same information for the merge to be
successful.</p>
<p>Option 4 is correct because the years are formatted differenntly in
<code>storms</code> and in <code>directors</code>. In
<code>storms</code> the column <code>"Year"</code> contains an int,
which is the year, whereas in <code>"Tenure"</code> the column contains
a string to represent a span of years. When we try to merge there is no
overlap between values in these columns. There will actually be an error
because we are trying to merge two columns of different types.</p>
<p>Option 3 is correct because the merge will fail to happen due to the
error we see caused by the columns containing values with
<strong>no</strong> overlap.</p>
<p><strong>Option 1:</strong> Is incorrect because you can merge
DataFrames with different column names using <code>left_on</code> and
<code>right_on</code>.</p>
<p><strong>Option 2:</strong> Is incorrect because regardless of the
<code>left</code> or <code>right</code> DataFrames if done correctly
they will merge together. This means the order of the DataFrames does
not make an impact.</p>
<hr/>
<h5>Difficulty: ⭐️⭐️⭐️</h5>
<p>
</p>
<p>The average score on this problem was 61%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<hr />
<p class="meta"><em>Source:</em> wi23-midterm — Q10</p>
<h2 id="problem-39">Problem 39</h2>
<p><br></p>
<h3 id="problem-39.1">Problem 39.1</h3>
<p>Recall that all the named storms in <code>storms</code> occurred
between 1965 and 2015, a fifty-year time period.</p>
<p>Below is a histogram and the code that produced it. Use it to answer
the questions that follow.</p>
<div class="sourceCode" id="cb67"><pre
class="sourceCode py"><code class="sourceCode python"><span id="cb67-1"><a href="#cb67-1" aria-hidden="true" tabindex="-1"></a>    (storms.groupby([<span class="st">&quot;Name&quot;</span>, <span class="st">&quot;Year&quot;</span>]).count()</span>
<span id="cb67-2"><a href="#cb67-2" aria-hidden="true" tabindex="-1"></a>        .reset_index()</span>
<span id="cb67-3"><a href="#cb67-3" aria-hidden="true" tabindex="-1"></a>        .plot(kind<span class="op">=</span><span class="st">&quot;hist&quot;</span>, y<span class="op">=</span><span class="st">&quot;Year&quot;</span>,</span>
<span id="cb67-4"><a href="#cb67-4" aria-hidden="true" tabindex="-1"></a>            density<span class="op">=</span><span class="va">True</span>, ec<span class="op">=</span><span class="st">&quot;w&quot;</span>,</span>
<span id="cb67-5"><a href="#cb67-5" aria-hidden="true" tabindex="-1"></a>            bins<span class="op">=</span>np.arange(<span class="dv">1965</span>, <span class="dv">2020</span>, <span class="dv">5</span>)))<span class="op">;</span></span></code></pre></div>
<center><img src='../../assets/images/wi23-midterm/q10_wi23-midterm.png' width=45%></center>
<p><br></p>
<p>Approximately <strong>(a)</strong> percent of named storms in this
fifty-year time period occurred in 1995 or later. Give your answer to
the nearest multiple of five.</p>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading39_1">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse39_1" aria-expanded="true" aria-controls="collapse39_1">
Click to view the solution.
</button>
</h2>
<div id="collapse39_1" class="accordion-collapse collapse"
aria-labelledby="heading39_1" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer:</strong> 55</p>
<p>We can find the percentage of named storms by using the fact: a
histograms’ area is always normalized to 1. This means we can calculate
the area of the rectangle, also known as width * height, to the left of
1995. The height, which is the frequency, is about 0.015 and the width
is the difference between 1995 and 1965. This gives us: <span class="math inline">1 - (1995 - 1965) * 0.015 = 0.55</span>. Next to
convert this to a percentage we multiply by 100, giving us: <span class="math inline">0.55 * 100 = 55\%</span>.</p>
<hr/>
<h5>Difficulty: ⭐️⭐️⭐️</h5>
<p>
</p>
<p>The average score on this problem was 52%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<p><br></p>
<h3 id="problem-39.2">Problem 39.2</h3>
<p>True or False? The line plot generated by the code below will have no
downward-sloping segments after 1995.</p>
<div class="sourceCode" id="cb68"><pre
class="sourceCode py"><code class="sourceCode python"><span id="cb68-1"><a href="#cb68-1" aria-hidden="true" tabindex="-1"></a>    (storms.groupby([<span class="st">&quot;Name&quot;</span>, <span class="st">&quot;Year&quot;</span>]).count()</span>
<span id="cb68-2"><a href="#cb68-2" aria-hidden="true" tabindex="-1"></a>        .reset_index()</span>
<span id="cb68-3"><a href="#cb68-3" aria-hidden="true" tabindex="-1"></a>        .groupby(<span class="st">&quot;Year&quot;</span>).count()</span>
<span id="cb68-4"><a href="#cb68-4" aria-hidden="true" tabindex="-1"></a>        .plot(kind<span class="op">=</span><span class="st">&quot;line&quot;</span>, y<span class="op">=</span><span class="st">&quot;Name&quot;</span>)<span class="op">;</span></span></code></pre></div>
<ul class="task-list">
<li><p><input type="radio" disabled="" /> True</p></li>
<li><p><input type="radio" disabled="" /> False</p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading39_2">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse39_2" aria-expanded="true" aria-controls="collapse39_2">
Click to view the solution.
</button>
</h2>
<div id="collapse39_2" class="accordion-collapse collapse"
aria-labelledby="heading39_2" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer:</strong> False</p>
<p>The previous histogram shows upward-sloping segments for each 5-year
period after 1995; however, we are now ploting a line graph that shows a
continuous timeline. Thus, there may be downward-sloping that happens
within any 5-year periods.</p>
<hr/>
<h5>Difficulty: ⭐️⭐️⭐️</h5>
<p>
</p>
<p>The average score on this problem was 51%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<hr />
<p class="meta"><em>Source:</em> wi23-midterm — Q11</p>
<h2 id="problem-40">Problem 40</h2>
<p><br></p>
<h3 id="problem-40.1">Problem 40.1</h3>
<p>The code below defines a variable called
<code>month formed</code>.</p>
<div class="sourceCode" id="cb69"><pre
class="sourceCode py"><code class="sourceCode python"><span id="cb69-1"><a href="#cb69-1" aria-hidden="true" tabindex="-1"></a>month_formed <span class="op">=</span> (storms.groupby([<span class="st">&quot;Name&quot;</span>, <span class="st">&quot;Year&quot;</span>]).<span class="bu">min</span>()</span>
<span id="cb69-2"><a href="#cb69-2" aria-hidden="true" tabindex="-1"></a>                      .reset_index()</span>
<span id="cb69-3"><a href="#cb69-3" aria-hidden="true" tabindex="-1"></a>                      .groupby(<span class="st">&quot;Month&quot;</span>).count()</span>
<span id="cb69-4"><a href="#cb69-4" aria-hidden="true" tabindex="-1"></a>                      .get(<span class="st">&quot;Name&quot;</span>))</span></code></pre></div>
<p>What is the data type of <code>month formed</code>?</p>
<ul class="task-list">
<li><p><input type="radio" disabled="" /> int</p></li>
<li><p><input type="radio" disabled="" /> str</p></li>
<li><p><input type="radio" disabled="" /> Series</p></li>
<li><p><input type="radio" disabled="" /> Dataframe</p></li>
<li><p><input type="radio" disabled="" /> None of these</p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading40_1">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse40_1" aria-expanded="true" aria-controls="collapse40_1">
Click to view the solution.
</button>
</h2>
<div id="collapse40_1" class="accordion-collapse collapse"
aria-labelledby="heading40_1" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer:</strong> Series</p>
<p>It’s helpful to analyze the code piece by piece. The first part is
doing <code>.groupby(["Name", "Year"]).min()</code>, which will index
both <code>"Name"</code> and <code>"Year"</code> and find the minimum
values in the DataFrame. We are still working with a DataFrame at this
point. The next part <code>.reset_index()</code> makes
<code>"Name"</code> and <code>"Year"</code> columns again. Again, this
is a DataFrame. The next part <code>.groupby("Month").count()</code>
makes <code>"Month"</code> the index and gets the count for each element
in the DataFrame. Finally, <code>.get("Name")</code> isolates the
<code>"Name"</code> column and returns to <code>month_formed</code> a
series.</p>
<hr/>
<h5>Difficulty: ⭐️⭐️</h5>
<p>
</p>
<p>The average score on this problem was 81%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<p><br></p>
<h3 id="problem-40.2">Problem 40.2</h3>
<p>Which of the following expressions evaluates to the proportion of
storms in our data set that were formed in August?</p>
<ul class="task-list">
<li><p><input type="radio" disabled="" /> <code>month_formed.loc[8]/month_formed.sum()</code></p></li>
<li><p><input type="radio" disabled="" /> <code>month_formed.iloc[7]/month_formed.sum()</code></p></li>
<li><p><input type="radio" disabled="" /> <code>month_formed[month_formed.index == 8].shape[0]/month_formed.sum()</code></p></li>
<li><p><input type="radio" disabled="" /> <code>month_formed[month_formed.get("Month") == 8].shape[0]/month_formed.sum()</code></p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading40_2">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse40_2" aria-expanded="true" aria-controls="collapse40_2">
Click to view the solution.
</button>
</h2>
<div id="collapse40_2" class="accordion-collapse collapse"
aria-labelledby="heading40_2" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer:</strong>
<code>month_formed.loc[8]/month_formed.sum()</code></p>
<p><strong>Option 1:</strong> Recall that August is the eigth month, so
using <code>.loc[8]</code> will find the label 8 in
<code>month_formed</code>, which will be <code>counts</code> or the
number of storms formed in August. Dividing the number of storms formed
in August by the total number of storms formed will give us the
proportion of storms that formed in August.</p>
<p><strong>Option 2:</strong> It is important to realize that the months
have become the index of <code>month_formed</code>, but that doesn’t
necessarily mean that the index starts in January or that there have
been storm during a month before August. For example if there were no
storms in March then there would be no 3 in the index. Recall
<code>.iloc[7]</code> is indexing for whatever is in position 7, but
because the index is not guaranteed we cannot be certain the
<code>.iloc[7]</code> will return August.</p>
<p><strong>Option 3:</strong> The code:
<code>month_formed[month_formed.index == 8].shape[0]</code> will return
1. Finding the index at month 8 will give us August, but doing
<code>.shape[0]</code> gives us the number of rows in August, which
should only be 1 because of <code>groupby</code>. This means that Option
3’s line of code will not give us the number of storms that formed in
August, which makes it impossible to find the propotion.</p>
<p><strong>Option 4:</strong> Remember that <code>months_formed</code>’s
index is <code>"Month"</code>. This means that there is no column
<code>"Month"</code>, so the code will error, meaning it cannot give us
proportions of storms that formed in August.</p>
<hr/>
<h5>Difficulty: ⭐️⭐️⭐️⭐️</h5>
<p>
</p>
<p>The average score on this problem was 35%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<hr />
<p class="meta"><em>Source:</em> wi24-final — Q9</p>
<h2 id="problem-41">Problem 41</h2>
<p>In 2024, the Olympics will include breaking (also known as
breakdancing) for the first time. The breaking competition will include
<strong>16 athletes</strong>, who will compete in a single-elimination
tournament.</p>
<p>In the first round, all 16 athletes will compete against an opponent
in a face-to-face “battle". The 8 winners, as determined by the judges,
will move on to the next round. Elimination continues until the final
round contains just 2 competitors, and the winner of this final battle
wins the tournament.</p>
<p>The table below shows how many competitors participate in each
round:</p>
<center><img src='../../assets/images/wi24-final/q9_table.png' width=400></center>
<!-- ::: center
   **Round**   **Competitors**
  ----------- -----------------
       1             16
       2              8
       3              4
       4              2
::: -->
<p>After the 2024 Olympics, suppose we make a DataFrame called
<code>breaking</code> containing information about the performance of
each athlete during each round. <code>breaking</code> will have one row
for each athlete’s performance in each round that they participated.
Therefore, there will be <span class="math inline">16+8+4+2 =</span>
<strong>30 rows</strong> in <code>breaking</code>.</p>
<p>In the <code>"name"</code> column of <code>breaking</code>, we will
record the athlete’s name (which we’ll assume to be unique), and in the
other columns we’ll record the judges’ scores in the categories on which
the athletes will be judged (creativity, personality, technique,
variety, performativity, and musicality).</p>
<p><br></p>
<h3 id="problem-41.1">Problem 41.1</h3>
<p>How many rows of <code>breaking</code> correspond to the winner of
the tournament? Give your answer as an integer.</p>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading41_1">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse41_1" aria-expanded="true" aria-controls="collapse41_1">
Click to view the solution.
</button>
</h2>
<div id="collapse41_1" class="accordion-collapse collapse"
aria-labelledby="heading41_1" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer:</strong> 4</p>
<p>Since the winner of the tournament must have won during the 1st, 2nd,
3rd, and final rounds, there will be a total of four rows in
<code>breaking</code> corresponding to this winner.</p>
<hr/>
<h5>Difficulty: ⭐️</h5>
<p>
</p>
<p>The average score on this problem was 94%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<h3 id="problem-41.2">Problem 41.2</h3>
<p>How many athletes’ names appear exactly twice in the
<code>"name"</code> column of <code>breaking</code>? Give your answer as
an integer.</p>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading41_2">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse41_2" aria-expanded="true" aria-controls="collapse41_2">
Click to view the solution.
</button>
</h2>
<div id="collapse41_2" class="accordion-collapse collapse"
aria-labelledby="heading41_2" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer:</strong> 4</p>
<p>For an athlete to appear on exactly two rows in
<code>breaking</code>, they must get through the 1st round but get
eliminated in the 2nd round. There are a total of 8 athletes in the 2nd
round, of which 4 are eliminated.</p>
<hr/>
<h5>Difficulty: ⭐️⭐️</h5>
<p>
</p>
<p>The average score on this problem was 82%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<h3 id="problem-41.3">Problem 41.3</h3>
<p>If we merge <code>breaking</code> with itself on the
<code>"name"</code> column, how many rows will the resulting DataFrame
have? Give your answer as an integer.</p>
<p><em>Hint</em>: Parts (a) and (b) of this question are relevant to
part (c).</p>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading41_3">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse41_3" aria-expanded="true" aria-controls="collapse41_3">
Click to view the solution.
</button>
</h2>
<div id="collapse41_3" class="accordion-collapse collapse"
aria-labelledby="heading41_3" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer:</strong> 74</p>
<p>This question asks us the number of rows in the DataFrame that
results from merging breaking with itself on the <code>name</code>
column. Let’s break this problem down.</p>
<p>Concept:</p>
<p>When a DataFrame is merged with another DataFrame, there will be one
row in the output DataFrame for every matching value between the two
DataFrames in the row you’re merging on. In general, this means you can
calculate the number of rows in the output DataFrame the following
way:</p>
<p><span class="math display">
\text{Number of instances of \texttt{a} in \texttt{df1} } \cdot \text{
Number of instances of \texttt{a} in \texttt{df2}} +
</span></p>
<p><span class="math display">
\text{Number of instances of \texttt{b} in \texttt{df1}} \cdot
\text{Number of instances of \texttt{b} in \texttt{df2}} +
</span></p>
<p><span class="math display">
\vdots
</span></p>
<p><span class="math display">
\text{Number of instances of \texttt{n} in \texttt{df1}} \cdot \text{
Number of instances of \texttt{n} in \texttt{df2}}
</span></p>
<p>For example, if there were <span class="math inline">2</span>
instances of <code>"Jack"</code> in <code>df1</code> and <span class="math inline">3</span> instances of <code>"Jack"</code> in
<code>df2</code>, there would be <span class="math inline">2 \cdot 3 =
6</span> instances of <code>"Jack"</code> in the output DataFrame.</p>
<p>So, when we’re merging a DataFrame with itself, you can calculate the
number of rows in the output DataFrame the following way:</p>
<p><span class="math display">
\text{Number of instances of \texttt{a} in \texttt{df1} } \cdot \text{
Number of instances of \texttt{a} in \texttt{df1} } +
</span></p>
<p><span class="math display">
\text{Number of instances of \texttt{b} in \texttt{df1}} \cdot
\text{Number of instances of \texttt{b} in \texttt{df1} } +
</span></p>
<p><span class="math display">
\vdots
</span></p>
<p><span class="math display">
\text{Number of instances of \texttt{n} in \texttt{df1}} \cdot \text{
Number of instances of \texttt{n} in \texttt{df1} }
</span></p>
<p>which is the same as</p>
<p><span class="math display">
\left(\text{Number of instances of \texttt{a} in \texttt{df1} }\right)^2
</span></p>
<p><span class="math display">
\left(\text{Number of instances of \texttt{b} in \texttt{df1} }\right)^2
</span></p>
<p><span class="math display">
\vdots
</span></p>
<p><span class="math display">
\left(\text{Number of instances of \texttt{n} in \texttt{df1} }\right)^2
</span></p>
<p>The Problem:</p>
<p>So, if we can figure out how many instances of each athlete are in
breaking, we can calculate the number of rows in the merged DataFrame by
squaring these numbers and adding them together.</p>
<p>As it turns out, we can absolutely do this! Consider the following
information, drawn from the DataFrame:</p>
<ol type="1">
<li><span class="math inline">8</span> athletes are eliminated in the
first round, thus only appearing one time in breaking (in the rows
corresponding to round one).</li>
<li><span class="math inline">4</span> athletes are eliminated in the
second round, appearing twice in breaking (in the rows corresponding to
rounds one and two).</li>
<li><span class="math inline">2</span> athletes are eliminated in the
third round, appearing three times in breaking (in the rows
corresponding to rounds one, two, and three).</li>
<li><span class="math inline">2</span> athletes reach the fourth round,
appearing four times in breaking (in the rows corresponding to rounds
one, two, three, and four).</li>
</ol>
<p>Using the formula above for calculating the number of rows in the
output DataFrame when merging a DataFrame with itself:</p>
<p>For <span class="math inline">8</span> athletes, they will appear
<span class="math inline">1^2 = 1</span> time in the merged DataFrame.
For <span class="math inline">4</span> athletes, they will appear <span class="math inline">2^2 = 4</span> times in the merged DataFrame. For
<span class="math inline">2</span> athletes, they will appear <span class="math inline">3^2 = 9</span> times in the merged DataFrame. And
for the last <span class="math inline">2</span> athletes, they will
appear <span class="math inline">4^2 = 16</span> times in the merged
DataFrame.</p>
<p>So, the total number of rows in the merged DataFrame is</p>
<p><span class="math inline">8(1) + 4(4) + 2(9) + 2(16) = 8 + 16 + 18 +
32 = 74</span> rows.</p>
<hr/>
<h5>Difficulty: ⭐️⭐️⭐️⭐️</h5>
<p>
</p>
<p>The average score on this problem was 39%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<h3 id="problem-41.4">Problem 41.4</h3>
<p>Recall that the number of competitors in each round is <span
class="math inline">16, 8, 4, 2</span>. Write one line of code that
evaluates to the array <code>np.array([16, 8, 4, 2])</code>. You
<strong>must use</strong> <code>np.arange</code> in your solution, and
you <strong>may not use</strong> <code>np.array</code> or the DataFrame
<code>breaking</code>.</p>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading41_4">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse41_4" aria-expanded="true" aria-controls="collapse41_4">
Click to view the solution.
</button>
</h2>
<div id="collapse41_4" class="accordion-collapse collapse"
aria-labelledby="heading41_4" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer:</strong> <code>2 ** np.arange(4, 0, -1)</code></p>
<p>This problem asks us to write one line of code that evaluates to the
array <code>np.array([16, 8, 4, 2])</code>.</p>
<p>Concept:</p>
<p>Right away, it should jump out at you that these are powers of <span class="math inline">2</span> in reverse order. Namely,</p>
<p><code>[2^4, 2^3, 2^2, 2^1]</code>.</p>
<p>The key insight is that exponentiation works element-wise on an
array. In otherwords:</p>
<p><code>2 ** [4, 3, 2, 1] = [2^4, 2^3, 2^2, 2^1]</code>.</p>
<p>Given this information, it is simply a matter of constructing a call
to <code>np.arange()</code> that resuts in the array
<code>[4, 3, 2, 1]</code>. While there are many calls that achieve this
outcome, one example is with the call
<code>np.arange(4, 0, -1)</code>.</p>
<p>So, the full expression that evaluates to
<code>np.array([16, 8, 4, 2])</code> is
<code>2 ** np.arange(4, 0, -1)</code></p>
<hr/>
<h5>Difficulty: ⭐️⭐️⭐️⭐️</h5>
<p>
</p>
<p>The average score on this problem was 38%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<hr />
<p class="meta"><em>Source:</em> wi24-midterm — Q7</p>
<h2 id="problem-42">Problem 42</h2>
<p>Part of the gameplay of <em>Clue</em> involves moving around the
gameboard. The gameboard has 9 rooms, arranged on a grid, and players
roll dice to determine how many spaces they can move.</p>
<p>The DataFrame <code>dist</code> contains a row and a column for each
of the 9 rooms. The entry in row <span class="math inline">r</span> and
column <span class="math inline">c</span> represents the shortest
distance between rooms <span class="math inline">r</span> and <span
class="math inline">c</span> on the <em>Clue</em> gameboard, or the
smallest dice roll that would be required to move between rooms <span
class="math inline">r</span> and <span class="math inline">c</span>.
Since you don’t need to move at all to get from a room to the same room,
the entries on the diagonal are all 0.</p>
<p><code>dist</code> is indexed by <code>"Room"</code>, and the room
names appear exactly as they appear in the index of the
<code>clue</code> DataFrame. These same values are also the column
labels in <code>dist</code>.</p>
<p><br></p>
<h3 id="problem-42.1">Problem 42.1</h3>
<p>Two of the following expressions are equivalent, meaning they
evaluate to the same value without erroring. Select these <strong>two
expressions</strong>.</p>
<ul class="task-list">
<li><p><input type="checkbox" disabled="" /> <code>dist.get("kitchen").loc["library"]</code></p></li>
<li><p><input type="checkbox" disabled="" /> <code>dist.get("kitchen").iloc["library"]</code></p></li>
<li><p><input type="checkbox" disabled="" /> <code>dist.get("library").loc["kitchen"]</code></p></li>
<li><p><input type="checkbox" disabled="" /> <code>dist.get("library").iloc["kitchen"]</code></p></li>
</ul>
<p>Explain in <strong>one sentence</strong> why these two expressions
are the same.</p>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading42_1">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse42_1" aria-expanded="true" aria-controls="collapse42_1">
Click to view the solution.
</button>
</h2>
<div id="collapse42_1" class="accordion-collapse collapse"
aria-labelledby="heading42_1" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer:</strong>
<code>dist.get("kitchen").loc["library"]</code> and
<code>dist.get("library").loc["kitchen"]</code></p>
<p><code>dist.get("kitchen").iloc["library"]</code> and
<code>dist.get("library").iloc["kitchen"]</code> are both wrong because
they uses <code>iloc</code> inappropriately. <code>iloc[]</code> takes
in an integer number representing the location of column, row, or cell
you would like to extract and it does not take a column or index
name.</p>
<p><code>dist.get("kitchen").loc["library"]</code> and
<code>dist.get("library").loc["kitchen"]</code> lead to the same answer
because the DataFrame has a unique property! The entry at <span class="math inline">r</span>, <span class="math inline">c</span> is the
same as the entry at <span class="math inline">c</span>, <span class="math inline">r</span> because both are the distances for the same
two rooms. The distance from the kitchen to library is the same as the
distance from the library to kichen.</p>
<hr/>
<h5>Difficulty: ⭐️⭐️</h5>
<p>
</p>
<p>The average score on this problem was 84%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<h3 id="problem-42.2">Problem 42.2</h3>
<p>On the <em>Clue</em> gameboard, there are two “secret passages." Each
secret passage connects two rooms. Players can immediately move through
secret passages without rolling, so in <code>dist</code> we record the
distance as 0 between two rooms that are connected with a secret
passage.</p>
<p>Suppose we run the following code.</p>
<div class="sourceCode" id="cb70"><pre
class="sourceCode py"><code class="sourceCode python"><span id="cb70-1"><a href="#cb70-1" aria-hidden="true" tabindex="-1"></a>    nonzero <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb70-2"><a href="#cb70-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> col <span class="kw">in</span> dist.columns:</span>
<span id="cb70-3"><a href="#cb70-3" aria-hidden="true" tabindex="-1"></a>        nonzero <span class="op">=</span> nonzero <span class="op">+</span> np.count_nonzero(dist.get(col))</span></code></pre></div>
<p>Determine the value of <code>nonzero</code> after the above code is
run.</p>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading42_2">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse42_2" aria-expanded="true" aria-controls="collapse42_2">
Click to view the solution.
</button>
</h2>
<div id="collapse42_2" class="accordion-collapse collapse"
aria-labelledby="heading42_2" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer:</strong> <code>nonzero</code> = 68</p>
<p>The <code>nonzero</code> variable represents the entries in the
DataFrame where the distance between two rooms is not 0. There are 81
entries in the DataFrame because there are 9 rooms and <span class="math inline">9 \cdot 9 = 81</span>. Since the diagonal of the
DataFrame is 0 (due to the distance from a room to itself being 0), we
know there are at most <span class="math inline">72 = 81 - 9</span>
nonzero entries in the DataFrame.</p>
<p>We are also told that there are 2 secret passages, each of which
connects 2 different rooms, meaning the distance between these rooms is
0. Each secret passage will cause 2 entries in the DataFrame to have a
distance of 0. For instance, if the secret passage was between the
kitchen and dining room, then the distance from the kitchen to the
dining room would be 0, but also the distance from the dining room to
the kitchen would be 0. Since there are 2 secret passages and each gives
rise to 2 entries that are 0, this is 4 additional entries that are 0.
This means there are 68 nonzero entries in the DataFrame, coming from
<span class="math inline">81 - 9 - 4 = 68</span>. </p>
<hr/>
<h5>Difficulty:
⭐️⭐️⭐️⭐️⭐️</h5>
<p>The average score on this problem was 28%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<h3 id="problem-42.3">Problem 42.3</h3>
<p>Fill in blanks so that the expression below evaluates to a DataFrame
with all the same information as <code>dist</code>, plus <strong>one
extra column</strong> called <code>"Cardholder"</code> containing
Janine’s knowledge of who holds each room card.</p>
<div class="sourceCode" id="cb71"><pre
class="sourceCode py"><code class="sourceCode python"><span id="cb71-1"><a href="#cb71-1" aria-hidden="true" tabindex="-1"></a>    dist.merge(___(a)___, ___(b)___, ___(c)___)</span></code></pre></div>
<ol type="1">
<li><p>What goes in blank (a)?</p></li>
<li><p>What goes in blank (b)?</p></li>
<li><p>What goes in blank (c)?</p></li>
</ol>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading42_3">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse42_3" aria-expanded="true" aria-controls="collapse42_3">
Click to view the solution.
</button>
</h2>
<div id="collapse42_3" class="accordion-collapse collapse"
aria-labelledby="heading42_3" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer:</strong></p>
<ul>
<li>(a): <code>clue.get(["Cardholder"])</code></li>
<li>(b): <code>left_index=True</code></li>
<li>(c): <code>right_index=True</code></li>
</ul>
<p>Since we want to create a DataFrame that looks like <code>dist</code>
with an extra column of <code>"Cardholder"</code>, we want to extract
just that column from <code>clue</code> to merge with <code>dist</code>.
We do this with <code>clue.get(["Cardholder"])</code>. This is necessary
because when we merge two DataFrames, we get all columns from either
DataFrame in the end result.</p>
<p>When deciding what columns to merge on, we need to look for columns
from each DataFrame that share common values. In this case, the common
values in the two DataFrames are not in columns, but in the index, so we
use <code>left_index=True</code> and <code>right_index=True</code>.</p>
<hr/>
<h5>Difficulty: ⭐️⭐️⭐️⭐️⭐️</h5>
<p>
</p>
<p>The average score on this problem was 28%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<h3 id="problem-42.4">Problem 42.4</h3>
<p>Suppose we generate a scatter plot as follows.</p>
<div class="sourceCode" id="cb72"><pre
class="sourceCode py"><code class="sourceCode python"><span id="cb72-1"><a href="#cb72-1" aria-hidden="true" tabindex="-1"></a>    dist.plot(kind<span class="op">=</span><span class="st">&quot;scatter&quot;</span>, x<span class="op">=</span><span class="st">&quot;kitchen&quot;</span>, y<span class="op">=</span><span class="st">&quot;study&quot;</span>)<span class="op">;</span></span></code></pre></div>
<p>Suppose the scatterplot has a point at (4, 6). What can we conclude
about the <em>Clue</em> gameboard?</p>
<ul class="task-list">
<li><p><input type="radio" disabled="" /> The kitchen is 4 spaces away from the study.</p></li>
<li><p><input type="radio" disabled="" /> The kitchen is 6 spaces away from the study.</p></li>
<li><p><input type="radio" disabled="" /> Another room besides the kitchen is 4 spaces away from the study.</p></li>
<li><p><input type="radio" disabled="" /> Another room besides the kitchen is 6 spaces away from the study.</p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading42_4">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse42_4" aria-expanded="true" aria-controls="collapse42_4">
Click to view the solution.
</button>
</h2>
<div id="collapse42_4" class="accordion-collapse collapse"
aria-labelledby="heading42_4" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer:</strong> Another room besides the kitchen is 6 spaces
away from the study.</p>
<p>Let’s explain each choice and why it is correct or incorrect. The
scatterplot shows how far a room is from the kitchen (as shown by values
on the x-axis) and how far a room is from the study (as shown by the
values on the y-axis). Each room is represented by a point. This means
there is a room that is 4 units away from the kitchen and 6 units away
from the study. This room can’t be the kitchen or study itself, since a
room must be distance 0 from itself. Therefore, we conclude, based on
the y-coordinate, that there is a room besides the kitchen that is 6
units away from the study.</p>
<hr/>
<h5>Difficulty: ⭐️⭐️⭐️⭐️</h5>
<p>
</p>
<p>The average score on this problem was 47%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<hr />
<p class="meta"><em>Source:</em> wi25-final — Q9</p>
<h2 id="problem-43">Problem 43</h2>
<p>The Triwizard Tournament is an international competition between
three wizarding academies: Hogwarts, Durmstrang, and Beauxbatons.</p>
<p>In a Triwizard Tournament, wizards from each school compete in three
dangerous magical challenges. If one school wins two or more challenges,
that school is the <strong>tournament champion</strong>. Otherwise,
there is no champion, since each school won a single challenge.</p>
<p>The DataFrame <code>triwiz</code> has a row for each challenge from
the first 20 Triwizard Tournaments. With 20 tournaments each having 3
challenges, <code>triwiz</code> has <strong>exactly 60 rows</strong>.
The first six rows are shown below.</p>
<center><img src='../../assets/images/wi25-final/triwiz.jpg' width=400></center>
<p>The columns are:</p>
<ul>
<li><p><code>"Year" (int)</code>: Triwizard Tournaments are held only
once every five years.</p></li>
<li><p><code>"Host" (str)</code>: Triwizard Tournaments are held at one
of the three participating schools on a rotating basis: Hogwarts,
Durmstrang, Beauxbatons, back to Hogwarts again, etc.</p></li>
<li><p><code>"Challenge" (int)</code>: Either <code>1</code>,
<code>2</code>, or <code>3</code>.</p></li>
<li><p><code>"Winner" (str)</code>: The school that won the
challenge.</p></li>
</ul>
<p><br></p>
<h3 id="problem-43.1">Problem 43.1</h3>
<p>(10 pts) Fill in the blanks below to create the DataFrame
<code>champions</code>, which is indexed by <code>"Winner"</code> and
has just one column, <code>"Year"</code>, containing <strong>the number
of years in which each school was the tournament champion</strong>.
<code>champions</code> is shown in full below.</p>
<center><img src='../../assets/images/wi25-final/champions.jpg' width=400></center>
<p>Note that the values in the <code>"Year"</code> column add up to 14,
not 20. That means there were 6 years in which there was a tie (for
example, 1299 was one such year).</p>
<pre><code>    grouped = triwiz.groupby(__(a)__).__(b)__.__(c)__
    filtered = grouped[__(d)__] 
    champions = filtered.groupby(__(e)__).__(f)__.__(g)__</code></pre>
<p>What goes in blank (a)?</p>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading43_1">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse43_1" aria-expanded="true" aria-controls="collapse43_1">
Click to view the solution.
</button>
</h2>
<div id="collapse43_1" class="accordion-collapse collapse"
aria-labelledby="heading43_1" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer:</strong> <code>["Year", "Winner"]</code> or
<code>["Winner", "Year"]</code></p>
<p>Grouping by both the <code>"Year"</code> and <code>"Winner"</code>
columns ensures that each school’s win in a given year is represented as
a single row.</p>
<hr/>
<h5>Difficulty: ⭐️⭐️</h5>
<p>
</p>
<p>The average score on this problem was 89%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<h3 id="problem-43.2">Problem 43.2</h3>
<p>What goes in blank (b)?</p>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading43_2">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse43_2" aria-expanded="true" aria-controls="collapse43_2">
Click to view the solution.
</button>
</h2>
<div id="collapse43_2" class="accordion-collapse collapse"
aria-labelledby="heading43_2" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer:</strong> <code>count()</code></p>
<p>Since each winner in a given year appears as a single row, we use
<code>count()</code> to determine how many times each school won that
year.</p>
<hr/>
<h5>Difficulty: ⭐️</h5>
<p>
</p>
<p>The average score on this problem was 90%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<h3 id="problem-43.3">Problem 43.3</h3>
<p>What goes in blank (c)?</p>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading43_3">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse43_3" aria-expanded="true" aria-controls="collapse43_3">
Click to view the solution.
</button>
</h2>
<div id="collapse43_3" class="accordion-collapse collapse"
aria-labelledby="heading43_3" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer:</strong> <code>reset_index()</code></p>
<p>Grouping by multiple columns creates a multi-index.
<code>reset_index()</code> flattens the DataFrame back to normal, where
each row represents a given year for each winning school.</p>
<hr/>
<h5>Difficulty: ⭐️⭐️</h5>
<p>
</p>
<p>The average score on this problem was 80%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<h3 id="problem-43.4">Problem 43.4</h3>
<p>What goes in blank (d)?</p>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading43_4">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse43_4" aria-expanded="true" aria-controls="collapse43_4">
Click to view the solution.
</button>
</h2>
<div id="collapse43_4" class="accordion-collapse collapse"
aria-labelledby="heading43_4" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer:</strong> <code>grouped.get("Host") != 1</code> or
<code>grouped.get("Host") &gt; 1</code> or
<code>grouped.get("Host") &gt;= 2</code></p>
<p>The Triwizard Tournament winner is defined as a school that wins two
or more challenges in a given year. After grouping with
<code>.count()</code>, all other columns contain the same value, which
is the number of challenges each <strong>winning</strong> school won
that year. A school will not appear in this DataFrame if they did not
win any challenges that year, so we only need to check if the value in
the other columns is not 1.<br/>
<code>.get("Challenge")</code> is also valid because all other columns
contain the same value.</p>
<hr/>
<h5>Difficulty: ⭐️⭐️⭐️</h5>
<p>
</p>
<p>The average score on this problem was 71%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<h3 id="problem-43.5">Problem 43.5</h3>
<p>What goes in blank (e)?</p>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading43_5">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse43_5" aria-expanded="true" aria-controls="collapse43_5">
Click to view the solution.
</button>
</h2>
<div id="collapse43_5" class="accordion-collapse collapse"
aria-labelledby="heading43_5" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer:</strong> <code>"Winner"</code></p>
<p>The resulting DataFrame should be indexed by <code>"Winner"</code>,
therefore the DataFrame is grouped by the <code>"Winner"</code>
column.</p>
<hr/>
<h5>Difficulty: ⭐️</h5>
<p>
</p>
<p>The average score on this problem was 90%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<h3 id="problem-43.6">Problem 43.6</h3>
<p>What goes in blank (f)?</p>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading43_6">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse43_6" aria-expanded="true" aria-controls="collapse43_6">
Click to view the solution.
</button>
</h2>
<div id="collapse43_6" class="accordion-collapse collapse"
aria-labelledby="heading43_6" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer:</strong> <code>count()</code></p>
<p>Grouping with <code>.count()</code> again ensures that the resulting
columns represent the number of times each <code>"Winner"</code>
(school) in the index won across all years.</p>
<hr/>
<h5>Difficulty: ⭐️⭐️</h5>
<p>
</p>
<p>The average score on this problem was 84%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<h3 id="problem-43.7">Problem 43.7</h3>
<p>What goes in blank (g)?</p>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading43_7">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse43_7" aria-expanded="true" aria-controls="collapse43_7">
Click to view the solution.
</button>
</h2>
<div id="collapse43_7" class="accordion-collapse collapse"
aria-labelledby="heading43_7" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer:</strong> <code>get(["Year"])</code></p>
<p>The question asks for a DataFrame with <code>"Year"</code> as the
only column, so brackets are used around <code>"Year"</code> to ensure
the output is a DataFrame rather than a Series.</p>
<hr/>
<h5>Difficulty: ⭐️⭐️⭐️</h5>
<p>
</p>
<p>The average score on this problem was 69%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<h3 id="problem-43.8">Problem 43.8</h3>
<p>How many rows are in the DataFrame that results from merging
<code>triwiz</code> with itself on <code>"Year"</code>? Give your answer
as an <strong>integer</strong>.</p>
<div class="center">

</div>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading43_8">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse43_8" aria-expanded="true" aria-controls="collapse43_8">
Click to view the solution.
</button>
</h2>
<div id="collapse43_8" class="accordion-collapse collapse"
aria-labelledby="heading43_8" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer:</strong> 180</p>
<p>The most important part of this question is understanding how
<code>merge</code> works in <code>babypandas</code>. Start by
<a href="https://dsc10.com/diagrams/#merging">reviewing this diagram</a>
from lecture.</p>
<p>When we merge two DataFrames together by <code>"Year"</code>, we are
matching every row in <code>triwiz</code> with every other row that has
the same value in the <code>"Year"</code> column. This means that for
each year, we’ll match all the rows from that year with each other.
Since there are three challenges per year, that means that each year
appears 3 times in the DataFrame. Since we are matching all rows from
each year with each other, this means we will end up with <span class="math inline">3 * 3</span> or 9 rows per year. Since there are 20
years in the DataFrame, we can multiply these together to get 180 total
rows in the merged DataFrame.</p>
<hr/>
<h5>Difficulty: ⭐️⭐️⭐️</h5>
<p>
</p>
<p>The average score on this problem was 69%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<h3 id="problem-43.9">Problem 43.9</h3>
<p>How many rows are in the DataFrame that results from merging
<code>triwiz</code> with itself on <code>"Challenge"</code>? Give your
answer as an <strong>integer</strong>.</p>
<div class="center">

</div>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading43_9">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse43_9" aria-expanded="true" aria-controls="collapse43_9">
Click to view the solution.
</button>
</h2>
<div id="collapse43_9" class="accordion-collapse collapse"
aria-labelledby="heading43_9" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer:</strong> 1200</p>
<p>Similar to the previous part, we are now matching all rows from a
given challenge to each other. There are 3 challenges per tournament, so
the values in the <code>"Challenge"</code> column are <code>1</code>,
<code>2</code>, and <code>3</code>. Each such values appears 20 times,
once for each year. As a result, for each of the 3 challenges there are
<span class="math inline">20 * 20</span> or 400 rows. Therefore, we have
<span class="math inline">400 * 3 = 1200</span> rows total.</p>
<hr/>
<h5>Difficulty: ⭐️⭐️⭐️</h5>
<p>
</p>
<p>The average score on this problem was 59%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<h3 id="problem-43.10">Problem 43.10</h3>
<p>How many rows are in the DataFrame that results from merging
<code>triwiz</code> with itself on <code>"Host"</code>? Select the
expression that evaluates to this number.</p>
<ul class="task-list">
<li><p><input type="radio" disabled="" /> <span class="math inline">2\cdot 6^2 + 7^2</span></p></li>
<li><p><input type="radio" disabled="" /> <span class="math inline">2\cdot 7^2 + 6^2</span></p></li>
<li><p><input type="radio" disabled="" /> <span class="math inline">2\cdot 18^2 + 21^2</span></p></li>
<li><p><input type="radio" disabled="" /> <span class="math inline">2\cdot 21^2 + 18^2</span></p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading43_10">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse43_10" aria-expanded="true" aria-controls="collapse43_10">
Click to view the solution.
</button>
</h2>
<div id="collapse43_10" class="accordion-collapse collapse"
aria-labelledby="heading43_10" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer:</strong> <span class="math inline">2 * 21^2 +
18^2</span></p>
<p>The key to understanding how this problem works is by understanding
how many times each school ends up hosting the tournament within this
dataset. It is stated that the host is determined on a rotating basis.
Based on the DataFrame description, we know the order is Hogwarts,
Durmstrang, and then Beauxbatons. Since there are only 20 years in this
dataset, the last school in the rotation will have one less host than
the other two schools. Thus, we have determined that Hogwarts hosts 7
times, Durmstrang hosts 7 times, and Beauxbatons hosts 6 times. Since
for each year a school hosts, they appear three times in the DataFrame,
each school appears 21 times, 21 times, and 18 times respectively. As
stated in the above questions when merging we are matching all rows from
a given host to each other. Therefore, the total rows can be expressed
as <span class="math inline">21^2 + 21^2 + 18^2</span>. This matches the
last answer choice.</p>
<hr/>
<h5>Difficulty: ⭐️⭐️⭐️⭐️</h5>
<p>
</p>
<p>The average score on this problem was 43%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<hr />
<p class="meta"><em>Source:</em> wi25-midterm — Q2</p>
<h2 id="problem-44">Problem 44</h2>
<p>As a broke college student, you are on a mission to find the dining
hall with the greatest number of affordable menu items.</p>
<p><br></p>
<h3 id="problem-44.1">Problem 44.1</h3>
<p>To begin, you want a DataFrame with the same columns as
<code>dining</code>, but with an additional column
<code>"Affordability"</code> which classifies each menu item as
follows:</p>
<ol type="1">
<li><p><code>"Cheap"</code>, for items that cost $6 or less.</p></li>
<li><p><code>"Moderate"</code>, for items that cost more than $6 and at
most $14.</p></li>
<li><p><code>"Expensive"</code>, for items that cost more than
$14.</p></li>
</ol>
<p>Fill in the blanks below to assign this new DataFrame to the variable
<code>with_affordability</code>.</p>
<div class="sourceCode" id="cb74"><pre
class="sourceCode py"><code class="sourceCode python"><span id="cb74-1"><a href="#cb74-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> categorize(price):</span>
<span id="cb74-2"><a href="#cb74-2" aria-hidden="true" tabindex="-1"></a>        price_as_float <span class="op">=</span> __(a)__  </span>
<span id="cb74-3"><a href="#cb74-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> price_as_float __(b)__:</span>
<span id="cb74-4"><a href="#cb74-4" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> __(c)__</span>
<span id="cb74-5"><a href="#cb74-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> price_as_float <span class="op">&gt;</span> <span class="dv">6</span>:</span>
<span id="cb74-6"><a href="#cb74-6" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="st">&quot;Moderate&quot;</span></span>
<span id="cb74-7"><a href="#cb74-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb74-8"><a href="#cb74-8" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> __(d)__</span>
<span id="cb74-9"><a href="#cb74-9" aria-hidden="true" tabindex="-1"></a>    with_affordability <span class="op">=</span> dining.assign(Affordability <span class="op">=</span> __(e)__)</span></code></pre></div>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading44_1">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse44_1" aria-expanded="true" aria-controls="collapse44_1">
Click to view the solution.
</button>
</h2>
<div id="collapse44_1" class="accordion-collapse collapse"
aria-labelledby="heading44_1" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer (a):</strong> <code>float(price.strip("$"))</code> or
<code>float(price.replace("$", ""))</code> or
<code>float(price.split("$")[1])</code></p>
<p>To solve this problem, we must keep in mind that the prices in the
<code>"Price"</code> column are formatted as strings with dollar signs
in front of them. For example, we might see a value such as
<code>"$9.50"</code>. Our function’s goal is to transform any given
value in the <code>"Price"</code> column into a float matching the
corresponding dollar amount.</p>
<p>Therefore, one strategy is to first use the <code>.strip</code>
string method to strip the price of the initial dollar sign. Since we
need our output as a float, we can call the python <code>float</code>
function on this to get the price as a float.</p>
<p>The other strategies are similar. We can replace the dollar sign with
the empty string, effectively removing it, then convert to a float.
Similarly, we can split the price according to the instances of
<code>"$"</code>. This will return a list of two elements, the first of
which contains everything before the dollar sign, which is the empty
string, and the second of which contains everything after the dollar
sign, which is the part we want. We extract it with <code>[1]</code> and
then convert the answer to a float.</p>
<hr/>
<h5>Difficulty: ⭐️⭐️⭐️</h5>
<p>
</p>
<p>The average score on this problem was 61%.</p>
<p><strong>Answer (b):</strong> <code>&gt; 14</code></p>
<p>The key to getting this question correct comes from understanding how
the placement of <code>price_as_float &gt; 6</code> affects how you
order the rest of the conditionals within the function. The method
through which we test if a price is <code>"Moderate"</code> is by
checking if <code>price_as_float &gt; 6</code>. But
<code>"Moderate"</code> is defined as being not only more than 6 dollars
but also less that or equal to 14 dollars. So we must first check to see
if the price is <code>"Expensive"</code> before we check and see if the
price is <code>"Moderate"</code>. This way, prices that are in the
<code>"Expensive"</code> range get caught by the first <code>if</code>
statement, and then prices in the <code>"Moderate"</code> range get
caught by the <code>elif</code>.</p>
<hr/>
<h5>Difficulty: ⭐️⭐️⭐️</h5>
<p>
</p>
<p>The average score on this problem was 74%.</p>
<p><strong>Answer (c):</strong> <code>"Expensive"</code></p>
<p>In the previous part of this question we checked to see if the
<code>price_as_float &gt; 14</code>. We did this to see if the given
price falls into the <code>"Expensive"</code> category. Since the
<code>categorize</code> function is meant to take in a price and output
the corresponding category, we just need to output the correct category
for this conditional which is <code>"Expensive"</code>.</p>
<hr/>
<h5>Difficulty: ⭐️⭐️</h5>
<p>
</p>
<p>The average score on this problem was 75%.</p>
<p><strong>Answer (d):</strong> <code>"Cheap"</code></p>
<p>In the previous parts of this question, we have implemented checks to
see if a price is <code>"Expensive"</code> or <code>"Moderate"</code>.
This leaves only the <code>"Cheap"</code> price category, meaning that
it can be placed in the else statement. The logic is we check if a price
is <code>"Expensive"</code> or <code>"Moderate"</code> and if its
neither, it has to be <code>"Cheap"</code>.</p>
<hr/>
<h5>Difficulty: ⭐️⭐️⭐️</h5>
<p>
</p>
<p>The average score on this problem was 74%.</p>
<p><strong>Answer (e):</strong>
<code>dining.get("Price").apply(categorize)</code></p>
<p>Now that we have implemented the <code>categorize</code> function, we
need to apply it to the <code>"Price"</code> column so that it can be
added as a new column into <code>dining</code>. Keep in mind our
function takes in one price and outputs its price category. Thus, we
need a way to apply this function to every value in the Series that
corresponds to the <code>"Price"</code> column. To do this, we first
need to <code>get</code> the Series from the DataFrame and then use
<code>apply</code> on that Series with our <code>categorize</code>
function as the input.</p>
<hr/>
<h5>Difficulty: ⭐️⭐️</h5>
<p>
</p>
<p>The average score on this problem was 89%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<h3 id="problem-44.2">Problem 44.2</h3>
<p>Now, you want to determine, for each dining hall, the number of menu
items that fall into each affordability category. Fill in the blanks to
define a DataFrame called <code>counts</code> containing this
information. <code>counts</code> should have exactly three columns,
named <code>"Dining Hall"</code>, <code>"Affordability"</code>, and
<code>"Count"</code>.</p>
<div class="sourceCode" id="cb75"><pre
class="sourceCode py"><code class="sourceCode python"><span id="cb75-1"><a href="#cb75-1" aria-hidden="true" tabindex="-1"></a>    counts <span class="op">=</span> with_affordability.groupby(__(f)__).count().reset_index()</span>
<span id="cb75-2"><a href="#cb75-2" aria-hidden="true" tabindex="-1"></a>    counts <span class="op">=</span> counts.assign(Count<span class="op">=</span>__(g)__).__(h)__</span></code></pre></div>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading44_2">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse44_2" aria-expanded="true" aria-controls="collapse44_2">
Click to view the solution.
</button>
</h2>
<div id="collapse44_2" class="accordion-collapse collapse"
aria-labelledby="heading44_2" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer (f):</strong>
<code>["Dining Hall", "Affordability"]</code> or
<code>["Affordability", "Dining Hall"]</code></p>
<p>The key to solving this problem comes from understanding exactly what
the question is asking. You are asked to create a DataFrame that
displays, in each dining hall, the number of menu items that fall into
each affordability category. This indicates that you will need to group
by both “Dining Hall” and “Affordability” because when you group by
multiple columns you get a row for every combination of values in those
columns. Rembemer that to group by multiple columns, you need to input
the columns names in a <strong>list</strong> as an argument in the
<code>groupby</code> function. The order of the columns does not
matter.</p>
<hr/>
<h5>Difficulty: ⭐️⭐️</h5>
<p>
</p>
<p>The average score on this problem was 81%.</p>
<p><strong>Answer (g):</strong> <code>counts.get("Price")</code> or
<code>counts.get("Calories")</code> or
<code>counts.get("Item")</code></p>
<p>For this part, you need to create a column called
<code>"Count"</code> with the number of menu items that fall into each
affordability category within each dining hall. The
<code>.count()</code> aggregation method works by counting the number of
values in each column within each group. In the resulting DataFrame, all
the columns have the same values, so we can use the values from any one
of the non-index columns in the grouped DataFrame. In this case, those
columns are <code>"Price"</code>, <code>"Calories"</code>, and
<code>"Item"</code>. Therefore to fill in the blank, you would get any
one of these columns.</p>
<hr/>
<h5>Difficulty: ⭐️⭐️⭐️</h5>
<p>
</p>
<p>The average score on this problem was 62%.</p>
<p><strong>Answer (h):</strong>
<code>get(["Dining Hall", "Affordability", "Count"])</code>or
<code>drop(columns=["Item", "Price", "Calories"])</code> (columns can be
in any order)</p>
<p>Recall the question asked to create a DataFrame with only three
columns. You have just added one of the columns, <code>"Count</code>.
This means you have to drop the remaining columns (<code>"Price"</code>,
<code>"Calories"</code>, and <code>"Item"</code>) or simply get the
desired columns (<code>"Dining Hall"</code>,
<code>"Affordability"</code>, and <code>"Count"</code>).</p>
<hr/>
<h5>Difficulty: ⭐️⭐️</h5>
<p>
</p>
<p>The average score on this problem was 77%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<h3 id="problem-44.3">Problem 44.3</h3>
<p>Suppose you determine that <code>"The Bistro"</code> is the dining
hall with the most menu items in the <code>"Cheap"</code> category, so
you will drag yourself there for every meal. Which of the following
expressions must evaluate to the number of <code>"Cheap"</code> menu
items available at <code>"The Bistro"</code>? <strong>Select all that
apply.</strong></p>
<ul class="task-list">
<li><p><input type="checkbox" disabled="" /> <code>counts.sort_values(by="Count", ascending=False).get("Count").iloc[0]</code></p></li>
<li><p><input type="checkbox" disabled="" /> <code>counts.get("Count").max()</code></p></li>
<li><p><input type="checkbox" disabled="" /> <code>(counts[counts.get("Affordability") == "Cheap"].sort_values(by="Count").get("Count").iloc[-1])</code></p></li>
<li><p><input type="checkbox" disabled="" /> <code>counts[counts.get("Dining Hall") == "The Bistro"].get("Count").max()</code></p></li>
<li><p><input type="checkbox" disabled="" /> <code>counts[(counts.get("Affordability") == "Cheap") &amp; (counts.get("Dining Hall") == "The Bistro")].get("Count").iloc[0]</code></p></li>
<li><p><input type="checkbox" disabled="" /> None of these.</p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading44_3">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse44_3" aria-expanded="true" aria-controls="collapse44_3">
Click to view the solution.
</button>
</h2>
<div id="collapse44_3" class="accordion-collapse collapse"
aria-labelledby="heading44_3" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer:</strong>
<code>(counts[counts.get("Affordability") == "Cheap"].sort_values(by="Count").get("Count").iloc[-1])</code>
and
<code>counts[(counts.get("Affordability") == "Cheap") &amp; (counts.get("Dining Hall") == "The Bistro")].get("Count").iloc[0]</code></p>
<ul>
<li><p><strong>Option 1</strong>: This code sorts all rows by
<code>"Count"</code> in descending order (largest to smallest) and
selects the count from the first row. This is incorrect because there
can be another combination of <code>"Dining Hall"</code> and
<code>"Affordability"</code> that has a number of menu items larger than
the number of <code>"Cheap"</code> items at <code>"The Bistro"</code>.
For example, maybe there are 100 <code>"Cheap"</code> items at
<code>"The Bistro"</code> but 200 <code>"Moderate"</code> items at
<code>"Pines"</code>.</p></li>
<li><p><strong>Option 2</strong>: This code selects the largest value in
the <code>"Count"</code> column, which may not necessarily be the number
of <code>"Cheap"</code> items at <code>"The Bistro"</code>. Taking the
same example as above, maybe there are 100 <code>"Cheap"</code> items at
<code>"The Bistro"</code> but 200 <code>"Moderate"</code> items at
<code>"Pines"</code>.</p></li>
<li><p><strong>Option 3</strong>: This code first filters
<code>counts</code> to only include rows where
<code>"Affordability"</code> is <code>"Cheap"</code>. Then, it sorts by
<code>"Count"</code> in ascending order (smallest to largest). Since the
question states that <code>"The Bistro"</code> has the most
<code>"Cheap"</code> menu items, selecting the last row
<code>(iloc[-1])</code> from the <code>"Count"</code> column correctly
retrieves the number of <code>"Cheap"</code> menu items at
<code>"The Bistro"</code>.</p></li>
<li><p><strong>Option 4</strong>: This code filters <code>counts</code>
to only include rows where <code>"Dining Hall"</code> is
<code>"The Bistro"</code>, then returns the maximum value in the
<code>"Count"</code> column. However, <code>"The Bistro"</code> may have
more menu items in the <code>"Moderate"</code> or
<code>"Expensive"</code> categories than it does in the
<code>"Cheap"</code> category. This query does not isolate
<code>"Cheap"</code> items, so it incorrectly returns the highest count
across all affordability levels rather than just
<code>"Cheap"</code>.</p></li>
</ul>
<p>For example, if <code>"The Bistro"</code> has 100
<code>"Cheap"</code> menu items, 200 <code>"Moderate"</code> menu items,
and 50 <code>"Cheap"</code> menu items, this code would evaluate to 200,
even though that is not the number of <code>"Cheap"</code> items at
<code>"The Bistro"</code>. This is possible because we are told that
<code>"The Bistro"</code> is the dining hall with the most menu items in
the <code>"Cheap"</code> category, meaning in this example that every
other dining hall has fewer than 100 <code>"Cheap"</code> items.
However, this tells us nothing about the number of menu items at
<code>"The Bistro"</code> in the other affordability categories, which
can be greater than 100.</p>
<ul>
<li><strong>Option 5</strong>: This code queries to find the rows that
correspond to <code>"Cheap"</code> affordabaility, and a
<code>"Dining Hall"</code> value of <code>"The Bistro"</code>. This is
only one such row! The code then selects the first (and only) value in
the <code>"Count"</code> column, which correctly evaluates to the number
of <code>"Cheap"</code> items at <code>"The Bistro"</code>.</li>
</ul>
<hr/>
<h5>Difficulty: ⭐️⭐️</h5>
<p>
</p>
<p>The average score on this problem was 84%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<hr />
<p class="meta"><em>Source:</em> wi25-midterm — Q5</p>
<h2 id="problem-45">Problem 45</h2>
<p>It’s the grand opening of UCSD’s newest dining attraction: The Bread
Basket! As a hardcore bread enthusiast, you celebrate by eating as much
bread as possible. There are only a few menu items at The Bread Basket,
shown with their costs in the table below:</p>
<table>
<thead>
<tr>
<th style="text-align: center;"><strong>Bread</strong></th>
<th style="text-align: center;"><strong>Cost</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">Sourdough</td>
<td style="text-align: center;">2</td>
</tr>
<tr>
<td style="text-align: center;">Whole Wheat</td>
<td style="text-align: center;">3</td>
</tr>
<tr>
<td style="text-align: center;">Multigrain</td>
<td style="text-align: center;">4</td>
</tr>
</tbody>
</table>
<p>Suppose you are given an array <code>eaten</code> containing the
names of each type of bread you ate.</p>
<p>For example, <code>eaten</code> could be defined as follows:</p>
<div class="sourceCode" id="cb76"><pre
class="sourceCode py"><code class="sourceCode python"><span id="cb76-1"><a href="#cb76-1" aria-hidden="true" tabindex="-1"></a>    eaten <span class="op">=</span> np.array([<span class="st">&quot;Whole Wheat&quot;</span>, <span class="st">&quot;Sourdough&quot;</span>, <span class="st">&quot;Whole Wheat&quot;</span>, </span>
<span id="cb76-2"><a href="#cb76-2" aria-hidden="true" tabindex="-1"></a>                      <span class="st">&quot;Sourdough&quot;</span>, <span class="st">&quot;Sourdough&quot;</span>])</span></code></pre></div>
<p>In this example, <code>eaten</code> represents five slices of bread
that you ate, for a total cost of <span class="math inline">\$12</span>.
Pricey!</p>
<p>In this problem, you’ll calculate the total cost of your bread-eating
extravaganza in various ways. In all cases, your code must calculate the
total cost for an arbitrary <code>eaten</code> array, which might not be
exactly the same as the example shown above.</p>
<p><br></p>
<h3 id="problem-45.1">Problem 45.1</h3>
<p>One way to calculate the total cost of the bread in the
<code>eaten</code> array is outlined below. Fill in the missing
code.</p>
<div class="sourceCode" id="cb77"><pre
class="sourceCode py"><code class="sourceCode python"><span id="cb77-1"><a href="#cb77-1" aria-hidden="true" tabindex="-1"></a>    breads <span class="op">=</span> [<span class="st">&quot;Sourdough&quot;</span>, <span class="st">&quot;Whole Wheat&quot;</span>, <span class="st">&quot;Multigrain&quot;</span>]</span>
<span id="cb77-2"><a href="#cb77-2" aria-hidden="true" tabindex="-1"></a>    prices <span class="op">=</span> [<span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>]</span>
<span id="cb77-3"><a href="#cb77-3" aria-hidden="true" tabindex="-1"></a>    total_cost <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb77-4"><a href="#cb77-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> __(a)__:</span>
<span id="cb77-5"><a href="#cb77-5" aria-hidden="true" tabindex="-1"></a>        total_cost <span class="op">=</span> (total_cost <span class="op">+</span> </span>
<span id="cb77-6"><a href="#cb77-6" aria-hidden="true" tabindex="-1"></a>                     np.count_nonzero(eaten <span class="op">==</span> __(b)__) <span class="op">*</span> __(c)__)</span></code></pre></div>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading45_1">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse45_1" aria-expanded="true" aria-controls="collapse45_1">
Click to view the solution.
</button>
</h2>
<div id="collapse45_1" class="accordion-collapse collapse"
aria-labelledby="heading45_1" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer (a):</strong> <code>[0, 1, 2]</code> or
<code>np.arange(len(bread))</code> or <code>range(3)</code> or
equivalent</p>
<p>Let’s read through the code skeleton and develop the answers from
intuition. First, we notice a <code>for</code> loop, but we don’t yet
know what sequence we’ll be looping through.</p>
<p>Then we notice a variable <code>total_cost</code> that is initalized
to <code>0</code>. This suggests we’ll use the accumulator pattern to
keep a running total.</p>
<p>Inside the loop, we see that we are indeed adding onto the running
total. The amount by which we increase <code>total_cost</code> is
<code>np.count_nonzero(eaten == __(b)__) * __(c)__</code>. Let’s
remember what this does. It first compares the <code>eaten</code> array
to some value and then counts how many <code>True</code> values are in
resulting Boolean array. In other words, it counts how many times the
entries in the <code>eaten</code> array equal some particular value.
This is a big clue about how to fill in the code. There are only three
possible values in the <code>eaten</code> array, and they are
<code>"Sourdough"</code>, <code>"Whole Wheat"</code>, and
<code>"Multigrain"</code>. For example, if blank (b) were filled with
<code>"Sourdough"</code>, we would be counting how many of the slices in
the <code>eaten</code> array were <code>"Sourdough"</code>. Since each
such slice costs 2 dollars, we could find the total cost of all
<code>"Sourdough"</code> slices by multiplying this count by 2.</p>
<p>Understanding this helps us understand what the code is doing: it is
separately computing the cost of each type of bread
(<code>"Sourdough"</code>, <code>"Whole Wheat"</code>,
<code>"Multigrain"</code>) and adding this onto the running total. Once
we understand what the code is doing, we can figure out how to fill in
the blanks.</p>
<p>We just discussed filling in blank (b) with <code>"Sourdough"</code>,
in which case we would have to fill in blank (c) with <code>2</code>.
But that just gives the contribution of <code>"Sourdough"</code> to the
overall cost. We also need the contributions from
<code>"Whole Wheat"</code> and <code>"Multigrain"</code>. Somehow, blank
(b) needs to take on the values in the provided <code>breads</code>
array. Similarly, blank (c) needs to take on the values in the
<code>prices</code> array, and we need to make sure that we iterate
through both of these arrays simultaneously. This means we should access
<code>breads[0]</code> when we access <code>prices[0]</code>, for
example. We can use the loop variable <code>i</code> to help us, and
fill in blank (b) with <code>breads[i]</code> and blank (c) with
<code>prices[i]</code>. This means <code>i</code> needs to take on the
values <code>0</code>, <code>1</code>, <code>2</code>, so we can loop
through the sequence <code>[0, 1, 2]</code> in blank (a). This is also
the same as <code>range(len(bread))</code> and
<code>range(len(price))</code>.</p>
<p>Bravo! We have everything we want, and the code block is now
complete.</p>
<hr/>
<h5>Difficulty: ⭐️⭐️⭐️</h5>
<p>
</p>
<p>The average score on this problem was 58%.</p>
<p><strong>Answer (b):</strong> <code>breads[i]</code></p>
<p>See explanation above.</p>
<hr/>
<h5>Difficulty: ⭐️⭐️⭐️</h5>
<p>
</p>
<p>The average score on this problem was 61%.</p>
<p><strong>Answer (c):</strong> <code>prices[i]</code></p>
<p>See explanation above.</p>
<hr/>
<h5>Difficulty: ⭐️⭐️⭐️</h5>
<p>
</p>
<p>The average score on this problem was 61%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<h3 id="problem-45.2">Problem 45.2</h3>
<p>Another way to calculate the total cost of the bread in the
<code>eaten</code> array uses the <code>merge</code> method. Fill in the
missing code below.</p>
<div class="sourceCode" id="cb78"><pre
class="sourceCode py"><code class="sourceCode python"><span id="cb78-1"><a href="#cb78-1" aria-hidden="true" tabindex="-1"></a>    available <span class="op">=</span> bpd.DataFrame().assign(Type <span class="op">=</span> [<span class="st">&quot;Sourdough&quot;</span>, </span>
<span id="cb78-2"><a href="#cb78-2" aria-hidden="true" tabindex="-1"></a>                <span class="st">&quot;Whole Wheat&quot;</span>, <span class="st">&quot;Multigrain&quot;</span>]).assign(Cost <span class="op">=</span> [<span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>])</span>
<span id="cb78-3"><a href="#cb78-3" aria-hidden="true" tabindex="-1"></a>    consumed <span class="op">=</span> bpd.DataFrame().assign(Eaten <span class="op">=</span> eaten)</span>
<span id="cb78-4"><a href="#cb78-4" aria-hidden="true" tabindex="-1"></a>    combined <span class="op">=</span> available.merge(consumed, left_on <span class="op">=</span> __(d)__, </span>
<span id="cb78-5"><a href="#cb78-5" aria-hidden="true" tabindex="-1"></a>                               right_on <span class="op">=</span> __(e)__)   </span>
<span id="cb78-6"><a href="#cb78-6" aria-hidden="true" tabindex="-1"></a>    total_cost <span class="op">=</span> combined.__(f)__</span></code></pre></div>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading45_2">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse45_2" aria-expanded="true" aria-controls="collapse45_2">
Click to view the solution.
</button>
</h2>
<div id="collapse45_2" class="accordion-collapse collapse"
aria-labelledby="heading45_2" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer (d):</strong> <code>"Type"</code></p>
<p>It always helps to sketch out the DataFrames.
</p>
<center><img src="../../assets/images/wi25-midterm/q5-2.png" width="300"/></center>
<p>Let’s first develop some intuition based on the keywords.</p>
<ol type="1">
<li><p>We create two DataFrames as seen above, and we perform a <a href="https://dsc-courses.github.io/bpd-reference/docs/documentation/building-organizing/df.merge()">merge</a>)
operation. We want to fill in what columns to merge on. It should be
easy to see that blank (e) would be the <code>"Eaten"</code> column in
<code>consumed</code>, so let’s fill that in.</p></li>
<li><p>We are getting <code>total_cost</code> from the
<code>combined</code> DataFrame in some way. If we want the total amount
of something, which aggregation function might we use?</p></li>
</ol>
<p>In general, if we have
<code>df_left.merge(df_right, left_on=col_left, right_on=col_right)</code>,
assuming all entries are non-empty, the merge process looks at
individual entries from the specified column in <code>df_left</code> and
grabs all entries from the specified column in <code>df_right</code>
that matches the entry content. Based on this, we know that the
<code>combined</code> DataFrame will contain a column of all the breads
we have eaten and their corresponding prices. Blank (d) is also settled:
we can get the list of all breads by merging on the <code>"Type"</code>
column in <code>available</code> to match with <code>"Eaten"</code>.</p>
<hr/>
<h5>Difficulty: ⭐️⭐️</h5>
<p>
</p>
<p>The average score on this problem was 81%.</p>
<p><strong>Answer (e):</strong> <code>"Eaten"</code></p>
<p>See explanation above.</p>
<hr/>
<h5>Difficulty: ⭐️⭐️</h5>
<p>
</p>
<p>The average score on this problem was 80%.</p>
<p><strong>Answer (f):</strong> <code>get("Cost").sum()</code></p>
<p>The <code>combined</code> DataFrame would look something like this:
</p>
<center><img src="../../assets/images/wi25-midterm/q5-2-f.png" width="200"/></center>
<p>To get the total cost of the bread in <code>"Eaten"</code>, we can
take the sum of the <code>"Cost"</code> column.</p>
<hr/>
<h5>Difficulty: ⭐️⭐️⭐️</h5>
<p>
</p>
<p>The average score on this problem was 70%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<hr />
</body>
</html>
