<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Lecture 13 — Practice</title>
  <style>
    /* Default styles provided by pandoc.
    ** See https://pandoc.org/MANUAL.html#variables-for-html for config info.
    */
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    /* CSS for syntax highlighting */
    html { -webkit-text-size-adjust: 100%; }
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { color: #008000; } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { color: #008000; font-weight: bold; } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="..\..\assets\theme.css" />
  <script defer=""
  src="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <link rel="stylesheet"
  href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css" />
</head>
<body>
<header id="title-block-header">
<h1 class="title">Lecture 13 — Practice</h1>
</header>
<p><link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-EVSTQN3/azprG1Anm3QDgpJLIm9Nao0Yz1ztcQTwFspd3yD65VohhpuuCOmLASjC" crossorigin="anonymous">
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/js/bootstrap.bundle.min.js" integrity="sha384-MrcW6ZMFYlzcLA8Nl+NtUVF0sA7MsXsP1UyJoMp4YLEuNSfAP+JcXn/tWtIaxVXM" crossorigin="anonymous"></script>
<!-- add after bootstrap.min.css -->
<link rel="stylesheet" href="https://cdn.rawgit.com/afeld/bootstrap-toc/v1.0.1/dist/bootstrap-toc.min.css"/>
<!-- add after bootstrap.min.js or bootstrap.bundle.min.js -->
<script src="https://cdn.rawgit.com/afeld/bootstrap-toc/v1.0.1/dist/bootstrap-toc.min.js"></script></p>
<!-- for difficulty gauges-->
<script src="https://cdn.plot.ly/plotly-2.16.1.min.js"></script>
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-B947E6J6H4"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-B947E6J6H4');
</script>
<p><a href="../../index.html">← return to practice.dsc10.com</a></p>
<hr />
<h1 id="lecture-13-collected-practice-questions">Lecture 13 — Collected
Practice Questions</h1>
<p>Below are practice problems tagged for Lecture <strong>13</strong>
(rendered directly from the original exam/quiz sources).</p>
<hr />
<h2 id="problem-1">Problem 1</h2>
<p><br></p>
<h3 id="problem-1.1">Problem 1.1</h3>
<p>Which of the following blocks of code correctly assigns
<code>random_art_museums</code> to an array of the names of 10 art
museums, randomly selected without replacement from those in
<code>art_museums</code>? Select all that apply.</p>
<p>Option 1:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> get_10(df):</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.array(df.sample(<span class="dv">10</span>).get(<span class="st">&#39;Name&#39;</span>))</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>random_art_museums <span class="op">=</span> get_10(art_museums)</span></code></pre></div>
<p>Option 2:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> get_10(art_museums):</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.array(art_museums.sample(<span class="dv">10</span>).get(<span class="st">&#39;Name&#39;</span>))</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>random_art_museums <span class="op">=</span> get_10(art_museums)</span></code></pre></div>
<p>Option 3:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> get_10(art_museums):</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    random_art_museums <span class="op">=</span> np.array(art_museums.sample(<span class="dv">10</span>).get(<span class="st">&#39;Name&#39;</span>))</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>random_art_museums <span class="op">=</span> get_10(art_museums)</span></code></pre></div>
<p>Option 4:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> get_10():</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.array(art_museums.sample(<span class="dv">10</span>).get(<span class="st">&#39;Name&#39;</span>))</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>random_art_museums <span class="op">=</span> get_10()</span></code></pre></div>
<p>Option 5:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>random_art_museums <span class="op">=</span> np.array([])</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> get_10():</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>    random_art_museums <span class="op">=</span> np.array(art_museums.sample(<span class="dv">10</span>).get(<span class="st">&#39;Name&#39;</span>))</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> random_art_museums</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>get_10()</span></code></pre></div>
<ul class="task-list">
<li><p><input type="checkbox" disabled="" /> Option 1</p></li>
<li><p><input type="checkbox" disabled="" /> Option 2</p></li>
<li><p><input type="checkbox" disabled="" /> Option 3</p></li>
<li><p><input type="checkbox" disabled="" /> Option 4</p></li>
<li><p><input type="checkbox" disabled="" /> Option 5</p></li>
<li><p><input type="checkbox" disabled="" /> None of the above</p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading1_1">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse1_1" aria-expanded="true" aria-controls="collapse1_1">
Click to view the solution.
</button>
</h2>
<div id="collapse1_1" class="accordion-collapse collapse"
aria-labelledby="heading1_1" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answers:</strong> Option 1, Option 2, and Option 4</p>
<p>Note that if <code>df</code> is a DataFrame, then
<code>df.sample(10)</code> is a DataFrame containing 10 randomly
selected rows in <code>df</code>. With that in mind, let’s look at all
of our options.</p>
<ul>
<li><strong>Option 1:</strong> This implementation of
<code>get_10</code> takes in a DataFrame <code>df</code> and returns an
array containing 10 randomly selected values in <code>df</code>’s
<code>'Name'</code> column. After defining <code>get_10</code>, we
assign <code>random_art_museums</code> to the result of calling
<code>get_10(art_museums)</code>. This assigns
<code>random_art_museums</code> as intended, so Option 1 is
correct.</li>
<li><strong>Option 2:</strong> This option is functionally the same as
Option 1, so it is also correct. The only difference between Option 2
and Option 1 is that Option 2 uses the parameter name
<code>art_museums</code> and Option 1 uses the parameter name
<code>df</code> (both in the <code>def</code> line and in the function
body); this does not change the behavior of <code>get_10</code> or the
lines afterward.</li>
<li><strong>Option 3:</strong> <code>get_10</code> here does not return
anything! So, <code>get_10(art_museums)</code> evaluates to
<code>None</code> (which means “nothing” in Python), and
<code>random_art_museums</code> is also <code>None</code>, meaning
Option 3 is incorrect.</li>
<li><strong>Option 4:</strong> At first, it may appear that this option
is wrong, as <code>get_10</code> does not take in any inputs. However,
the body of <code>get_10</code> contains a reference to the DataFrame
<code>art_museums</code>, which is ultimately where we want to sample
from. As a result, <code>get_10</code> does indeed return an array
containing 10 randomly selected museum names, and
<code>random_art_museums = get_10()</code> correctly assigns
<code>random_art_museums</code> to this array, so Option 4 is
correct.</li>
<li><strong>Option 5:</strong> Here, <code>get_10</code> returns the
correct array. However, outside of the function,
<code>random_art_museums</code> is never assigned to the output of
<code>get_10</code>. (The variable name <code>random_art_museums</code>
inside the function has nothing to do with the array defined before and
outside the function.) As a result, after running the line
<code>get_10()</code> at the bottom of the code block,
<code>random_art_museums</code> is still an empty array, and as such,
Option 5 is incorrect.</li>
</ul>
<hr/>
<h5>Difficulty: ⭐️⭐️</h5>
<p>
</p>
<p>The average score on this problem was 85%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<h3 id="problem-1.2">Problem 1.2</h3>
<p>London has the most art museums in the top 100 of any city in the
world. The most visited art museum in London is
<code>'Tate Modern'</code>.</p>
<p>Which of the following blocks of code correctly assigns
<code>best_in_london</code> to <code>'Tate Modern'</code>? Select all
that apply.</p>
<p>Option 1:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> most_common(df, col):</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> df.groupby(col).count().sort_values(by<span class="op">=</span><span class="st">&#39;Rank&#39;</span>, ascending<span class="op">=</span><span class="va">False</span>).index[<span class="dv">0</span>]</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> most_visited(df, col, value):</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> df[df.get(col)<span class="op">==</span>value].sort_values(by<span class="op">=</span><span class="st">&#39;Visitors&#39;</span>, ascending<span class="op">=</span><span class="va">False</span>).get(<span class="st">&#39;Name&#39;</span>).iloc[<span class="dv">0</span>]</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>best_in_london <span class="op">=</span> most_visited(art_museums, <span class="st">&#39;City&#39;</span>, most_common(art_museums, <span class="st">&#39;City&#39;</span>))</span></code></pre></div>
<p>Option 2:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> most_common(df, col):</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(df.groupby(col).count().sort_values(by<span class="op">=</span><span class="st">&#39;Rank&#39;</span>, ascending<span class="op">=</span><span class="va">False</span>).index[<span class="dv">0</span>])</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> most_visited(df, col, value):</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(df[df.get(col)<span class="op">==</span>value].sort_values(by<span class="op">=</span><span class="st">&#39;Visitors&#39;</span>, ascending<span class="op">=</span><span class="va">False</span>).get(<span class="st">&#39;Name&#39;</span>).iloc[<span class="dv">0</span>])</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>best_in_london <span class="op">=</span> most_visited(art_museums, <span class="st">&#39;City&#39;</span>, most_common(art_museums, <span class="st">&#39;City&#39;</span>))</span></code></pre></div>
<p>Option 3:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> most_common(df, col):</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> df.groupby(col).count().sort_values(by<span class="op">=</span><span class="st">&#39;Rank&#39;</span>, ascending<span class="op">=</span><span class="va">False</span>).index[<span class="dv">0</span>]</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> most_visited(df, col, value):</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(df[df.get(col)<span class="op">==</span>value].sort_values(by<span class="op">=</span><span class="st">&#39;Visitors&#39;</span>, ascending<span class="op">=</span><span class="va">False</span>).get(<span class="st">&#39;Name&#39;</span>).iloc[<span class="dv">0</span>])</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>best_in_london <span class="op">=</span> most_visited(art_museums, <span class="st">&#39;City&#39;</span>, most_common(art_museums, <span class="st">&#39;City&#39;</span>))</span></code></pre></div>
<ul class="task-list">
<li><p><input type="checkbox" disabled="" /> Option 1</p></li>
<li><p><input type="checkbox" disabled="" /> Option 2</p></li>
<li><p><input type="checkbox" disabled="" /> Option 3</p></li>
<li><p><input type="checkbox" disabled="" /> None of the above</p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading1_2">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse1_2" aria-expanded="true" aria-controls="collapse1_2">
Click to view the solution.
</button>
</h2>
<div id="collapse1_2" class="accordion-collapse collapse"
aria-labelledby="heading1_2" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer:</strong> Option 1 only</p>
<p>At a glance, it may seem like there’s a lot of reading to do to
answer the question. However, it turns out that all 3 options follow
similar logic; the difference is in their use of <code>print</code> and
<code>return</code> statements. Whenever we want to “save” the output of
a function to a variable name or use it in another function, we need to
<code>return</code> somewhere within our function. Only Option 1
contains a <code>return</code> statement in both
<code>most_common</code> and <code>most_visited</code>, so it is the
only correct option.</p>
<p>Let’s walk through the logic of Option 1 (which we don’t necessarily
need to do to answer the problem, but we should in order to enhance our
understanding):</p>
<ul>
<li>First, we use <code>most_common</code> to find the city with the
most art museums. <code>most_common</code> does this by grouping the
input DataFrame <code>df</code> (<code>art_museums</code>, in this case)
by <code>'City'</code> and using the <code>.count()</code> method to
find the number of rows per <code>'City'</code>. Note that when using
<code>.count()</code>, all columns in the aggregated DataFrame will
contain the same information, so it doesn’t matter which column you use
to extract the counts per group. After sorting by one of these columns
(<code>'Rank'</code>, in this case) in decreasing order,
<code>most_common</code> takes the first value in the
<code>index</code>, which will be the name of the <code>'City'</code>
with the most art museums. <strong>This is London</strong>,
i.e. <code>most_common(art_museums, 'City')</code> evaluates to
<code>'London'</code> in Option 1 (in Option 2, it evaluates to
<code>None</code>, since <code>most_common</code> there doesn’t
<code>return</code> anything).</li>
<li>Then, we use <code>most_visited</code> to find the museum with the
most visitors in the city with the most museums. This is achieved by
keeping only the rows of the input DataFrame <code>df</code> (again,
<code>art_museums</code> in this case) where the value in the
<code>col</code> (<code>'City'</code>) column is <code>value</code>
(<code>most_common(art_museums, 'City')</code>, or
<code>'London'</code>). Now that we only have information for museums in
London, we can sort by <code>'Visitors'</code> to find the most visited
such museum, and take the first value from the resulting
<code>'Name'</code> column. While all 3 options follow this logic, only
Option 1 <strong>returns</strong> the desired value, and so only Option
1 assigns <code>best_in_london</code> correctly. (Even if Option 2’s
<code>most_visited</code> used <code>return</code> instead of
<code>print</code>, it still wouldn’t work, since Option 2’s
<code>most_common</code> also uses <code>print</code> instead of
<code>return</code>).</li>
</ul>
<hr/>
<h5>Difficulty: ⭐️⭐️</h5>
<p>
</p>
<p>The average score on this problem was 86%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<hr />
<p class="meta"><em>Source:</em> fa23-final — Q8</p>
<h2 id="problem-2">Problem 2</h2>
<p>Since <code>txn</code> has 140,000 rows, Jack wants to get a quick
glimpse at the data by looking at a simple random sample of 10 rows from
<code>txn</code>. He defines the DataFrame <code>ten_txns</code> as
follows:</p>
<pre><code>    ten_txns = txn.sample(10, replace=False)</code></pre>
<p>Which of the following code blocks also assign <code>ten_txns</code>
to a simple random sample of 10 rows from <code>txn</code>?</p>
<p>Option 1:</p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode py"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>    all_rows <span class="op">=</span> np.arange(txn.shape[<span class="dv">0</span>])</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>    perm <span class="op">=</span> np.random.permutation(all_rows)</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>    positions <span class="op">=</span> np.random.choice(perm, size<span class="op">=</span><span class="dv">10</span>, replace<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>    ten_txn <span class="op">=</span> txn.take(positions)</span></code></pre></div>
<p>Option 2:</p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode py"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>    all_rows <span class="op">=</span> np.arange(txn.shape[<span class="dv">0</span>])</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>    choice <span class="op">=</span> np.random.choice(all_rows, size<span class="op">=</span><span class="dv">10</span>, replace<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>    positions <span class="op">=</span> np.random.permutation(choice)</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>    ten_txn <span class="op">=</span> txn.take(positions)</span></code></pre></div>
<p>Option 3:</p>
<div class="sourceCode" id="cb12"><pre
class="sourceCode py"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>    all_rows <span class="op">=</span> np.arange(txn.shape[<span class="dv">0</span>])</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>    positions <span class="op">=</span> np.random.permutation(all_rows).take(np.arange(<span class="dv">10</span>))</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>    ten_txn <span class="op">=</span> txn.take(positions)</span></code></pre></div>
<p>Option 4:</p>
<div class="sourceCode" id="cb13"><pre
class="sourceCode py"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>    all_rows <span class="op">=</span> np.arange(txn.shape[<span class="dv">0</span>])</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>    positions <span class="op">=</span> np.random.permutation(all_rows.take(np.arange(<span class="dv">10</span>)))</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>    ten_txn <span class="op">=</span> txn.take(positions)</span></code></pre></div>
<p><strong>Select all that apply.</strong></p>
<ul class="task-list">
<li><p><input type="checkbox" disabled="" /> Option 1</p></li>
<li><p><input type="checkbox" disabled="" /> Option 2</p></li>
<li><p><input type="checkbox" disabled="" /> Option 3</p></li>
<li><p><input type="checkbox" disabled="" /> Option 4</p></li>
<li><p><input type="checkbox" disabled="" /> None of the above.</p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading2">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse2" aria-expanded="true" aria-controls="collapse2">
Click to view the solution.
</button>
</h2>
<div id="collapse2" class="accordion-collapse collapse"
aria-labelledby="heading2" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer:</strong> Option 1, Option 2, and Option 3.</p>
<p>Let’s consider each option.</p>
<ul>
<li><p>Option 1: First, <code>all_rows</code> is defined as an array
containing the integer positions of all the rows in the DataFrame. Then,
we randomly shuffle the elements in this array and store it in the array
<code>permutations</code>. Finally, we select 10 integers randomly
(without replacement), and use <code>.take()</code> to select the rows
from the DataFrame with the corresponding integer locations. In other
words, we are randomly selecting ten row numbers and taking those
randomly selected. This gives a simple random sample of 10 rows from the
DataFrame txn, so option 1 is correct.</p></li>
<li><p>Option 2: Option 2 is similar to option 1, except that the order
of the <code>np.random.choice</code> and the
<code>np.random.permutation</code> operations are switched. This doesn’t
affect the output, since the choice we made was, by definition, random.
Therefore, it doesn’t matter if we shuffle the rows before or after (or
not at all), since the most this will do is change the order of a sample
which was already randomly selected. So, option 2 is correct.</p></li>
<li><p>Option 3: Here, we randomly shuffle the elements of
<code>all_rows</code>, and then we select the first 10 elements with
<code>np.take</code>. Since the shuffling of elements from
<code>all_rows</code> was random, we don’t know which elements are in
the first 10 positions of this new shuffled array (in other words, the
first 10 elements are random). So, when we select the rows from
<code>txn</code> which have the corresponding integer locations in the
next step, we’ve simply selected 10 rows with random integer locations.
Therefore, this is a valid random sample from <code>txn</code>, and
option 3 is correct.</p></li>
<li><p>Option 4: The difference between this option and option 3 is the
order in which <code>np.random.permutation</code> and
<code>np.take</code> are executed. Here, we select the first 10 elements
before the permutation (inside the parentheses). As a result, the array
which we’re shuffling with <code>np.random.permutation</code> does not
include all the integer locations like <code>all_rows</code> does, it’s
simply the first ten elements. Therefore, this code produces a random
shuffling of the first 10 rows of <code>txn</code>, which is not a
random sample.</p></li>
</ul>
<hr/>
<h5>Difficulty: ⭐️⭐️</h5>
<p>
</p>
<p>The average score on this problem was 82%.</p>
</div>
</div>
</div>
</div>
<hr />
<h2 id="problem-3">Problem 3</h2>
<p>We want to use <code>app_data</code> to estimate the average amount
of time it takes to build an IKEA bed (any product in the
<code>'bed'</code> category). Which of the following strategies would be
an appropriate way to estimate this quantity? Select all that apply.</p>
<ul class="task-list">
<li><p><input type="checkbox" disabled="" /> Query to keep only the beds. Then resample with replacement many
times. For each resample, take the mean of the <code>'minutes'</code>
column. Compute a 95% confidence interval based on those means.</p></li>
<li><p><input type="checkbox" disabled="" /> Query to keep only the beds. Group by <code>'product'</code> using
the mean aggregation function. Then resample with replacement many
times. For each resample, take the mean of the <code>'minutes'</code>
column. Compute a 95% confidence interval based on those means.</p></li>
<li><p><input type="checkbox" disabled="" /> Resample with replacement many times. For each resample, first query
to keep only the beds and then take the mean of the
<code>'minutes'</code> column. Compute a 95% confidence interval based
on those means.</p></li>
<li><p><input type="checkbox" disabled="" /> Resample with replacement many times. For each resample, first query
to keep only the beds. Then group by <code>'product'</code> using the
mean aggregation function, and finally take the mean of the
<code>'minutes'</code> column. Compute a 95% confidence interval based
on those means.</p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading3">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse3" aria-expanded="true" aria-controls="collapse3">
Click to view the solution.
</button>
</h2>
<div id="collapse3" class="accordion-collapse collapse"
aria-labelledby="heading3" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer: </strong> Option 1</p>
<p>Only the first answer is correct. This is a question of parameter
estimation, so our approach is to use bootstrapping to create many
resamples of our original sample, computing the average of each
resample. Each resample should always be the same size as the original
sample. The first answer choice accomplishes this by querying first to
keep only the beds, then resampling from the DataFrame of beds only.
This means resamples will have the same size as the original sample.
Each resample’s mean will be computed, so we will have many resample
means from which to construct our 95% confidence interval.</p>
<p>In the second answer choice, we are actually taking the mean twice.
We first average the build times for all builds of the same product when
grouping by product. This produces a DataFrame of different products
with the average build time for each. We then resample from this
DataFrame, computing the average of each resample. But this is a
resample of products, not of product builds. The size of the resample is
the number of unique products in <code>app_data</code>, not the number
of reported product builds in <code>app_data</code>. Further, we get
incorrect results by averaging numbers that are already averages. For
example, if 5 people build bed A and it takes them each 1 hour, and 1
person builds bed B and it takes them 10 hours, the average amount of
time to build a bed is <span class="math inline">\frac{5*1+10}{6} =
2.5</span>. But if we average the times for bed A (1 hour) and average
the times for bed B (5 hours), then average those, we get <span class="math inline">\frac{1+5}{2} = 3</span>, which is not the same.
More generally, grouping is not a part of the bootstrapping process
because we want each data value to be weighted equally.</p>
<p>The last two answer choices are incorrect because they involve
resampling from the full <code>app_data</code> DataFrame before querying
to keep only the beds. This is incorrect because it does not preserve
the sample size. For example, if <code>app_data</code> contains 1000
reported bed builds and 4000 other product builds, then the only
relevant data is the 1000 bed build times, so when we resample, we want
to consider another set of 1000 beds. If we resample from the full
<code>app_data</code> DataFrame, our resample will contain 5000 rows,
but the number of beds will be random, not necessarily 1000. If we query
first to keep only the beds, then resample, our resample will contain
exactly 1000 beds every time. As an added bonus, since we only care
about beds, it’s much faster to resample from a smaller DataFrame of
beds only than it is to resample from all <code>app_data</code> with
plenty of rows we don’t care about.</p>
<hr/>
<h5>Difficulty: ⭐️⭐️⭐️</h5>
<p>
</p>
<p>The average score on this problem was 71%.</p>
</div>
</div>
</div>
</div>
<hr />
<h2 id="problem-4">Problem 4</h2>
<p>Shivani wrote a function called <code>doggos</code> defined as
follows:</p>
<div class="sourceCode" id="cb14"><pre
class="sourceCode py"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> doggos(n, lower, upper):</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>    t <span class="op">=</span> df.sample(n, replace<span class="op">=</span><span class="va">True</span>).get(<span class="st">&#39;longevity&#39;</span>)</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">sum</span>(lower <span class="op">&lt;=</span> t <span class="op">&lt;</span> upper)</span></code></pre></div>
<p>This plot shows a density histogram of the <code>'longevity'</code>
column.</p>
<center><img src='../../assets/images/su22-final/q5_hist.png' width=50%></center>
<p>Answer each of these questions by either writing a <strong>single
number</strong> in the box or selecting “Not enough information”, but
<strong>not both</strong>. What is the probability that:</p>
<p><br></p>
<h3 id="problem-4.1">Problem 4.1</h3>
<p><code>doggos(1, 10, 11) == 1</code> is <code>True</code>?</p>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading4_1">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse4_1" aria-expanded="true" aria-controls="collapse4_1">
Click to view the solution.
</button>
</h2>
<div id="collapse4_1" class="accordion-collapse collapse"
aria-labelledby="heading4_1" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer: </strong> 0.15</p>
<p>Let’s first understand the function. The function takes inputs
<code>n</code>, <code>lower</code>, and <code>upper</code> and randomly
takes a sample of <code>n</code> rows with replacement from DataFrame
<code>df</code>, gets column <code>longevity</code> from the sample and
saves it as a Series <code>t</code>. The <code>n</code> entries of
<code>t</code> are randomly generated according to the density histogram
shown in the picture. That is, the probability of a particular value
being generated in Series <code>t</code> for a given entry can be
visualized by the density histogram in the picture.
<code>lower &lt;= t &lt; upper</code> takes <code>t</code> and generates
a Series of boolean values, either <code>True</code> or
<code>False</code> depending on whether the corresponding entry in
<code>t</code> lies within the range. And so
<code>sum(lower &lt;= t &lt; upper)</code> returns the number of entries
in <code>t</code> that lies between the range values. (This is because
<code>True</code> has a value of 1 and <code>False</code> has a value of
0, so summing Booleans is a quick way to count how many
<code>True</code> there are.)</p>
<p>Now part a is just asking for the probability that we’ll draw a
<code>longevity</code> value (given that <code>n</code> is
<code>1</code>, so we only draw one <code>longevity</code> value)
between 10 and 11 given the density plot. Note that the probability of a
bar is given by the width of the bar multiplied by the height. Now
looking at the bar with bin of range 10 to 11, we can see that the
probability is just <span class="math inline">(11-10) * 0.15 = 1 * 0.15
= 0.15</span>.</p>
<hr/>
<h5>Difficulty: ⭐️⭐️</h5>
<p>
</p>
<p>The average score on this problem was 86%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<h3 id="problem-4.2">Problem 4.2</h3>
<p><code>doggos(2, 0, 12) == 2</code> is <code>True</code>?</p>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading4_2">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse4_2" aria-expanded="true" aria-controls="collapse4_2">
Click to view the solution.
</button>
</h2>
<div id="collapse4_2" class="accordion-collapse collapse"
aria-labelledby="heading4_2" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer: </strong> 0.36</p>
<p>Part b is essentially asking us: What is the probability that after
drawing two <code>longevity</code> values according to the density plot,
both of them will lie in between 0 and 12?</p>
<p>Let’s first start by considering the probability of drawing 1
<code>longevity</code> value that lies between <code>0</code> and
<code>12</code>. This is simply just the sum of the areas of the three
bars of range 6-10, 10-11, and 11-12, which is just <span class="math inline">(4*0.05) + (1*0.15) + (1*0.25) = 0.6</span></p>
<p>Now because we draw each value independently from one another, we
simply square this probability which gives us an answer of <span class="math inline">0.6*0.6 = 0.36</span></p>
<hr/>
<h5>Difficulty: ⭐️⭐️</h5>
<p>
</p>
<p>The average score on this problem was 81%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<h3 id="problem-4.3">Problem 4.3</h3>
<p><code>doggos(2, 13, 20) &gt; 0</code> is <code>True</code>?</p>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading4_3">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse4_3" aria-expanded="true" aria-controls="collapse4_3">
Click to view the solution.
</button>
</h2>
<div id="collapse4_3" class="accordion-collapse collapse"
aria-labelledby="heading4_3" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer: </strong> 0.19</p>
<p>Part c is essentially asking us: What is the probability that after
drawing two <code>longevity</code> values according to the density plot,
at least one of them will lie in between 12 and 20?</p>
<p>While you can directly solve for this probability, a faster method
would be to solve for the complementary of this problem. That is, we can
solve for the probability that <strong>none</strong> of them lie in
between the given ranges. And once we solve this, we can simply subtract
our answer from one, because the only options for this scenario is that
either at least one of the values lie in between the range, or neither
of the values do.</p>
<p>Again, let’s solve for the probability of drawing 1
<code>longevity</code> value that isn’t between the range. Staying true
to our complementary strategy, this is just 1 minus the probability of
drawing a <code>longevity</code> value that <strong>is</strong> in the
range, which is just <span class="math inline">1 - (1*0.05+1*0.05) =
0.9</span></p>
<p>Again, because we draw each value independently, squaring this
probability gives us the probability that neither of our drawn values
are in the range, or <span class="math inline">0.9*0.9 = 0.81</span>.
Finally, subtracting this from 1 gives us our desired answer or <span class="math inline">1 - 0.81 =0.19</span></p>
<hr/>
<h5>Difficulty: ⭐️⭐️⭐️</h5>
<p>
</p>
<p>The average score on this problem was 66%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<hr />
<h2 id="problem-5">Problem 5</h2>
<p>You sample from a population by assigning each element of the
population a number starting with 1. You include element 1 in your
sample. Then you generate a random number, <code>n</code>, between 2 and
5, inclusive, and you take every <code>n</code>th element after element
1 to be in your sample. For example, if you select <code>n=2</code>,
then your sample will be elements <code>1, 3, 5, 7</code>, and so
on.</p>
<p><br></p>
<h3 id="problem-5.1">Problem 5.1</h3>
<p><strong>True or False</strong>: Before the sample is drawn, you can
calculate the probability of selecting each subset of the
population.</p>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading5_1">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse5_1" aria-expanded="true" aria-controls="collapse5_1">
Click to view the solution.
</button>
</h2>
<div id="collapse5_1" class="accordion-collapse collapse"
aria-labelledby="heading5_1" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer: </strong> True</p>
<p>The answer is true since someone can easily sketch each sample to
view the probability of selecting a certain subset. For example, when n
= 2 we know the elements are 1, 3, 5, 7, and so on. Similarly we know
this information for n = 3, 4 and 5. Using this information we could
calculate the probability of selecting a subset.</p>
<hr/>
<h5>Difficulty: ⭐️</h5>
<p>
</p>
<p>The average score on this problem was 97%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<h3 id="problem-5.2">Problem 5.2</h3>
<p><strong>True or False</strong>: Each subset of the population is
equally likely to be selected.</p>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading5_2">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse5_2" aria-expanded="true" aria-controls="collapse5_2">
Click to view the solution.
</button>
</h2>
<div id="collapse5_2" class="accordion-collapse collapse"
aria-labelledby="heading5_2" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer: </strong> False</p>
<p>No, each subset of the population is not equally likely to be
selected since the element assigned as element 1 will always be selected
due to the way sampling is conducted as defined in the question. That
is, the question says we always include element one in the sample which
will over represent it in samples as compared to other parts of the
population.</p>
<hr/>
<h5>Difficulty: ⭐️⭐️⭐️⭐️</h5>
<p>
</p>
<p>The average score on this problem was 46%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<hr />
<h2 id="problem-6">Problem 6</h2>
<p>Assume <code>df</code> is a DataFrame with distinct rows. Which of
the following best describes <code>df.sample(10)</code>?</p>
<ul class="task-list">
<li><p><input type="radio" disabled="" /> an array of length 10, where some of the entries might be the
same</p></li>
<li><p><input type="radio" disabled="" /> an array of length 10, where no two entries can be the same</p></li>
<li><p><input type="radio" disabled="" /> a DataFrame with 10 rows, where some of the rows might be the
same</p></li>
<li><p><input type="radio" disabled="" /> a DataFrame with 10 rows, where no two rows can be the same</p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading6">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse6" aria-expanded="true" aria-controls="collapse6">
Click to view the solution.
</button>
</h2>
<div id="collapse6" class="accordion-collapse collapse"
aria-labelledby="heading6" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer: </strong> a DataFrame with 10 rows, where no two rows
can be the same</p>
<p>Looking at the documentation for <code>.sample()</code> we can see
that it accepts a few arguments. The first argument specifies the number
of rows (which is why we specify 10). The next argument is a boolean
that specifies if the sampling happens with or without replacement. By
default, the sampling will occur without replacement (which happens in
this question since no argument is specified so the default is evoked).
Looking at the return, we can see that since we are sampling a
dataframe, a dataframe will also be returned which is why a DataFrame
with 10 rows, where no two rows can be the same is correct.</p>
<hr/>
<h5>Difficulty: ⭐️</h5>
<p>
</p>
<p>The average score on this problem was 94%.</p>
</div>
</div>
</div>
</div>
<hr />
<h2 id="problem-7">Problem 7</h2>
<p>Describe in your own words the difference between a probability
distribution and an empirical distribution. Give an example of what each
distribution might look like for a certain experiment. Choose an
experiment that we have not already seen in this class.</p>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading7">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse7" aria-expanded="true" aria-controls="collapse7">
Click to view the solution.
</button>
</h2>
<div id="collapse7" class="accordion-collapse collapse"
aria-labelledby="heading7" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer: </strong> There are many possible correct answers.
Below are some student responses that earned full credit, lightly edited
for clarity.</p>
<hr/>
<p><i>Probability distributions are theoretical distributions
distributed over all possible values of an experiment. Meanwhile,
empirical distributions are distributions of the real observed data. An
example of this would be choosing a certain suit from a deck of cards.
The probability distribution would be uniform, with a 1/4 chance of
choosing each suit. Meanwhile, the empirical distribution of choosing
suits from a deck of cards in 50 pulls manually and graphing the
observed data would show us different chances. </i></p>
<hr/>
<p><i>A probability distribution is the distribution describing the
theoretical probability of each potential value occurring in an
experiment, while the empirical distribution describes the proportion of
each of the values in the experiment after running it, including all
observed values. In other words, the probability distribution is what we
expect to happen, and the empirical distribution is what actually
happens.</i></p>
<p><i>For example: My friends and I often go to a food court to eat, and
we randomly pick a restaurant every time. There is 1 McDonald’s, 1
Subway, and 2 Panda Express restaurants in the food court.</i></p>
<p><i>The probability distribution is as follows:</i></p>
<ul>
<li>P(McDonald’s) = 0.25</li>
<li>P(Subway) = 0.25</li>
<li>P(Panda Express) = 0.5</li>
</ul>
<p><i>After going to the food court 100 times, we look at the empirical
distribution to see which restaurants we eat at most often. it is as
follows:</i></p>
<ul>
<li>(McDonald’s) = 0.21</li>
<li>(Subway) = 0.22</li>
<li>(Panda Express) = 0.57</li>
</ul>
<hr/>
<p><i>Probability distribution is a theoretical representation of
certain outcomes in an event whereas an empirical distribution is the
observational representation of the same outcomes in an event produced
from an experiment.</i></p>
<p><i>An example would be if I had 10 pairs of shoes in my closet: The
probability distribution would suggest that each pair of shoes has an
equal chance of getting picked on any given day. On the other hand, an
empirical distribution would be drawn by recording which pair got picked
on a given day in N trials. </i></p>
<hr/>
<h5>Difficulty: ⭐️⭐️</h5>
<p>
</p>
<p>The average score on this problem was 82%.</p>
</div>
</div>
</div>
</div>
<hr />
<h2 id="problem-8">Problem 8</h2>
<div class="sourceCode" id="cb15"><pre
class="sourceCode py"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>results <span class="op">=</span> np.array([])</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> np.arange(<span class="dv">10</span>):</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>    result <span class="op">=</span> np.random.choice(np.arange(<span class="dv">1000</span>), replace<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>    results <span class="op">=</span> np.append(results, result)</span></code></pre></div>
<p>After this code executes, <code>results</code> contains:</p>
<ul class="task-list">
<li><p><input type="radio" disabled="" /> a simple random sample of size 9, chosen from a set of size 999 with
replacement</p></li>
<li><p><input type="radio" disabled="" /> a simple random sample of size 9, chosen from a set of size 999
without replacement</p></li>
<li><p><input type="radio" disabled="" /> a simple random sample of size 10, chosen from a set of size 1000
with replacement</p></li>
<li><p><input type="radio" disabled="" /> a simple random sample of size 10, chosen from a set of size 1000
without replacement</p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading8">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse8" aria-expanded="true" aria-controls="collapse8">
Click to view the solution.
</button>
</h2>
<div id="collapse8" class="accordion-collapse collapse"
aria-labelledby="heading8" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer: </strong> a simple random sample of size 10, chosen
from a set of size 1000 with replacement</p>
<p>Let’s see what the code is doing. The first line initializes an empty
array called <code>results</code>. The for loop runs 10 times. Each
time, it creates a value called <code>result</code> by some process
we’ll inspect shortly and appends this value to the end of the
<code>results</code> array. At the end of the code snippet,
<code>results</code> will be an array containing 10 elements.</p>
<p>Now, let’s look at the process by which each element
<code>result</code> is generated. Each <code>result</code> is a random
element chosen from <code>np.arange(1000)</code> which is the numbers
from 0 to 999, inclusive. That’s 1000 possible numbers. Each time
<code>np.random.choice</code> is called, just one value is chosen from
this set of 1000 possible numbers.</p>
<p>When we sample just one element from a set of values, sampling with
replacement is the same as sampling without replacement, because
sampling with or without replacement concerns whether subsequent draws
can be the same as previous ones. When we’re just sampling one element,
it really doesn’t matter whether our process involves putting that
element back, as we’re not going to draw again!</p>
<p>Therefore, <code>result</code> is just one random number chosen from
the 1000 possible numbers. Each time the <code>for</code> loop executes,
<code>result</code> gets set to a random number chosen from the 1000
possible numbers. It is possible (though unlikely) that the random
<code>result</code> of the first execution of the loop matches the
<code>result</code> of the second execution of the loop. More generally,
there can be repeated values in the <code>results</code> array since
each entry of this array is independently drawn from the same set of
possibilities. Since repetitions are possible, this means the sample is
drawn with replacement.</p>
<p>Therefore, the <code>results</code> array contains a sample of size
10 chosen from a set of size 1000 with replacement. This is called a
“simple random sample” because each possible sample of 10 values is
equally likely, which comes from the fact that
<code>np.random.choice</code> chooses each possible value with equal
probability by default.</p>
<hr/>
<h5>Difficulty: ⭐️⭐️⭐️⭐️⭐️</h5>
<p>
</p>
<p>The average score on this problem was 11%.</p>
</div>
</div>
</div>
</div>
<hr />
<h2 id="problem-9">Problem 9</h2>
<p>Suppose we take a uniform random sample with replacement from a
population, and use the sample mean as an estimate for the population
mean. Which of the following is correct?</p>
<ul class="task-list">
<li><p><input type="radio" disabled="" /> If we take a larger sample, our sample mean will be closer to the
population mean.</p></li>
<li><p><input type="radio" disabled="" /> If we take a smaller sample, our sample mean will be closer to the
population mean.</p></li>
<li><p><input type="radio" disabled="" /> If we take a larger sample, our sample mean is more likely to be
close to the population mean than if we take a smaller sample.</p></li>
<li><p><input type="radio" disabled="" /> If we take a smaller sample, our sample mean is more likely to be
close to the population mean than if we take a larger sample.</p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading9">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse9" aria-expanded="true" aria-controls="collapse9">
Click to view the solution.
</button>
</h2>
<div id="collapse9" class="accordion-collapse collapse"
aria-labelledby="heading9" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer: </strong> If we take a larger sample, our sample mean
is more likely to be close to the population mean than if we take a
smaller sample.</p>
<p>Larger samples tend to give better estimates of the population mean
than smaller samples. That’s because large samples are more like the
population than small samples. We can see this in the extreme. Imagine a
sample of 1 element from a population. The sample might vary a lot,
depending on the distribution of the population. On the other extreme,
if we sample the whole population, our sample mean will be exactly the
same as the population mean.</p>
<p>Notice that the correct answer choice uses the words “is more likely
to be close to” as opposed to “will be closer to.” We’re talking about a
general phenomenon here: larger samples tend to give better estimates of
the population mean than smaller samples. We cannot say that if we take
a larger sample our sample mean “will be closer to” the population mean,
since it’s always possible to get lucky with a small sample and unlucky
with a large sample. That is, one particular small sample may happen to
have a mean very close to the population mean, and one particular large
sample may happen to have a mean that’s not so close to the population
mean. This <em>can</em> happen, it’s just not likely to.</p>
<hr/>
<h5>Difficulty: ⭐️</h5>
<p>
</p>
<p>The average score on this problem was 100%.</p>
</div>
</div>
</div>
</div>
<hr />
<p class="meta"><em>Source:</em> wi23-final — Q5</p>
<h2 id="problem-10">Problem 10</h2>
<p>As in the previous question, let <code>coop_sample</code> be a sample
of 100 rows of games, all corresponding to cooperative games.</p>
<p>Define <code>samp</code> and <code>resamp</code> as follows.</p>
<div class="sourceCode" id="cb16"><pre
class="sourceCode py"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>samp <span class="op">=</span> coop_sample.get(<span class="st">&quot;Complexity&quot;</span>)</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>resamp <span class="op">=</span> coop_sample.sample(<span class="dv">100</span>, replace<span class="op">=</span><span class="va">True</span>).get(<span class="st">&quot;Complexity&quot;</span>)</span></code></pre></div>
<p><br></p>
<h3 id="problem-10.1">Problem 10.1</h3>
<p>Which of the following statements <strong>could</strong> evaluate to
True? Select all that are possible.</p>
<ul class="task-list">
<li><p><input type="checkbox" disabled="" /> <code>len(samp.unique()) &lt; len(resamp.unique())</code></p></li>
<li><p><input type="checkbox" disabled="" /> <code>len(samp.unique()) == len(resamp.unique())</code></p></li>
<li><p><input type="checkbox" disabled="" /> <code>len(samp.unique()) &gt; len(resamp.unique())</code></p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading10_1">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse10_1" aria-expanded="true" aria-controls="collapse10_1">
Click to view the solution.
</button>
</h2>
<div id="collapse10_1" class="accordion-collapse collapse"
aria-labelledby="heading10_1" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer:</strong> Options 2 and 3</p>
<p><strong>Option 2:</strong> This is correct because it is possible for
<code>resamp</code> to be shuffled in such a way that the number of
unique elements are not the same.</p>
<p><strong>Option 3:</strong> This is correct because it is possible for
<code>resamp</code> to pull the same values more often making it less
unique than <code>samp</code>.</p>
<p><strong>Option 1:</strong> The reason that this is incorrect is
because <code>samp.unique()</code> has the most possible unique elements
inside of it. When we shuffle it using
<code>coop_sample.sample(100, replace = True)</code> we could pull the
same value multiple times, making it less unique.</p>
<hr/>
<h5>Difficulty: ⭐️</h5>
<p>
</p>
<p>The average score on this problem was 91%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<h3 id="problem-10.2">Problem 10.2</h3>
<p>Which of the following statements <strong>could</strong> evaluate to
True? Select all that are possible.</p>
<ul class="task-list">
<li><p><input type="checkbox" disabled="" /> <code>np.count nonzero(samp == 1) &lt; np.count nonzero(resamp == 1)</code></p></li>
<li><p><input type="checkbox" disabled="" /> <code>np.count nonzero(samp == 1) == np.count nonzero(resamp == 1)</code></p></li>
<li><p><input type="checkbox" disabled="" /> <code>np.count nonzero(samp == 1) &gt; np.count nonzero(resamp == 1)</code></p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading10_2">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse10_2" aria-expanded="true" aria-controls="collapse10_2">
Click to view the solution.
</button>
</h2>
<div id="collapse10_2" class="accordion-collapse collapse"
aria-labelledby="heading10_2" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer:</strong> Options 1, 2, and 3</p>
<p><strong>Option 1:</strong> It might be helpful to recall what exactly
the column <code>“Complexity”</code> holds. In this case it holds the
average complexity of the game on a scale of 1 to 5. The code is trying
to find if the number of ones in <code>samp</code> and
<code>resamp</code> are different. It is possible that when shuffling
due to <code>replace = True</code> that <code>resamp</code> has more
ones inside of it than <code>samp</code>.</p>
<p><strong>Option 2:</strong> Once again it is possible that when
shuffled <code>resamp</code> has the same number of ones as
<code>samp</code> does.</p>
<p><strong>Option 3:</strong> When we shuffle <code>coop_sample</code>
there is no guarantee that one will sample more ones and instead other
averages could be selected. This means it is possible for the number of
ones in <code>samp</code> can be greater than the number of ones in
<code>resamp</code>.</p>
<hr/>
<h5>Difficulty: ⭐️⭐️</h5>
<p>
</p>
<p>The average score on this problem was 83%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<h3 id="problem-10.3">Problem 10.3</h3>
<p>Which of the following statements <strong>could</strong> evaluate to
True? Select all that are possible.</p>
<ul class="task-list">
<li><p><input type="checkbox" disabled="" /> <code>samp.min() &lt; resamp.min()</code></p></li>
<li><p><input type="checkbox" disabled="" /> <code>samp.min() == resamp.min()</code></p></li>
<li><p><input type="checkbox" disabled="" /> <code>samp.min() &gt; resamp.min()</code></p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading10_3">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse10_3" aria-expanded="true" aria-controls="collapse10_3">
Click to view the solution.
</button>
</h2>
<div id="collapse10_3" class="accordion-collapse collapse"
aria-labelledby="heading10_3" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer:</strong> Options 1 and 2</p>
<p><strong>Option 1:</strong> It is possible when shuffled that
<code>samp</code>’s original minimum is never sampled, making
<code>resamp</code>’s minimum to be greater than <code>samp</code>’s
min.</p>
<p><strong>Option 2:</strong>: If <code>samp</code>’s original min is
sampled then it will be the same minimum that appears inside of
<code>resamp</code>.</p>
<p><strong>Option 3:</strong> It is impossible for <code>resamp</code>’s
minimum to be less than <code>samp</code>’s minimum. This is because all
of <code>resamp</code>’s values come from <code>samp</code>. That means
there cannot be a smaller average inside of <code>resamp</code> that
never appears in <code>samp</code>.</p>
<hr/>
<h5>Difficulty: ⭐️⭐️</h5>
<p>
</p>
<p>The average score on this problem was 83%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<h3 id="problem-10.4">Problem 10.4</h3>
<p>Which of the following statements <strong>could</strong> evaluate to
True? Select all that are possible.</p>
<ul class="task-list">
<li><p><input type="checkbox" disabled="" /> <code>np.std(samp) &lt; np.std(resamp)</code></p></li>
<li><p><input type="checkbox" disabled="" /> <code>np.std(samp) == np.std(resamp)</code></p></li>
<li><p><input type="checkbox" disabled="" /> <code>np.std(samp) &gt; np.std(resamp)</code></p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading10_4">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse10_4" aria-expanded="true" aria-controls="collapse10_4">
Click to view the solution.
</button>
</h2>
<div id="collapse10_4" class="accordion-collapse collapse"
aria-labelledby="heading10_4" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer:</strong> Options 1, 2, and 3</p>
<p><strong>Option 1:</strong> <code>np.std()</code> gives us the
standard deviation of the array we give it. When we do
<code>np.std(samp)</code> we are finding the standard deviation of
<code>“Complexity”</code>. When we do <code>np.std(resamp)</code> we are
finding the standard deviation of <code>“Complexity”</code>, which may
grab values multiple times. Since we are grabbing values multiple times
it is possible to have a standard deviation become smaller if we
continuously grab smaller values.</p>
<p><strong>Option 2:</strong> If the <code>resamp</code> gets us the
same values as <code>samp</code> we would end up with the same standard
deviation, which would make
<code>np.std(samp) == np.std(resamp)</code>.</p>
<p><strong>Option 3:</strong> Similar to Option 1, we may grab many
values which are on the larger end, which could increase our standard
deviation.</p>
<hr/>
<h5>Difficulty: ⭐️⭐️</h5>
<p>
</p>
<p>The average score on this problem was 79%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<hr />
<p class="meta"><em>Source:</em> wi23-final — Q14</p>
<h2 id="problem-11">Problem 11</h2>
<p>Suppose the function <code>simulate_lcr</code> from the last question
has been correctly implemented, and we want to use it to see how many
turns a game of <em>Left, Center, Right</em> usually takes.</p>
<p><strong>Note:</strong> You can answer this question even if you
couldn’t answer the previous one.</p>
<p>Consider the code and histogram below.</p>
<div class="sourceCode" id="cb17"><pre
class="sourceCode py"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>turns <span class="op">=</span> np.array([])</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> np.arange(<span class="dv">10000</span>):</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>    turns <span class="op">=</span> np.append(turns, simulate_lcr())</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>(bpd.DataFrame().assign(turns<span class="op">=</span>turns).plot(kind<span class="op">=</span><span class="st">&quot;hist&quot;</span>, density <span class="op">=</span> <span class="va">True</span>, ec<span class="op">=</span><span class="st">&quot;w&quot;</span>, bins <span class="op">=</span> np.arange(<span class="dv">0</span>, <span class="dv">66</span>, <span class="dv">6</span>)))</span></code></pre></div>
<center><img src='../../assets/images/wi23-final/hist.jpg' width=40%></center>
<p><br></p>
<h3 id="problem-11.1">Problem 11.1</h3>
<p>Does this histogram show a probability distribution or an empirical
distribution?</p>
<ul class="task-list">
<li><p><input type="radio" disabled="" /> Probability Distribution</p></li>
<li><p><input type="radio" disabled="" /> Empirical Distribution</p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading11_1">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse11_1" aria-expanded="true" aria-controls="collapse11_1">
Click to view the solution.
</button>
</h2>
<div id="collapse11_1" class="accordion-collapse collapse"
aria-labelledby="heading11_1" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer:</strong> Empirical Distribution</p>
<p>An empirical distribution is derived from observed data, in this
case, the results of 10,000 simulated games of Left, Center, Right. It
represents the frequencies of outcomes (number of turns taken in each
game) as observed in these simulations.</p>
<hr/>
<h5>Difficulty: ⭐️⭐️⭐️</h5>
<p>
</p>
<p>The average score on this problem was 54%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<h3 id="problem-11.2">Problem 11.2</h3>
<p>What is the probability of a game of <em>Left, Center, Right</em>
lasting 30 turns or more? Choose the closest answer below.</p>
<ul class="task-list">
<li><p><input type="radio" disabled="" /> 0.01</p></li>
<li><p><input type="radio" disabled="" /> 0.06</p></li>
<li><p><input type="radio" disabled="" /> 0.10</p></li>
<li><p><input type="radio" disabled="" /> 0.60</p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading11_2">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse11_2" aria-expanded="true" aria-controls="collapse11_2">
Click to view the solution.
</button>
</h2>
<div id="collapse11_2" class="accordion-collapse collapse"
aria-labelledby="heading11_2" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer:</strong> 0.06</p>
<p>We’re being asked to find the proportion of values in the histogram
that are greater than or equal to 30, which is equal to the area of the
histogram to the right of 30. Immediately, we can rule out 0.01 and
0.60, because the area to the right of 30 is more than 1% of the total
area and less than 60% of the total area.</p>
<p>The problem then boils down to determining whether the area to the
right of 30 is 0.06 or 0.10. While you could solve this by finding the
areas of the three bars individually and adding them together, there’s a
quicker solution. Notice that the <span class="math inline">x</span>-axis gridlines – the vertical lines in the
background in white – appear every 10 units (at <span class="math inline">x = 0</span>, <span class="math inline">x =
10</span>, <span class="math inline">x = 20</span>, <span class="math inline">x = 30</span>, and so on) and the <span class="math inline">y</span>-axis gridlines – the horizontal lines in
the background in white – appear every 0.01 units (at <span class="math inline">y = 0</span>, <span class="math inline">y =
0.01</span>, <span class="math inline">y = 0.02</span>, and so on).
There’s a “box” in the grid between <span class="math inline">x =
30</span> and <span class="math inline">x = 40</span>, and between <span class="math inline">y = 0</span> and <span class="math inline">y =
0.01</span>. The area of that box is <span class="math inline">(40 - 30)
\cdot 0.01 = 0.1</span>, which means that if a bar book up the entire
box, then 10% of the values in this distribution would fall into that
bar’s bin.</p>
<p>So, to decide whether the area to the right of 30 is closer to 0.06
or 0.1, we can estimate whether the three bars to the right of 30 would
fill up the entire box described above (that is, the box from 30 to 40
on the <span class="math inline">x</span>-axis and 0 to 0.1 on the <span class="math inline">y</span>-axis), or whether it would be much emptier.
Visually, if you broke off the area that is to the right of 40 in the
histogram and put it in the box we’ve just described, then quite a bit
of the box would still be empty. As such, the area to the right of 30 is
less than the area of the box, so it’s less than 0.1, and so the only
valid option is 0.06.</p>
<hr/>
<h5>Difficulty: ⭐️⭐️⭐️</h5>
<p>
</p>
<p>The average score on this problem was 50%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<h3 id="problem-11.3">Problem 11.3</h3>
<p>Suppose a player with <span class="math inline">n</span> chips takes
their turn. What is the probability that they will have to put at least
one chip into the center? Give your answer as a mathematical expression
involving <span class="math inline">n</span>.</p>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading11_3">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse11_3" aria-expanded="true" aria-controls="collapse11_3">
Click to view the solution.
</button>
</h2>
<div id="collapse11_3" class="accordion-collapse collapse"
aria-labelledby="heading11_3" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer:</strong> <span class="math inline">1 -
(\frac{5}{6})^n</span></p>
<p>Recall that the die used to play this game has six sides: L, C, R,
Dot, Dot, Dot. The chance of getting C is <span class="math inline">\frac{1}{6}</span>. So we can take the compliment of
that to get <span class="math inline">\frac{5}{6}</span>, which is the
probability of not putting at least one chip into the center and then
doing (<span class="math inline">\frac{5}{6}</span>)^n. Once again we
must use the complement rule as to convert it back to the probability of
putting at least one chip into the center. This gives us the answer:
<span class="math inline">1 - (\frac{5}{6})</span>^n</p>
<hr/>
<h5>Difficulty: ⭐️⭐️⭐️</h5>
<p>
</p>
<p>The average score on this problem was 56%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<h3 id="problem-11.4">Problem 11.4</h3>
<p>Suppose a player with <span class="math inline">n</span> chips takes
their turn. What is the probability that they will end their turn with
<span class="math inline">n</span> chips? Give your answer as a
mathematical expression involving <span
class="math inline">n</span>.</p>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading11_4">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse11_4" aria-expanded="true" aria-controls="collapse11_4">
Click to view the solution.
</button>
</h2>
<div id="collapse11_4" class="accordion-collapse collapse"
aria-labelledby="heading11_4" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer:</strong> <span class="math inline">\left( \frac{1}{2}
\right)^n</span></p>
<p>Recall, when it is a player’s turn, they roll one die for each of the
<span class="math inline">n</span> chips they have. The die that they
roll has six faces. In three of those faces (L, C, and R), they end up
losing a chip, and in the other three of those faces (dot, dot, and
dot), they keep the chip. So, for each chip, there is a <span class="math inline">\frac{3}{6} = \frac{1}{2}</span> chance that they
get to keep it after the turn. Since each die roll is independent, there
is a <span class="math inline">\frac{1}{2} \cdot \frac{1}{2} \cdot ...
\cdot \frac{1}{2} = \left( \frac{1}{2} \right)^n</span> chance that they
get to keep all <span class="math inline">n</span> chips. (Note that
there is no way to earn more chips during a turn, so that’s not
something we need to consider.)</p>
<hr/>
<h5>Difficulty: ⭐️⭐️⭐️</h5>
<p>
</p>
<p>The average score on this problem was 69%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<hr />
</body>
</html>
