<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Discussion 4: Functions, Subgroups, Merge, and Control Flow</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="../assets/theme.css" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
   var mathElements = document.getElementsByClassName("math");
   var macros = [];
   for (var i = 0; i < mathElements.length; i++) {
    var texText = mathElements[i].firstChild;
    if (mathElements[i].tagName == "SPAN") {
     katex.render(texText.data, mathElements[i], {
      displayMode: mathElements[i].classList.contains('display'),
      throwOnError: false,
      macros: macros,
      fleqn: false
     });
  }}});
  </script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">Discussion 4: Functions, Subgroups, Merge, and Control Flow</h1>
</header>
<p><link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-EVSTQN3/azprG1Anm3QDgpJLIm9Nao0Yz1ztcQTwFspd3yD65VohhpuuCOmLASjC" crossorigin="anonymous"> <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/js/bootstrap.bundle.min.js" integrity="sha384-MrcW6ZMFYlzcLA8Nl+NtUVF0sA7MsXsP1UyJoMp4YLEuNSfAP+JcXn/tWtIaxVXM" crossorigin="anonymous"></script> <!-- add after bootstrap.min.css --> <link rel="stylesheet" href="https://cdn.rawgit.com/afeld/bootstrap-toc/v1.0.1/dist/bootstrap-toc.min.css"/> <!-- add after bootstrap.min.js or bootstrap.bundle.min.js --> <script src="https://cdn.rawgit.com/afeld/bootstrap-toc/v1.0.1/dist/bootstrap-toc.min.js"></script></p>
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-B947E6J6H4"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-B947E6J6H4');
</script>
<p><a href="../index.html">← return to practice.dsc10.com</a></p>
<hr />
<p>The problems in this worksheet are taken from past exams. Work on them <strong>on paper</strong>, since the exams you take in this course will also be on paper. <br><br>We encourage you to complete this worksheet in a discussion section, which is held live on Monday, October 17th. Solutions will be made available after all discussion sections have concluded. You don’t need to submit your answers anywhere.</p>
<hr />
<h2 id="problem-1">Problem 1</h2>
<p><center><img src='../assets/images/sp22-midterm/cartoon.png' width=20%></center></p>
<p>Included is a DataFrame named <code>sungod</code> that contains information on the artists who have performed at Sun God in years past. <strong>For each year that the festival was held, we have one row for each artist that performed that year.</strong> The columns are:</p>
<ul>
<li><code>'Year'</code> (<code>int</code>): the year of the festival</li>
<li><code>'Artist'</code> (<code>str</code>): the name of the artist</li>
<li><code>'Appearance_Order'</code> (<code>int</code>): the order in which the artist appeared in that year’s festival (1 means they came onstage first)</li>
</ul>
<p>The rows of <code>sungod</code> are arranged in <strong>no particular order</strong>. The first few rows of <code>sungod</code> are shown below (though <code>sungod</code> has <strong>many more rows</strong> than pictured here).</p>
<center><img src='../assets/images/sp22-midterm/sungod.png' width=30%></center>
<p>Assume:</p>
<ul>
<li><p>Only one artist ever appeared at a time (for example, we can’t have two separate artists with a <code>'Year'</code> of 2015 and an <code>'Appearance_Order'</code> of 3).</p></li>
<li><p>An artist may appear in multiple different Sun God festivals (they could be invited back).</p></li>
<li><p>We have already run <code>import babypandas as bpd</code> and <code>import numpy as np</code>. <br><br></p></li>
</ul>
<p>Fill in the blank in the code below so that <code>chronological</code> is a DataFrame with the same rows as <code>sungod</code>, but ordered chronologically by appearance on stage. That is, earlier years should come before later years, and within a single year, artists should appear in the DataFrame in the order they appeared on stage at Sun God. Note that <code>groupby</code> automatically sorts the index in ascending order.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>chronological <span class="op">=</span> sungod.groupby(___________).<span class="bu">max</span>().reset_index()</span></code></pre></div>
<ul class="task-list">
<li><p><input type="radio" disabled="" /> <code>['Year', 'Artist', 'Appearance_Order']</code></p></li>
<li><p><input type="radio" disabled="" /> <code>['Year', 'Appearance_Order']</code></p></li>
<li><p><input type="radio" disabled="" /> <code>['Appearance_Order', 'Year']</code></p></li>
<li><p><input type="radio" disabled="" /> None of the above.</p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading1">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse1" aria-expanded="true" aria-controls="collapse1">
Click to view the solution.
</button>
</h2>
<div id="collapse1" class="accordion-collapse collapse collapse" aria-labelledby="heading1" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer: </strong> <code>['Year', 'Appearance_Order']</code></p>
<p>The fact that <code>groupby</code> automatically sorts the index in ascending order is important here. Since we want earlier years before later years, we could group by <code>'Year'</code>, however if we <em>just</em> group by year, all the artists who performed in a given year will be aggregated together, which is not what we want. Within each year, we want to organize the artists in ascending order of <code>'Appearance_Order'</code>. In other words, we need to group by <code>'Year'</code> with <code>'Appearance_Order'</code> as subgroups. Therefore, the correct way to reorder the rows of <code>sungod</code> as desired is <code>sungod.groupby(['Year', 'Appearance_Order']).max().reset_index()</code>. Note that we need to reset the index so that the resulting DataFrame has <code>'Year'</code> and <code>'Appearance_Order'</code> as columns, like in <code>sungod</code>.</p>
</div>
</div>
</div>
</div>
<hr />
<h2 id="problem-2">Problem 2</h2>
<p>Another DataFrame called <code>music</code> contains a row for every music artist that has ever released a song. The columns are:</p>
<ul>
<li><code>'Name'</code> (<code>str</code>): the name of the music artist</li>
<li><code>'Genre'</code> (<code>str</code>): the primary genre of the artist</li>
<li><code>'Top_Hit'</code> (<code>str</code>): the most popular song by that artist, based on sales, radio play, and streaming</li>
<li><code>'Top_Hit_Year'</code> (<code>int</code>): the year in which the top hit song was released</li>
</ul>
<p>You want to know how many musical genres have been represented at Sun God since its inception in 1983. Which of the following expressions produces a DataFrame called <code>merged</code> that could help determine the answer?</p>
<ul class="task-list">
<li><p><input type="radio" disabled="" /> <code>merged = sungod.merge(music, left_on='Year', right_on='Top_Hit_Year')</code></p></li>
<li><p><input type="radio" disabled="" /> <code>merged = music.merge(sungod, left_on='Year', right_on='Top_Hit_Year')</code></p></li>
<li><p><input type="radio" disabled="" /> <code>merged = sungod.merge(music, left_on='Artist', right_on='Name')</code></p></li>
<li><p><input type="radio" disabled="" /> <code>merged = music.merge(sungod, left_on='Artist', right_on='Name')</code></p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading2">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse2" aria-expanded="true" aria-controls="collapse2">
Click to view the solution.
</button>
</h2>
<div id="collapse2" class="accordion-collapse collapse collapse" aria-labelledby="heading2" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer: </strong> <code>merged = sungod.merge(music, left_on='Artist', right_on='Name')</code></p>
<p>The question we want to answer is about Sun God music artists’ genres. In order to answer, we’ll need a DataFrame consisting of rows of artists that have performed at Sun God since its inception in 1983. If we merge the <code>sungod</code> DataFrame with the <code>music</code> DataFrame based on the artist’s name, we’ll end up with a DataFrame containing one row for each artist that has ever performed at Sun God. Since the column containing artists’ names is called <code>'Artist'</code> in <code>sungod</code> and <code>'Name'</code> in <code>music</code>, the correct syntax for this merge is <code>merged = sungod.merge(music, left_on='Artist', right_on='Name')</code>. Note that we could also interchange the left DataFrame with the right DataFrame, as swapping the roles of the two DataFrames in a merge only changes the ordering of rows and columns in the output, not the data itself. This can be written in code as <code>merged = music.merge(sungod, left_on='Name', right_on='Artist')</code>, but this is not one of the answer choices.</p>
</div>
</div>
</div>
</div>
<hr />
<h2 id="problem-3">Problem 3</h2>
<p>Consider an artist that has only appeared once at Sun God. At the time of their Sun God performance, we’ll call the artist</p>
<ul>
<li><strong>outdated</strong> if their top hit came out more than five years prior,</li>
<li><strong>trending</strong> if their top hit came out within the five years prior, and</li>
<li><strong>up-and-coming</strong> if their top hit came out after they appeared at Sun God.</li>
</ul>
<p>Complete the function below so it outputs the appropriate description for any input artist who has appeared exactly once at Sun God.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> classify_artist(artist):</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    filtered <span class="op">=</span> merged[merged.get(<span class="st">&#39;Artist&#39;</span>) <span class="op">==</span> artist]</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    year <span class="op">=</span> filtered.get(<span class="st">&#39;Year&#39;</span>).iloc[<span class="dv">0</span>]</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    top_hit_year <span class="op">=</span> filtered.get(<span class="st">&#39;Top_Hit_Year&#39;</span>).iloc[<span class="dv">0</span>]</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> ___(a)___ <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="st">&#39;up-and-coming&#39;</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> ___(b)___:</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="st">&#39;outdated&#39;</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="st">&#39;trending&#39;</span></span></code></pre></div>
<p><br></p>
<h3 id="problem-3.1">Problem 3.1</h3>
<p>What goes in blank (a)?</p>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading3_1">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse3_1" aria-expanded="true" aria-controls="collapse3_1">
Click to view the solution.
</button>
</h2>
<div id="collapse3_1" class="accordion-collapse collapse collapse" aria-labelledby="heading3_1" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer: </strong> <code>top_hit_year - year</code></p>
<p>Before we can answer this question, we need to understand what the first three lines of the <code>classify_artist</code> function are doing. The first line creates a DataFrame with only one row, corresponding to the particular artist that’s passed in as input to the function. We know there is just one row because we are told that the artist being passed in as input has appeared exactly once at Sun God. The next two lines create two variables:</p>
<ul>
<li><code>year</code> contains the year in which the artist performed at Sun God, and</li>
<li><code>top_hit_year</code> contains the year in which their top hit song was released.</li>
</ul>
<p>Now, we can fill in blank (a). Notice that the body of the <code>if</code> clause is <code>return 'up-and-coming'</code>. Therefore we need a condition that corresponds to up-and-coming, which we are told means the top hit came out after the artist appeared at Sun God. Using the variables that have been defined for us, this condition is <code>top_hit_year &gt; year</code>. However, the <code>if</code> statement condition is already partially set up with <code>&gt; 0</code> included. We can simply rearrange our condition <code>top_hit_year &gt; year</code> by subtracting <code>year</code> from both sides to obtain <code>top_hit_year - year &gt; 0</code>, which fits the desired format.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<h3 id="problem-3.2">Problem 3.2</h3>
<p>What goes in blank (b)?</p>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading3_2">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse3_2" aria-expanded="true" aria-controls="collapse3_2">
Click to view the solution.
</button>
</h2>
<div id="collapse3_2" class="accordion-collapse collapse collapse" aria-labelledby="heading3_2" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer: </strong> <code>year-top_hit_year &gt; 5</code></p>
<p>For this part, we need a condition that corresponds to an artist being outdated which happens when their top hit came out more than five years prior to their appearance at Sun God. There are several ways to state this condition: <code>year-top_hit_year &gt; 5</code>, <code>year &gt; top_hit_year + 5</code>, or any equivalent condition would be considered correct.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<hr />
<h2 id="problem-4">Problem 4</h2>
<p>King Triton 🔱, UCSD’s mascot, is quite the traveler! For this question, we will be working with the <code>flights</code> DataFrame, which details several facts about each of the flights that King Triton has been on over the past few years. The first few rows of <code>flights</code> are shown below.</p>
<center><img src='../assets/images/fa21-midterm/flights.png' width=40%></center>
<p>Here’s a description of the columns in <code>flights</code>:</p>
<ul>
<li><code>'DATE'</code>: the date on which the flight occurred. Assume that there were no “redeye” flights that spanned multiple days.</li>
<li><code>'FLIGHT'</code>: the flight number. Note that this is not unique; airlines reuse flight numbers on a daily basis.</li>
<li><code>'FROM'</code> and <code>'TO'</code>: the 3-letter airport code for the departure and arrival airports, respectively. Note that it’s not possible to have a flight from and to the same airport.</li>
<li><code>'DIST'</code>: the distance of the flight, in miles.</li>
<li><code>'HOURS'</code>: the length of the flight, in hours.</li>
<li><code>'SEAT'</code>: the kind of seat King Triton sat in on the flight; the only possible values are <code>'WINDOW'</code>, <code>'MIDDLE'</code>, and <code>'AISLE'</code>. <br><br></li>
</ul>
<p>Suppose we create a DataFrame called <code>socal</code> containing only King Triton’s flights departing from SAN, LAX, or SNA (John Wayne Airport in Orange County). <code>socal</code> has 10 rows; the bar chart below shows how many of these 10 flights departed from each airport.</p>
<center><img src='../assets/images/fa21-midterm/socal.png' width=30%></center>
<p>Consider the DataFrame that results from merging <code>socal</code> with itself, as follows:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>double_merge <span class="op">=</span> socal.merge(socal, left_on<span class="op">=</span><span class="st">&#39;FROM&#39;</span>, right_on<span class="op">=</span><span class="st">&#39;FROM&#39;</span>)</span></code></pre></div>
<p>How many rows does <code>double_merge</code> have?</p>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading4">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse4" aria-expanded="true" aria-controls="collapse4">
Click to view the solution.
</button>
</h2>
<div id="collapse4" class="accordion-collapse collapse collapse" aria-labelledby="heading4" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer: </strong> 38</p>
<p>There are two flights from LAX. When we merge <code>socal</code> with itself on the <code>'FROM'</code> column, each of these flights gets paired up with each of these flights, for a total of four rows in the output. That is, the first flight from LAX gets paired with both the first and second flights from LAX. Similarly, the second flight from LAX gets paired with both the first and second flights from LAX.</p>
<p>Following this logic, each of the five flights from SAN gets paired with each of the five flights from SAN, for an additional 25 rows in the output. For SNA, there will be 9 rows in the output. The total is therefore <span class="math inline">2^2 + 5^2 + 3^2 = 4 + 25 + 9 = 38</span> rows.</p>
</div>
</div>
</div>
</div>
<hr />
<h2 id="problem-5">Problem 5</h2>
<p>We define a “route” to be a departure and arrival airport pair. For example, all flights from <code>'SFO'</code> to <code>'SAN'</code> make up the “SFO to SAN route”. This is different from the “SAN to SFO route”.</p>
<p>Fill in the blanks below so that <code>most_frequent.get('FROM').iloc[0]</code> and <code>most_frequent.get('TO').iloc[0]</code> correspond to the departure and destination airports of the route that King Triton has spent the <strong>most time flying on</strong>.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>most_frequent <span class="op">=</span> flights.groupby(__(a)__).__(b)__</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>most_frequent <span class="op">=</span> most_frequent.reset_index().sort_values(__(c)__)</span></code></pre></div>
<p><br></p>
<h3 id="problem-5.1">Problem 5.1</h3>
<p>What goes in blank (a)?</p>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading5_1">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse5_1" aria-expanded="true" aria-controls="collapse5_1">
Click to view the solution.
</button>
</h2>
<div id="collapse5_1" class="accordion-collapse collapse collapse" aria-labelledby="heading5_1" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer: </strong> <code>['FROM', 'TO']</code></p>
<p>We want to organize flights by route. This means we need to group by both <code>'FROM'</code> and <code>'TO'</code> so any flights with the same pair of departure and arrival airports get grouped together. To group by multiple columns, we must use a list containing all these column names, as in <code>flights.groupby(['FROM', 'TO'])</code>.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<h3 id="problem-5.2">Problem 5.2</h3>
<p>What goes in blank (b)?</p>
<ul class="task-list">
<li><p><input type="radio" disabled="" /> <code>count()</code></p></li>
<li><p><input type="radio" disabled="" /> <code>mean()</code></p></li>
<li><p><input type="radio" disabled="" /> <code>sum()</code></p></li>
<li><p><input type="radio" disabled="" /> <code>max()</code></p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading5_2">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse5_2" aria-expanded="true" aria-controls="collapse5_2">
Click to view the solution.
</button>
</h2>
<div id="collapse5_2" class="accordion-collapse collapse collapse" aria-labelledby="heading5_2" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer: </strong> <code>sum()</code></p>
<p>Every <code>.groupby</code> command needs an aggregation function! Since we are asked to find the route that King Triton has spent the most time flying on, we want to total the times for all flights on a given route.</p>
<p>Note that <code>.count()</code> would tell us how many flights King Triton has taken on each route. That’s meaningful information, but not what we need to address the question of which route he spent the most time flying on.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<h3 id="problem-5.3">Problem 5.3</h3>
<p>What goes in blank (c)?</p>
<ul class="task-list">
<li><p><input type="radio" disabled="" /> <code>by='HOURS', ascending=True</code></p></li>
<li><p><input type="radio" disabled="" /> <code>by='HOURS', ascending=False</code></p></li>
<li><p><input type="radio" disabled="" /> <code>by='HOURS', descending=True</code></p></li>
<li><p><input type="radio" disabled="" /> <code>by='DIST', ascending=False</code></p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading5_3">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse5_3" aria-expanded="true" aria-controls="collapse5_3">
Click to view the solution.
</button>
</h2>
<div id="collapse5_3" class="accordion-collapse collapse collapse" aria-labelledby="heading5_3" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer: </strong> <code>by='HOURS', ascending=False</code></p>
<p>We want to know the route that King Triton spent the most time flying on. After we group flights by route, summing flights on the same route, the <code>'HOURS'</code> column contains the total amount of time spent on each route. We need <code>most_frequent.get('FROM').iloc[0]</code> and <code>most_frequent.get('TO').iloc[0]</code> to correspond with the departure and destination airports of the route that King Triton has spent the most time flying on. To do this, we need to sort in descending order of time, to bring the largest time to the top of the DataFrame. So we must sort by <code>'HOURS'</code> with <code>ascending=False</code>.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<hr />
<h2 id="problem-6">Problem 6</h2>
<p>For this question we will use data from the 2021 Women’s National Basketball Association (WNBA) season for the next several problems. In basketball, players score points by shooting the ball into a hoop. The team that scores the most points wins the game.</p>
<p>Kelsey Plum, a WNBA player, attended La Jolla Country Day School, which is adjacent to UCSD’s campus. Her current team is the Las Vegas Aces (three-letter code <code>'LVA'</code>). <strong>In 2021, the Las Vegas Aces played 31 games, and Kelsey Plum played in all 31.</strong></p>
<p>The DataFrame <code>plum</code> contains her stats for all games the Las Vegas Aces played in 2021. The first few rows of <code>plum</code> are shown below (though the full DataFrame has 31 rows, not 5):</p>
<center><img src='../assets/images/wi22-final/plum.png' width=40%></center>
<p>Each row in <code>plum</code> corresponds to a single game. For each game, we have:</p>
<ul>
<li><code>'Date'</code> (<code>str</code>), the date on which the game was played</li>
<li><code>'Opp'</code> (<code>str</code>), the three-letter code of the opponent team</li>
<li><code>'Home'</code> (<code>bool</code>), <code>True</code> if the game was played in Las Vegas (“home”) and <code>False</code> if it was played at the opponent’s arena (“away”)</li>
<li><code>'Won'</code> (<code>bool</code>), <code>True</code> if the Las Vegas Aces won the game and <code>False</code> if they lost</li>
<li><code>'PTS'</code> (<code>int</code>), the number of points Kelsey Plum scored in the game</li>
<li><code>'AST'</code> (<code>int</code>), the number of assists (passes) Kelsey Plum made in the game</li>
<li><code>'TOV'</code> (<code>int</code>), the number of turnovers Kelsey Plum made in the game (a turnover is when you lose the ball – turnovers are bad!) <br><br></li>
</ul>
<p><br></p>
<h3 id="problem-6.1">Problem 6.1</h3>
<p>Consider the function <code>unknown</code>, defined below.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> unknown(df):</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    grouped <span class="op">=</span> plum.groupby(<span class="st">&#39;Opp&#39;</span>).<span class="bu">max</span>().get([<span class="st">&#39;Date&#39;</span>, <span class="st">&#39;PTS&#39;</span>])</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.array(grouped.reset_index().index)[df]</span></code></pre></div>
<p>What does <code>unknown(3)</code> evaluate to?</p>
<ul class="task-list">
<li><p><input type="radio" disabled="" /> <code>'2021-06-05'</code></p></li>
<li><p><input type="radio" disabled="" /> <code>'WAS'</code></p></li>
<li><p><input type="radio" disabled="" /> The date on which Kelsey Plum scored the most points</p></li>
<li><p><input type="radio" disabled="" /> The three-letter code of the opponent on which Kelsey Plum scored the most points</p></li>
<li><p><input type="radio" disabled="" /> The number 0</p></li>
<li><p><input type="radio" disabled="" /> The number 3</p></li>
<li><p><input type="radio" disabled="" /> An error</p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading6_1">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse6_1" aria-expanded="true" aria-controls="collapse6_1">
Click to view the solution.
</button>
</h2>
<div id="collapse6_1" class="accordion-collapse collapse collapse" aria-labelledby="heading6_1" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer:</strong> The number 3</p>
<p><code>plum.groupby('Opp').max()</code> finds the largest value in the <code>'Date'</code>, <code>'Home'</code>, <code>'Won'</code>, <code>'PTS'</code>, <code>'AST'</code>, and <code>'TOV'</code> columns for each unique <code>'Opp'</code> (independently for each column). <code>grouped = plum.groupby('Opp').max().get(['Date', 'PTS'])</code> keeps only the <code>'Date'</code> and <code>'PTS'</code> columns. Note that in <code>grouped</code>, the index is <code>'Opp'</code>, the column we grouped on.</p>
<p>When <code>grouped.reset_index()</code> is called, the index is switched back to the default of 0, 1, 2, 3, 4, and so on. Then, <code>grouped.reset_index().index</code> is an <code>Index</code> containing the numbers <code>[0, 1, 2, 3, 4, ...]</code>, and <code>np.array(grouped.reset_index().index)</code> is <code>np.array([0, 1, 2, 3, 4, ...])</code>. In this array, the number at position <code>i</code> is just <code>i</code>, so the number at position <code>df</code> is <code>df</code>. Here, <code>df</code> is the argument to <code>unknown</code>, and we were asked for the value of <code>unknown(3)</code>, so the correct answer is the number at position 3 in <code>np.array([0, 1, 2, 3, 4, ...])</code> which is 3.</p>
<p>Note that if we asked for <code>unknown(50)</code> (or <code>unknown(k)</code>, where <code>k</code> is any integer above 30), the answer would be “An error”, since <code>grouped</code> could not have had 51 rows. <code>plum</code> has 31 rows, so <code>grouped</code> has at most 31 rows (but likely less, since Kelsey Plum’s team likely played the same opponent multiple times).</p>
</div>
</div>
</div>
</div>
<p><br></p>
<h3 id="problem-6.2">Problem 6.2</h3>
<p>For your convenience, we show the first few rows of <code>plum</code> again below.</p>
<center><img src='../assets/images/wi22-final/plum.png' width=40%></center>
<p>Suppose that Plum’s team, the Las Vegas Aces, won at least one game in Las Vegas and lost at least one game in Las Vegas. Also, suppose they won at least one game in an opponent’s arena and lost at least one game in an opponent’s arena.</p>
<p>Consider the DataFrame <code>home_won</code>, defined below.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>home_won <span class="op">=</span> plum.groupby([<span class="st">&#39;Home&#39;</span>, <span class="st">&#39;Won&#39;</span>]).mean().reset_index()</span></code></pre></div>
<ol type="1">
<li><p>How many rows does <code>home_won</code> have?</p></li>
<li><p>How many columns does <code>home_won</code> have?</p></li>
</ol>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading6_2">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse6_2" aria-expanded="true" aria-controls="collapse6_2">
Click to view the solution.
</button>
</h2>
<div id="collapse6_2" class="accordion-collapse collapse collapse" aria-labelledby="heading6_2" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer:</strong> 4 rows and 5 columns.</p>
<p><code>plum.groupby(['Home', 'Won']).mean()</code> contains one row for every unique combination of <code>'Home'</code> and <code>'Won'</code>. There are two values of <code>'Home'</code> - <code>True</code> and <code>False</code> – and two values of <code>'Won'</code> – <code>True</code> and <code>False</code> – leading to 4 combinations. We can assume that there was at least one row in <code>plum</code> for each of these 4 combinations due to the assumption given in the problem:</p>
<p><em>Suppose that Plum’s team, the Las Vegas Aces, won at least one game in Las Vegas and lost at least one game in Las Vegas. Also, suppose they won at least one game in an opponent’s arena and lost at least one game in an opponent’s arena.</em></p>
<p><code>plum</code> started with 7 columns: <code>'Date'</code>, <code>'Opp'</code>, <code>'Home'</code>, <code>'Won'</code>, <code>'PTS'</code>, <code>'AST'</code>, and <code>'TOV'</code>. After grouping by <code>['Home', 'Won']</code> and using <code>.mean()</code>, <code>'Home'</code> and <code>'Won'</code> become the index. The resulting DataFrame contains all of the columns that the <code>.mean()</code> aggregation method can work on. We cannot take the mean of <code>'Date'</code> and <code>'Opp'</code>, because those columns are strings, so <code>plum.groupby(['Home', 'Won']).mean()</code> contains a <code>MultiIndex</code> with 2 “columns” – <code>'Home'</code> and <code>'Won'</code> – and 3 regular columns – <code>'PTS'</code> <code>'AST'</code>, and <code>'TOV'</code>. Then, when using <code>.reset_index()</code>, <code>'Home'</code> and <code>'Won'</code> are restored as regular columns, meaning that <code>plum.groupby(['Home', 'Won']).mean().reset_index()</code> has <span class="math inline">2 + 3 = 5</span> columns.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<h3 id="problem-6.3">Problem 6.3</h3>
<p>Consider the DataFrame <code>home_won</code> once again.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>home_won <span class="op">=</span> plum.groupby([<span class="st">&#39;Home&#39;</span>, <span class="st">&#39;Won&#39;</span>]).mean().reset_index()</span></code></pre></div>
<p>Now consider the DataFrame <code>puzzle</code>, defined below. Note that the only difference between <code>home_won</code> and <code>puzzle</code> is the use of <code>.count()</code> instead of <code>.mean()</code>.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>puzzle <span class="op">=</span> plum.groupby([<span class="st">&#39;Home&#39;</span>, <span class="st">&#39;Won&#39;</span>]).count().reset_index()</span></code></pre></div>
<p>How do the number of rows and columns in <code>home_won</code> compare to the number of rows and columns in <code>puzzle</code>?</p>
<ul class="task-list">
<li><p><input type="radio" disabled="" /> <code>home_won</code> and <code>puzzle</code> have the same number of rows and columns</p></li>
<li><p><input type="radio" disabled="" /> <code>home_won</code> and <code>puzzle</code> have the same number of rows, but a different number of columns</p></li>
<li><p><input type="radio" disabled="" /> <code>home_won</code> and <code>puzzle</code> have the same number of columns, but a different number of rows</p></li>
<li><p><input type="radio" disabled="" /> <code>home_won</code> and <code>puzzle</code> have both a different number of rows and a different number of columns</p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading6_3">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse6_3" aria-expanded="true" aria-controls="collapse6_3">
Click to view the solution.
</button>
</h2>
<div id="collapse6_3" class="accordion-collapse collapse collapse" aria-labelledby="heading6_3" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer: </strong> <code>home_won</code> and <code>puzzle</code> have the same number of rows, but a different number of columns</p>
<p>All that changed between <code>home_won</code> and <code>puzzle</code> is the aggregation method. The aggregation method has no influence on the number of rows in the output DataFrame, as there is still one row for each of the 4 unique combinations of <code>'Home'</code> and <code>'Won'</code>.</p>
<p>However, <code>puzzle</code> has 7 columns, instead of 5. In the solution to the above subpart, we noticed that we could not use <code>.mean()</code> on the <code>'Date'</code> and <code>'Opp'</code> columns, since they contained strings. However, we can use <code>.count()</code> (since <code>.count()</code> just determines the number of non-NA values in each group), and so the <code>'Date'</code> and <code>'Opp'</code> columns are not “lost” when aggregating. Hence, <code>puzzle</code> has 2 more columns than <code>home_won</code>.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<hr />
<h2 id="section"><span class="math display"> </span></h2>
<h4 id="feedback-find-an-error-still-confused-have-a-suggestion-let-us-know-here.">👋 Feedback: Find an error? Still confused? Have a suggestion? <a href="https://forms.gle/WZ71FchnXU1K154d7">Let us know here</u></a>.</h4>
<hr />
</body>
</html>
