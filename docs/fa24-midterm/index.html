<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Fall 2024 Midterm Exam</title>
  <style>
    /* Default styles provided by pandoc.
    ** See https://pandoc.org/MANUAL.html#variables-for-html for config info.
    */
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    /* CSS for syntax highlighting */
    html { -webkit-text-size-adjust: 100%; }
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { color: #008000; } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { color: #008000; font-weight: bold; } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="../assets/theme.css" />
  <script defer=""
  src="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <link rel="stylesheet"
  href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css" />
</head>
<body>
<header id="title-block-header">
<h1 class="title">Fall 2024 Midterm Exam</h1>
</header>
<p><link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-EVSTQN3/azprG1Anm3QDgpJLIm9Nao0Yz1ztcQTwFspd3yD65VohhpuuCOmLASjC" crossorigin="anonymous">
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/js/bootstrap.bundle.min.js" integrity="sha384-MrcW6ZMFYlzcLA8Nl+NtUVF0sA7MsXsP1UyJoMp4YLEuNSfAP+JcXn/tWtIaxVXM" crossorigin="anonymous"></script>
<!-- add after bootstrap.min.css -->
<link rel="stylesheet" href="https://cdn.rawgit.com/afeld/bootstrap-toc/v1.0.1/dist/bootstrap-toc.min.css"/>
<!-- add after bootstrap.min.js or bootstrap.bundle.min.js -->
<script src="https://cdn.rawgit.com/afeld/bootstrap-toc/v1.0.1/dist/bootstrap-toc.min.js"></script></p>
<!-- for difficulty gauges-->
<script src="https://cdn.plot.ly/plotly-2.16.1.min.js"></script>
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-B947E6J6H4"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-B947E6J6H4');
</script>
<p><a href="../index.html">← return to practice.dsc10.com</a></p>
<hr />
<p><strong>Instructor(s):</strong> Janine Tiefenbruck</p>
<p>This exam was administered in-person. The exam was closed-notes,
except students were allowed to bring their own double-sided cheat
sheet. No calculators were allowed. Students had <strong>50
minutes</strong> to take this exam.</p>
<hr />
<p>Trick-or-treating is a Halloween tradition, where children wear
costumes and walk around their neighborhood from house to house to
collect candy. In this exam, you’ll work with a data set representing
the candy given out on Halloween. Each row represents one type of candy
given out by one house in San Diego.</p>
<p>The columns of <code>treat</code> are as follows:</p>
<ul>
<li><code>"address"</code> (<code>str</code>): The address of the house
giving out candy.</li>
<li><code>"candy"</code> (<code>str</code>): The type of candy that is
being given out.</li>
<li><code>"how_many"</code> (<code>int</code>): How many pieces of candy
are being given out.</li>
<li><code>"neighborhood"</code> (<code>str</code>): The neighborhood
that the house is in.</li>
</ul>
<p>The first few rows of <code>treat</code> are shown below, though
<code>treat</code> has many more rows than pictured.</p>
<center><img src="../../assets/images/fa24-midterm/preview.jpg" width=600></center>
<p><br></p>
<p>Throughout this exam, we will refer to <code>treat</code> repeatedly.
Assume that we have already run <code>import babypandas as bpd</code>
and <code>import numpy as np</code>.</p>
<hr />
<h2 id="problem-1">Problem 1</h2>
<div class="meta">
<p><span class="pill pill-lecture" title="Lecture number(s)">Lecture
4</span></div></p>
<p>Which of the following columns would be an appropriate index for the
<code>treat</code> DataFrame?</p>
<ul class="task-list">
<li><p><input type="radio" disabled="" /> <code>"address"</code></p></li>
<li><p><input type="radio" disabled="" /> <code>"candy"</code></p></li>
<li><p><input type="radio" disabled="" /> <code>"neighborhood"</code></p></li>
<li><p><input type="radio" disabled="" /> None of these.</p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading1">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse1" aria-expanded="true" aria-controls="collapse1">
Click to view the solution.
</button>
</h2>
<div id="collapse1" class="accordion-collapse collapse"
aria-labelledby="heading1" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer</strong>: None of these.</p>
<p>The index uniquely identifies each row of a DataFrame. As a result,
for a column to be a candidate for the index, it must not contain repeat
items. Since it is possible for an address to give out different types
of candy, values in <code>"address"</code> can show up multiple times.
Similarly, values in <code>"candy"</code> can also show up multiple
times as it will appear anytime a house gives it out. Finally, a
neighborhood has multiple houses, so if more than one of those houses
show up, that value in <code>"neighborhood"</code> will appear multiple
times. Since <code>"address"</code>, <code>"candy"</code>, and
<code>"neighborhood"</code> can potentially have repeat values, none of
them can be the index for <code>treat</code>.</p>
<hr/>
<h5>Difficulty: ⭐️⭐️⭐️</h5>
<p>
</p>
<p>The average score on this problem was 54%.</p>
</div>
</div>
</div>
</div>
<hr />
<h2 id="problem-2">Problem 2</h2>
<div class="meta">
<p><span class="pill pill-lecture" title="Lecture number(s)">Lecture
4</span></div></p>
<p>Which of the following expressions evaluate to
<code>"M&amp;M"</code>? Select all that apply.</p>
<ul class="task-list">
<li><p><input type="checkbox" disabled="" /> <code>treat.get("candy").iloc[1]</code></p></li>
<li><p><input type="checkbox" disabled="" /> <code>treat.sort_values(by="candy", ascending = False).get("candy").iloc[1]</code></p></li>
<li><p><input type="checkbox" disabled="" /> <code>treat.sort_values(by="candy", ascending = False).get("candy").loc[1]</code></p></li>
<li><p><input type="checkbox" disabled="" /> <code>treat.set_index("candy").index[-1]</code></p></li>
<li><p><input type="checkbox" disabled="" /> None of these.</p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading2">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse2" aria-expanded="true" aria-controls="collapse2">
Click to view the solution.
</button>
</h2>
<div id="collapse2" class="accordion-collapse collapse"
aria-labelledby="heading2" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer</strong>: <code>treat.get("candy").iloc[1]</code> and
<code>treat.sort_values(by="candy", ascending = False).get("candy").loc[1]</code></p>
<ul>
<li><p><strong>Option 1</strong>:
<code>treat.get("candy").iloc[1]</code> gets the <code>candy</code>
column and then retrieves the value at index location <code>1</code>,
which would be <code>"M&amp;M"</code>.</p></li>
<li><p><strong>Option 2</strong>:
<code>treat.sort_values(by="candy", ascending=False).get("candy").iloc[1]</code>
sorts the <code>candy</code> column in descending order (alphabetically,
the last candy is at the top) and then retrieves the value at index
location <code>1</code> in the <code>candy</code> column. The entire
dataset is not shown, but in the given rows, the second-to-last candy
alphabetically is <code>"Skittles"</code>, so we know that
<code>"M&amp;M"</code> will not be the second-to-last alphabetical candy
in the full dataset.</p></li>
<li><p><strong>Option 3</strong>:
<code>treat.sort_values(by="candy", ascending=False).get("candy").loc[1]</code>
is very similar to the last option; however, this time,
<code>.loc[1]</code> is used instead of <code>.iloc[1]</code>. This
means that instead of looking at the row in position <code>1</code>
(second row) of the sorted DataFrame, we are finding the row with an
index label of <code>1</code>. When the rows are sorted by
<code>candy</code> in descending order, the index labels remain with
their original rows, so the <code>"M&amp;M"</code> row is retrieved when
we search for the index label <code>1</code>.</p></li>
<li><p><strong>Option 4</strong>:
<code>treat.set_index("candy").index[-1]</code> sets the index to the
<code>candy</code> column and then retrieves the last element in the
index (<code>candy</code>). The entire dataset is not shown, but in the
given rows, the last value would be <code>"Skittles"</code> and not
<code>"M&amp;M"</code>. The last value of the full dataset could be
<code>"M&amp;M"</code>, but since we are not sure, this option is not
selected.</p></li>
</ul>
<hr/>
<h5>Difficulty: ⭐️⭐️⭐️</h5>
<p>
</p>
<p>The average score on this problem was 66%.</p>
</div>
</div>
</div>
</div>
<hr />
<h2 id="problem-3">Problem 3</h2>
<div class="meta">
<p><span class="pill pill-lecture" title="Lecture number(s)">Lecture
12</span></div></p>
<p>Consider the code below.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>street <span class="op">=</span> treats.get(<span class="st">&quot;address&quot;</span>).<span class="bu">str</span>.contains(<span class="st">&quot;Street&quot;</span>)</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>sour <span class="op">=</span> treats.get(<span class="st">&quot;candy&quot;</span>).<span class="bu">str</span>.contains(<span class="st">&quot;Sour&quot;</span>)</span></code></pre></div>
<p><br></p>
<h3 id="problem-3.1">Problem 3.1</h3>
<p>What is the data type of <code>street</code>?</p>
<ul class="task-list">
<li><p><input type="radio" disabled="" /> <code>int</code></p></li>
<li><p><input type="radio" disabled="" /> <code>bool</code></p></li>
<li><p><input type="radio" disabled="" /> <code>str</code></p></li>
<li><p><input type="radio" disabled="" /> Series</p></li>
<li><p><input type="radio" disabled="" /> DataFrame</p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading3_1">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse3_1" aria-expanded="true" aria-controls="collapse3_1">
Click to view the solution.
</button>
</h2>
<div id="collapse3_1" class="accordion-collapse collapse"
aria-labelledby="heading3_1" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer</strong>: Series</p>
<p>.str.contains works in a series and returns a series of booleans.
Each entry is <code>True</code> if it contains a certain string or
<code>False</code> otherwise. So the answer is <code>street</code> has
the Series data type. </p>
<hr/>
<h5>Difficulty: ⭐️⭐️</h5>
<p>The average score
on this problem was 75%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<h3 id="problem-3.2">Problem 3.2</h3>
<p>What does the following expression evaluate to? Write your answer
<strong>exactly</strong> how the output would appear in Python.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>np.count_nonzero(street <span class="op">&amp;</span> sour) <span class="op">&gt;</span> sour.<span class="bu">sum</span>()</span></code></pre></div>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading3_2">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse3_2" aria-expanded="true" aria-controls="collapse3_2">
Click to view the solution.
</button>
</h2>
<div id="collapse3_2" class="accordion-collapse collapse"
aria-labelledby="heading3_2" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer</strong>: <code>False</code></p>
<p><code>np.count_nonzero(street &amp; sour)</code> counts the number of
rows that contains the word “Street” in the <code>address</code> column
AND also contains the word “Sour” in <code>candy</code>.
<code>sour.sum()</code> sums up all the trues and falses, effectively
making it a count of rows that contain the word “Sour” in
<code>candy</code>. Even if we don’t know the full dataframe, we should
be able to figure out that the number of rows that satisfy the condition
of both <code>Street</code> AND <code>Sour</code> should be lower than
or equal to the number of rows that satisfy <code>Sour</code> by itself.
Therefore, it’s impossible for
<code>np.count_nonzero(street &amp; sour) &gt; sour.sum()</code> to be
<code>True</code> so the answer is <code>False</code>.</p>
<hr/>
<h5>Difficulty: ⭐️⭐️⭐️</h5>
<p>
</p>
<p>The average score on this problem was 59%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<hr />
<h2 id="problem-4">Problem 4</h2>
<div class="meta">
<p><span class="pill pill-lecture" title="Lecture number(s)">Lecture
8</span></div></p>
<p>The <code>"address"</code> column contains quite a bit of
information. All houses are in <code>"San Diego, CA"</code>, but the
street address and the zip code vary. Note that the “street address"
includes both the house number and street name, such as
<code>"820 Opal Street"</code>. All addresses are formatted in the same
way, for example,
<code>"820 Opal Street, San Diego, CA, 92109"</code>.</p>
<p><br></p>
<h3 id="problem-4.1">Problem 4.1</h3>
<p>Fill in the blanks in the function <code>address_part</code> below.
The function has two inputs: a value in the index of <code>treat</code>
and a string <code>part</code>, which is either <code>"street"</code> or
<code>"zip"</code>. The function should return the appropriate part of
the address at the given index value, as a string. Example behavior is
given below.</p>
<pre><code>&gt;&gt;&gt; address_part(4, &quot;street&quot;)
&quot;8575 Jade Coast Drive&quot;

&gt;&gt;&gt; address_part(1, &quot;zip&quot;)
&quot;92109&quot;</code></pre>
<p>The function already has a return statement included. You should not
add the word <code>return</code> anywhere else!</p>
<pre><code>def address_part(index_value, part):
    if part == &quot;street&quot;:
        var = 0
    else:
        ___(a)___
    return treat.get(&quot;address&quot;).loc[___(b)___].___(c)___</code></pre>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading4_1">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse4_1" aria-expanded="true" aria-controls="collapse4_1">
Click to view the solution.
</button>
</h2>
<div id="collapse4_1" class="accordion-collapse collapse"
aria-labelledby="heading4_1" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer</strong>:</p>
<ul>
<li><p>(a): <code>var = 3</code>, <code>var = -1</code> or alternate
solution <code>var = 1</code></p></li>
<li><p>(b): <code>index_value</code></p></li>
<li><p>(c): <code>split(", ")[var]</code> or alternate solution
<code>split(", San Diego, CA, ")[var]</code></p></li>
</ul>
<hr/>
<h5>Difficulty: ⭐️⭐️⭐️</h5>
<p>
</p>
<p>The average score on this problem was 58%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<h3 id="problem-4.2">Problem 4.2</h3>
<p>Suppose we had a different function called <code>zip_as_int</code>
that took as input a single address, formatted exactly as the addresses
in <code>treat</code>, and returned the zip code as an <code>int</code>.
Write a Python expression using the <code>zip_as_int</code> function
that evaluates to a Series with the zip codes of all the addresses in
<code>treat</code>.</p>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading4_2">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse4_2" aria-expanded="true" aria-controls="collapse4_2">
Click to view the solution.
</button>
</h2>
<div id="collapse4_2" class="accordion-collapse collapse"
aria-labelledby="heading4_2" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer</strong>:
<code>treat.get("address").apply(zip_as_int)</code></p>
<hr/>
<h5>Difficulty: ⭐️⭐️</h5>
<p>
</p>
<p>The average score on this problem was 76%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<hr />
<h2 id="problem-5">Problem 5</h2>
<div class="meta">
<p><span class="pill pill-lecture" title="Lecture number(s)">Lecture
5</span></div></p>
<p>Write a Python expression that evaluates to the address of the house
with the most pieces of candy available (the most
<strong>pieces</strong>, not the most varieties).</p>
<p>It’s okay if you need to write on multiple lines, but your code
should represent a single expression in Python.</p>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading5">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse5" aria-expanded="true" aria-controls="collapse5">
Click to view the solution.
</button>
</h2>
<div id="collapse5" class="accordion-collapse collapse"
aria-labelledby="heading5" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer</strong>:
<code>treat.groupby("address").sum().sort_values(by="how_many", ascending = False).index[0]</code>
or
<code>treat.groupby("addresss").sum().sort_values(by="how_many").index[-1]</code></p>
<p>In the <code>treat</code> DataFrame, there are multiple rows for each
address, one for each candy they are giving out with their quantity.
Since we want the address with the most pieces of candy available, we
need to combine this information, so we start by grouping by address:
<code>treat.groupby(“address”)</code>. Now, since we want to add the
number of candy available per address, we use the <code>sum()</code>
aggregate function. So now we have a DataFrame with one row per address
where there value in each column is the sum of all the values. To get
the address with the most pieces of candy available, we can simply sort
by the <code>“how_many”</code> column since this stores the total amount
of candy per house. Setting <code>ascending=False</code> means that the
address with the greatest amount of candy will be the first row. Since
the addresses are located in the index as a result of the
<code>groupby</code>, we can access this value by using
<code>index[0]</code>.</p>
<p>Note: If you do not set <code>ascending=False</code>, then the
address with the most amount of candy available will be the last row
which you can access by <code>index[-1]</code>.</p>
<hr/>
<h5>Difficulty: ⭐️⭐️⭐️</h5>
<p>
</p>
<p>The average score on this problem was 67%.</p>
</div>
</div>
</div>
</div>
<hr />
<h2 id="problem-6">Problem 6</h2>
<div class="meta">
<p><span class="pill pill-lecture" title="Lecture number(s)">Lecture
11</span></div></p>
<p>Suppose you visit a house that has 40 Twix, 50 M&amp;Ms, and 10
KitKats in a bowl. You take three pieces of candy from this bowl.</p>
<p><br></p>
<h3 id="problem-6.1">Problem 6.1</h3>
<p>What is the probability you get all Twix?</p>
<ul class="task-list">
<li><p><input type="radio" disabled="" /> <span class="math inline">\dfrac{40}{100} \cdot \dfrac{39}{100} \cdot
\dfrac{38}{100}</span></p></li>
<li><p><input type="radio" disabled="" /> <span class="math inline">\dfrac{40}{100} \cdot \dfrac{40}{99} \cdot
\dfrac{40}{98}</span></p></li>
<li><p><input type="radio" disabled="" /> <span class="math inline">\dfrac{40}{100} \cdot \dfrac{40}{100} \cdot
\dfrac{40}{100}</span></p></li>
<li><p><input type="radio" disabled="" /> <span class="math inline">\dfrac{40}{100} \cdot \dfrac{39}{99} \cdot
\dfrac{38}{98}</span></p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading6_1">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse6_1" aria-expanded="true" aria-controls="collapse6_1">
Click to view the solution.
</button>
</h2>
<div id="collapse6_1" class="accordion-collapse collapse"
aria-labelledby="heading6_1" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer</strong>: <span class="math inline">\dfrac{40}{100}
\cdot \dfrac{39}{99} \cdot \dfrac{38}{98}</span></p>
<p>We need to find the probability that we get all Twix among the three
candies selected from the bowl. Since we are selecting three times from
the same bowl, we know that we are selecting <strong>without
replacement</strong>.</p>
<ol type="1">
<li><strong>First Selection:</strong>
<ul>
<li>There are 40 Twix and 40 + 50 + 10 = 100 candies in the bowl,
meaning the probability of selecting a Twix is <span class="math inline">\frac{40}{100}</span>.</li>
</ul></li>
<li><strong>Second Selection:</strong>
<ul>
<li>Now that we have chosen one Twix there are 39 Twix and 99 candies
left, meaning that the probability of selecting a Twix now is <span class="math inline">\frac{39}{99}</span>.</li>
</ul></li>
<li><strong>Third Selection:</strong>
<ul>
<li>After selecting two Twix there are 38 Twix and 98 candies left,
meaning the probability of selecting a Twix is <span class="math inline">\frac{38}{98}</span>.</li>
</ul></li>
</ol>
<p>The total probability that we grab all Twix from the bowl is the
product of these probabilities: <strong><span class="math inline">\frac{40}{100} \cdot \frac{39}{99} \cdot
\frac{38}{98}</span></strong></p>
<hr/>
<h5>Difficulty: ⭐️</h5>
<p>
</p>
<p>The average score on this problem was 94%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<h3 id="problem-6.2">Problem 6.2</h3>
<p>What is the probability you get no Twix? Leave your answer
<strong>completely unsimplified</strong>, similar to the answer choices
for part (a).</p>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading6_2">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse6_2" aria-expanded="true" aria-controls="collapse6_2">
Click to view the solution.
</button>
</h2>
<div id="collapse6_2" class="accordion-collapse collapse"
aria-labelledby="heading6_2" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer</strong>: <span class="math inline">\dfrac{60}{100}
\cdot \dfrac{59}{99} \cdot \dfrac{58}{98}</span></p>
<p>We need to find the probability that we get no Twix among the three
candies selected from the bowl. We know that two candies are not Twix in
our bowl (M&amp;Ms and Kitkats). Since we are selecting three times from
the same bowl, we know that we are selecting <strong>without
replacement</strong>.</p>
<ol type="1">
<li><strong>First Selection:</strong>
<ul>
<li>There are 60 non-Twix candies in the bowl (50 M&amp;Ms and 10
Kitkats) and 100 total candies. This means the probability of selecting
a non-Twix is <span class="math inline">\frac{60}{100}</span>.</li>
</ul></li>
<li><strong>Second Selection:</strong>
<ul>
<li>Regardless of which non-Twix candy was chosen, there are now 59
non-Twix candies in the bowl (49 M&amp;Ms and 10 Kitkats OR 50 M&amp;Ms
and 9 Kitkats). Since there are 99 total candies in the bowl, the
probability of selecting a non-Twix is <span class="math inline">\frac{59}{99}</span>.</li>
</ul></li>
<li><strong>Third Selection:</strong>
<ul>
<li>After selecting two non-Twix there are 58 non-Twix and 98 total
candies left meaning the probability of selecting a non-Twix is <span class="math inline">\frac{58}{98}</span>.</li>
</ul></li>
</ol>
<p>The total probability that we grab no Twix from the bowl is the
product of these probabilities: <strong><span class="math inline">\frac{60}{100} \cdot \frac{59}{99} \cdot
\frac{58}{98}</span></strong></p>
<hr/>
<h5>Difficulty: ⭐️⭐️</h5>
<p>
</p>
<p>The average score on this problem was 81%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<h3 id="problem-6.3">Problem 6.3</h3>
<p>Let <span class="math inline">a</span> be your answer to part (a) and
let <span class="math inline">b</span> be your answer to part (b). Write
a mathematical expression in terms of <span class="math inline">a</span>
and/or <span class="math inline">b</span> that evaluates to the
probability of getting some Twix and some non-Twix candy from this
house.</p>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading6_3">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse6_3" aria-expanded="true" aria-controls="collapse6_3">
Click to view the solution.
</button>
</h2>
<div id="collapse6_3" class="accordion-collapse collapse"
aria-labelledby="heading6_3" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer</strong>: <span class="math inline">1 - a - b</span>
or <span class="math inline">1 - (a + b)</span></p>
<p>The case where we get some Twix and some non-Twix occurs can also be
thought of as the case when we <strong>DO NOT</strong> get either all
Twix <strong>OR</strong> all non-Twix. In 6.1 we calculated the
probability of getting all Twix as <span class="math inline">a</span>
and in 6.2 we calculated the probability of getting all non-Twix as
<span class="math inline">b</span>. Therefore the probability of getting
either all Twix <strong>OR</strong> all non-Twix is equal to <span class="math inline">a + b</span>. However, we are looking for the
probability that this <strong>does not</strong> happen, meaning our
answer is <span class="math inline">1 - (a + b)</span>.</p>
<hr/>
<h5>Difficulty: ⭐️⭐️⭐️⭐️</h5>
<p>
</p>
<p>The average score on this problem was 30%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<hr />
<h2 id="problem-7">Problem 7</h2>
<div class="meta">
<p><span class="pill pill-lecture" title="Lecture number(s)">Lecture
12</span></div></p>
<p>Suppose you visit another house and their candy bowl is composed of 2
Twix, 3 Rolos, 1 Snickers, 3 M&amp;Ms, and 1 KitKat. You do the same as
before and take 3 candies from the bowl at random.</p>
<p>Fill in the blanks in the code below so that
<code>prob_all_same</code> evaluates to an estimate of the probability
that you get three of the same type of candy.</p>
<pre><code>    candy_bowl = np.array([&quot;Twix&quot;, &quot;Twix&quot;, &quot;Rolo&quot;, &quot;Rolo&quot;, &quot;Rolo&quot;, &quot;Snickers&quot;, &quot;M&amp;M&quot;, &quot;M&amp;M&quot;, &quot;M&amp;M&quot;, &quot;KitKat&quot;])

    repetitions = 10000
    prob_all_same = 0
    for i in np.arange(repetitions):
        grab = np.random.choice(___(a)___)
        if ___(b)___:
            prob_all_same = prob_all_same + 1
    prob_all_same = ___(c)___</code></pre>
<p><br></p>
<h3 id="problem-7.1">Problem 7.1</h3>
<p>What goes in blank (a)?</p>
<ul class="task-list">
<li><p><input type="radio" disabled="" /> <code>candy_bowl, len(candy_bowl), replace=False</code></p></li>
<li><p><input type="radio" disabled="" /> <code>candy_bowl, 3, replace=False</code></p></li>
<li><p><input type="radio" disabled="" /> <code>candy_bowl, 3, replace=True</code></p></li>
<li><p><input type="radio" disabled="" /> <code>candy_bowl, repetitions, replace=True</code></p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading7_1">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse7_1" aria-expanded="true" aria-controls="collapse7_1">
Click to view the solution.
</button>
</h2>
<div id="collapse7_1" class="accordion-collapse collapse"
aria-labelledby="heading7_1" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer</strong>:
<code>candy_bowl, 3, replace=False</code></p>
<p>The question asks us to “take 3 candies from the bowl at random.” In
this part, we need to sample 3 candies at random using
<code>np.random.choice</code>. Now, we evaluate each option one by one
as follows:</p>
<ul>
<li><p><code>candy_bowl, len(candy_bowl), replace=False</code>: The code
tries to sample all candies without replacement. However, we are asked
to only sample three candies, not all.</p></li>
<li><p><code>candy_bowl, 3, replace=False</code>: The code samples three
candies without replacement, which matches the description. This option
is correct.</p></li>
<li><p><code>candy_bowl, 3, replace=True</code>: The code samples three
candies from the bowl with replacement. Under this setting, the same
candy can be selected multiple times in a single grab, which is not
realistic.</p></li>
<li><p><code>candy_bowl, repetitions, replace=True</code>: This option
attempts to sample <code>repetitions</code> (10,000) candies in a single
grab. We are asked to sample three candies per iteration of the loop,
not thousands.</p></li>
</ul>
<hr/>
<h5>Difficulty: ⭐️⭐️</h5>
<p>
</p>
<p>The average score on this problem was 88%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<h3 id="problem-7.2">Problem 7.2</h3>
<p>What goes in blank (b)?</p>
<ul class="task-list">
<li><p><input type="radio" disabled="" /> <code>grab[0] == "Rolo" and grab[1] == "Rolo" and grab[2] == "Rolo"</code></p></li>
<li><p><input type="radio" disabled="" /> <code>grab[0] == grab[1] and grab[0] == grab[2]</code></p></li>
<li><p><input type="radio" disabled="" /> <code>grab[0] == grab[1] or grab[0] == grab[2]</code></p></li>
<li><p><input type="radio" disabled="" /> <code>grab == "Rolo" | grab == "M&amp;M"</code></p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading7_2">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse7_2" aria-expanded="true" aria-controls="collapse7_2">
Click to view the solution.
</button>
</h2>
<div id="collapse7_2" class="accordion-collapse collapse"
aria-labelledby="heading7_2" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer</strong>:
<code>grab[0] == grab[1] and grab[0] == grab[2]</code></p>
<p>Here, we need condition that checks if all three candies selected in
the grab are the same. We now analyze each option as follows:</p>
<ul>
<li><p><code>grab[0] == "Rolo" and grab[1] == "Rolo" and grab[2] == "Rolo"</code>:
This condition explicitly checks if all three candies are “Rolo”. While
it ensures that the three candies are the same, it only works for “Rolo”
and not for other types of candy in the bowl (e.g., “Twix,”
“M&amp;M”).</p></li>
<li><p><code>grab[0] == grab[1] and grab[0] == grab[2]</code>: This
condition checks if the first candy (grab[0]) is the same as the second
(grab[1]) and the third (grab[2]). If all three candies are the same
type (regardless of which type), this condition will evaluate to True.
Otherwise, the expression will evaluate to False, which is what we need.
The option is correct.</p></li>
<li><p><code>grab[0] == grab[1] or grab[0] == grab[2]</code>: This
condition checks if the first candy (grab[0]) matches either the second
(grab[1]) or the third (grab[2]). It does not require all three candies
to be the same. For example, if grab = [“Twix”, “Twix”, “M&amp;M”], this
condition would incorrectly evaluate to True.</p></li>
<li><p><code>grab == "Rolo" | grab == "M&amp;M"</code>: This condition
is syntactically invalid. It tries to compare the grab list (which
contains three elements) with two strings (“Rolo” and “M&amp;M”) using a
bitwise OR (|), not to mention that it does not check if three candies
are the same.</p></li>
</ul>
<hr/>
<h5>Difficulty: ⭐️</h5>
<p>
</p>
<p>The average score on this problem was 92%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<h3 id="problem-7.3">Problem 7.3</h3>
<p>What goes in blank (c)?</p>
<ul class="task-list">
<li><p><input type="radio" disabled="" /> <code>prob_all_same.mean()</code></p></li>
<li><p><input type="radio" disabled="" /> <code>prob_all_same / len(candy_bowl)</code></p></li>
<li><p><input type="radio" disabled="" /> <code>prob_all_same / repetitions</code></p></li>
<li><p><input type="radio" disabled="" /> <code>prob_all_same / 3</code></p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading7_3">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse7_3" aria-expanded="true" aria-controls="collapse7_3">
Click to view the solution.
</button>
</h2>
<div id="collapse7_3" class="accordion-collapse collapse"
aria-labelledby="heading7_3" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer</strong>: <code>prob_all_same / repetitions</code></p>
<p>To calculate the estimated probability of drawing three candies of
the same type, we divide the total number of successes
(<code>prob_all_same</code>, which counts the instances where all three
candies are identical) by the total number of iterations
(<code>repetitions</code>).</p>
<p>The option <code>prob_all_same.mean()</code> is incorrect because
<code>prob_all_same</code> is an integer that accumulates the count of
successful trials, not an array or list that supports the
<code>.mean()</code> method. Similarly, dividing by
<code>len(candy_bowl)</code> or <code>3</code> is incorrect, as neither
represents the total number of iterations. Therefore, using these values
as the denominator would not provide an accurate probability
estimate.</p>
<hr/>
<h5>Difficulty: ⭐️⭐️</h5>
<p>
</p>
<p>The average score on this problem was 86%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<hr />
<h2 id="problem-8">Problem 8</h2>
<div class="meta">
<p><span class="pill pill-lecture" title="Lecture number(s)">Lecture
9</span></div></p>
<p>Select the correct way to fill in the blank such that the code below
evaluates to <code>True</code>.</p>
<pre><code>treat.groupby(______).mean().shape[0] == treat.shape[0]</code></pre>
<ul class="task-list">
<li><p><input type="radio" disabled="" /> <code>"address"</code></p></li>
<li><p><input type="radio" disabled="" /> <code>"candy"</code></p></li>
<li><p><input type="radio" disabled="" /> <code>"neighborhood"</code></p></li>
<li><p><input type="radio" disabled="" /> <code>["address", "candy"]</code></p></li>
<li><p><input type="radio" disabled="" /> <code>["candy", "neighborhood"]</code></p></li>
<li><p><input type="radio" disabled="" /> <code>["address", "neighborhood"]</code></p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading8">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse8" aria-expanded="true" aria-controls="collapse8">
Click to view the solution.
</button>
</h2>
<div id="collapse8" class="accordion-collapse collapse"
aria-labelledby="heading8" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer</strong>: <code>["address", "candy"]</code></p>
<p><code>.shape</code> returns a tuple containing the number of rows and
number of columns of a DataFrame respectively. By indexing
<code>.shape[0]</code> we get the number of rows. In the above question,
we are comparing whether the number of rows of <code>treat</code>
grouped by its column(s) is equal to the number of rows of the original
<code>treat</code> itself. This is only possible when there is a unique
row for each value in the column or for each combination of columns.
Since it is possible for an address to give out different types of
candy, values in <code>"address"</code> can show up multiple times.
Similarly, values in <code>"candy"</code> can also show up multiple
times since more than one house may give out a specific candy. A
neighborhood has multiple houses, so if a neighborhood has more than one
house, <code>"neighborhood"</code> will appear multiple times.</p>
<p>% write for combinations here % Each address gives out a specific
candy only once, and hence <code>["address", "candy"]</code> would have
a unique row for each combination. This would make the number of rows in
the grouped DataFrame equal to <code>treat</code> itself. Multiple
neighborhoods might be giving out the same candy or a single
neighborhood could be giving out multiple candies, so
<code>["candy", "neighborhood"]</code> is not the answer. Finally, a
neighborhood can have multiple addresses, but each address could be
giving out more than one candy, which would mean this combination would
occur multiple times in <code>treat</code>, which means this would also
not be an answer. Since <code>["address", "candy"]</code> is the only
combination that gives a unique row for each combination, the grouped
DataFrame would contain the same number of rows as <code>treat</code>
itself.</p>
<hr/>
<h5>Difficulty: ⭐️⭐️⭐️</h5>
<p>
</p>
<p>The average score on this problem was 69%.</p>
</div>
</div>
</div>
</div>
<hr />
<h2 id="problem-9">Problem 9</h2>
<div class="meta">
<p><span class="pill pill-lecture" title="Lecture number(s)">Lecture
9</span></div></p>
<p>Assume that all houses in <code>treat</code> give out the same size
candy, say fun-sized. Suppose we have an additional DataFrame,
<code>trick</code>, which is indexed by <code>"candy"</code> and has one
column, <code>"price"</code>, containing the cost in dollars of a
<strong>single piece</strong> of fun-sized candy, as a
<code>float</code>.</p>
<p>Suppose that:</p>
<ul>
<li><p><code>treat</code> has 200 rows total, and includes 15 distinct
types of candies.</p></li>
<li><p><code>trick</code> has 25 rows total: 15 for the candies that
appear in <code>treat</code>, plus 10 additional rows that correspond to
candies not represented in <code>treat</code>.</p></li>
</ul>
<p>Consider the following line of code:</p>
<pre><code>trick_or_treat = trick.merge(treat, left_index = True, right_on = &quot;candy&quot;)</code></pre>
<p>How many rows does <code>trick_or_treat</code> have?</p>
<ul class="task-list">
<li><p><input type="radio" disabled="" /> <span class="math inline">15</span></p></li>
<li><p><input type="radio" disabled="" /> <span class="math inline">25</span></p></li>
<li><p><input type="radio" disabled="" /> <span class="math inline">200</span></p></li>
<li><p><input type="radio" disabled="" /> <span class="math inline">215</span></p></li>
<li><p><input type="radio" disabled="" /> <span class="math inline">225</span></p></li>
<li><p><input type="radio" disabled="" /> <span class="math inline">3000</span></p></li>
<li><p><input type="radio" disabled="" /> <span class="math inline">5000</span></p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading9">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse9" aria-expanded="true" aria-controls="collapse9">
Click to view the solution.
</button>
</h2>
<div id="collapse9" class="accordion-collapse collapse"
aria-labelledby="heading9" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer</strong>: 200</p>
<p>We are told that <code>trick</code> has 25 rows: 15 from candies that
are in <code>treat</code> and 10 additional candies. This means that
each candy in <code>trick</code> appears exactly once because 15+10= 25.
In addition, a general property when merging dataframes is that the
number of rows for one shared value between the dataframes is the
product of the number of occurences in either dataframe. For example, if
Twix occurs 5 times in <code>treat</code>, the number of times it occurs
in <code>trick_or_treat</code> is 5 * 1 = 5 (it occurs once in
<code>trick</code>). Using this logic, we can determine how many rows
are in <code>trick_or_treat</code>. Since each number of candies is
multipled by one and they sum up to 200, the number of rows will be
200.</p>
<hr/>
<h5>Difficulty: ⭐️⭐️⭐️⭐️</h5>
<p>
</p>
<p>The average score on this problem was 39%.</p>
</div>
</div>
</div>
</div>
<hr />
<h2 id="problem-10">Problem 10</h2>
<div class="meta">
<p><span class="pill pill-lecture" title="Lecture number(s)">Lecture
7</span></div></p>
<p>Recall from the last problem that the DataFrame
<code>trick_or_treat</code> includes a column called
<code>"price"</code> with the cost in dollars of a <strong>single
piece</strong> of fun-sized candy, as a <code>float</code>.</p>
<p>Assume we have run the line of code <code>tot = trick_or_treat</code>
to reassign <code>trick_or_treat</code> to the shorter variable name
<code>tot</code>.</p>
<p>In this problem, we’ll use <code>tot</code> to calculate the total
amount of money that each house spent on Halloween candy. This number is
always less than <span class="math inline">\$80</span> for the houses in
our data set.</p>
<p><br></p>
<h3 id="problem-10.1">Problem 10.1</h3>
<p>Fill in the blanks below so that the following block of code plots a
histogram that displays the distribution of the total amount of money
that houses spent on Halloween candy, in dollars.</p>
<pre><code>total = (tot.assign(total_spent = ___(a)___)
            .groupby(___(b)___).___(c)___)
total.plot(kind = &quot;hist&quot;,  y = &quot;total_spent&quot;, density = True,
           bins = np.arange(0, 90, 10))
            </code></pre>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading10_1">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse10_1" aria-expanded="true" aria-controls="collapse10_1">
Click to view the solution.
</button>
</h2>
<div id="collapse10_1" class="accordion-collapse collapse"
aria-labelledby="heading10_1" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer</strong>:</p>
<ul>
<li><p>(a): <code>tot.get("price") * tot.get("how_many")</code></p></li>
<li><p>(b): “address”</p></li>
<li><p>(c): <code>sum()</code></p></li>
</ul>
<p><strong>(a):
<code>tot.get("price") * tot.get("how_many")</code></strong></p>
<ul>
<li><code>tot.get("price")</code> retrieves the cost of a single piece
of candy.</li>
<li><code>tot.get("how_many")</code> retrieves the number of pieces of
candy given out.</li>
<li>Multiplying these two columns calculates the total amount spent on
candy for each row in the dataset.</li>
<li>This step creates a new column <code>total_spent</code> that
represents the total money spent for each type of candy at a given
house.</li>
</ul>
<p><strong>(b): “address”</strong></p>
<ul>
<li>The data is grouped by the <code>"address"</code> column, which
uniquely identifies each house. This ensures that all records associated
with a single house are aggregated together.</li>
</ul>
<p><strong>(c): <code>sum()</code></strong></p>
<ul>
<li>After grouping by <code>"address"</code>, the <code>.sum()</code>
operation aggregates the total amount of money spent on candy for each
house. This sums up all <code>total_spent</code> values for records
belonging to the same house.</li>
</ul>
<p>Final Output: The <code>total</code> DataFrame will have one row for
each house, with the column <code>total_spent</code> representing the
total money spent on Halloween candy. Finally, the
<code>total.plot</code> command creates a histogram of the
<code>total_spent</code> values to visualize the distribution of
spending across houses.</p>
<hr/>
<h5>Difficulty: ⭐️⭐️⭐️</h5>
<p>
</p>
<p>The average score on this problem was 65%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<p>The histogram below displays the distribution of the total amount of
money that houses spent on Halloween candy; it is the histogram that
would be generated from the code snippet above, assuming the blanks were
filled in correctly.</p>
<center><img src='../assets/images/fa24-midterm/halloween_dist.png' width=500></center>
<p><br></p>
<h3 id="problem-10.2">Problem 10.2</h3>
<p>Which two adjacent bins in the histogram represent about <span
class="math inline">50\%</span> of the houses?</p>
<ul class="task-list">
<li><p><input type="radio" disabled="" /> <code>[10, 20)</code> and <code>[20, 30)</code></p></li>
<li><p><input type="radio" disabled="" /> <code>[20, 30)</code> and <code>[30, 40)</code></p></li>
<li><p><input type="radio" disabled="" /> <code>[30, 40)</code> and <code>[40, 50)</code></p></li>
<li><p><input type="radio" disabled="" /> <code>[40, 50)</code> and <code>[50, 60)</code></p></li>
<li><p><input type="radio" disabled="" /> <code>[50, 60)</code> and <code>[60, 70)</code></p></li>
<li><p><input type="radio" disabled="" /> Not possible to determine.</p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading10_2">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse10_2" aria-expanded="true" aria-controls="collapse10_2">
Click to view the solution.
</button>
</h2>
<div id="collapse10_2" class="accordion-collapse collapse"
aria-labelledby="heading10_2" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer</strong>: <code>[20, 30)</code> and
<code>[30, 40)</code></p>
<ul>
<li>The histogram shows that the bins <code>[20, 30)</code> and
<code>[30, 40)</code> have the two tallest bars, with heights of 0.020
and 0.030, respectively.</li>
<li>Each bar’s height represents the density of data in that range
(proportion of houses divided by bin width). Since the bin width is 10,
we can multiply the height by 10 to calculate the proportion of data in
each bin:
<ul>
<li><code>[20, 30)</code> contributes <span class="math inline">0.020
\times 10 = 0.2</span> or <span class="math inline">20\%</span> of the
houses.</li>
<li><code>[30, 40)</code> contributes <span class="math inline">0.030
\times 10 = 0.3</span> or <span class="math inline">30\%</span> of the
houses.</li>
</ul></li>
<li>Together, these two bins account for <span class="math inline">20\%
+ 30\% = 50\%</span> of the houses.</li>
</ul>
<hr/>
<h5>Difficulty: ⭐️⭐️</h5>
<p>
</p>
<p>The average score on this problem was 83%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<h3 id="problem-10.3">Problem 10.3</h3>
<p>Suppose we create a new histogram, using the same code as above but
with <code>bins = np.arange(0, 90, 20)</code> instead of
<code>bins = np.arange(0, 90, 10)</code>. Approximate the height of the
tallest bar in this new histogram. If this is not possible, write “Not
possible to determine."</p>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading10_3">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse10_3" aria-expanded="true" aria-controls="collapse10_3">
Click to view the solution.
</button>
</h2>
<div id="collapse10_3" class="accordion-collapse collapse"
aria-labelledby="heading10_3" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer</strong>: 0.025</p>
<ul>
<li>With the new bin width of 20, the histogram combines adjacent bins
from the original histogram. The new bins become
<code>[0, 20)</code>,<code>[20, 40)</code>,<code>[40, 60)</code>,<code>[60, 80)</code>.
The bin <code>[20, 40)</code> merges the original bins
<code>[20, 30)</code> and <code>[30, 40)</code> and would be the bin
with the highest bar in the new histogram.</li>
<li>To find the total proportion of data in <code>[20, 40)</code>:
<ul>
<li>From the original histogram:
<ul>
<li><code>[20, 30)</code> contributes <span class="math inline">0.020
\times 10 = 0.2</span> (20%).</li>
<li><code>[30, 40)</code> contributes <span class="math inline">0.030
\times 10 = 0.3</span> (30%).</li>
</ul></li>
<li>Total for <code>[20, 40)</code> is <span class="math inline">0.2 +
0.3 = 0.5</span> or <span class="math inline">50\%</span>.</li>
</ul></li>
<li>The new bin width is 20, so the height of the bar is calculated as:
Height = <span class="math inline">\frac{\text{Proportion}}{\text{Bin
Width}}</span> = <span class="math inline">\frac{0.5}{20}</span> =
0.025<br/>
</li>
<li>Therefore, the tallest bar in the new histogram has a height of
0.025.</li>
</ul>
<hr/>
<h5>Difficulty: ⭐️⭐️⭐️⭐️</h5>
<p>
</p>
<p>The average score on this problem was 38%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<h3 id="problem-10.4">Problem 10.4</h3>
<p>Suppose we create a new histogram, using the same code as above but
substituting <code>bins = np.arange(0, 90, 5)</code> for
<code>bins = np.arange(0, 90, 10)</code>. Approximate the height of the
tallest bar in this new histogram. If this is not possible, write “Not
possible to determine."</p>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading10_4">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse10_4" aria-expanded="true" aria-controls="collapse10_4">
Click to view the solution.
</button>
</h2>
<div id="collapse10_4" class="accordion-collapse collapse"
aria-labelledby="heading10_4" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer</strong>: Not possible to determine.</p>
<ul>
<li>In the original histogram, the bins are 10 units wide (e.g.,
<code>[20, 30)</code>). When switching to 5-unit bins (e.g.,
<code>[20, 25)</code>, <code>[25, 30)</code>), we need to know the
distribution of data within the original 10-unit bins to calculate the
new bar heights.</li>
<li>The histogram does not provide this detailed information. For
example, we cannot determine whether the data in <code>[20, 30)</code>
is evenly distributed between <code>[20, 25)</code> and
<code>[25, 30)</code> or concentrated in one of the sub-bins.</li>
<li>Without this additional information, it is impossible to approximate
the height of the tallest bar accurately.</li>
</ul>
<hr/>
<h5>Difficulty: ⭐️⭐️⭐️</h5>
<p>
</p>
<p>The average score on this problem was 70%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<hr />
<h2 id="problem-11">Problem 11</h2>
<div class="meta">
<p><span class="pill pill-lecture" title="Lecture number(s)">Lecture
5</span></div></p>
<p>As in the last problem, we’ll continue working with the
<code>tot</code> DataFrame that came from merging <code>trick</code>
with <code>treat</code>. The <code>"price"</code> column contains the
cost in dollars of a <strong>single piece</strong> of fun-sized candy,
as a <code>float</code>.</p>
<p>In this problem, we want to use <code>tot</code> to calculate the
<strong>average cost per piece</strong> of Halloween candy at each
house. For example, suppose one house has 30 Twix, which cost <span
class="math inline">\$0.20</span> each, and 20 Laffy Taffy, which cost
<span class="math inline">\$0.10</span> each. Then this house spent
<span class="math inline">\$8.00</span> on 50 pieces of candy, for an
average cost of <span class="math inline">\$0.16</span> per piece.</p>
<p>Which of the following correctly sets <code>ac</code> to a DataFrame
indexed by <code>"address"</code> with a column called
<code>"avg_cost"</code> that contains the average cost per piece of
Halloween candy at each address? Select all that apply.</p>
<p>Way 1:</p>
<pre><code>ac = tot.groupby(&quot;address&quot;).sum()
ac = ac.assign(avg_cost = ac.get(&quot;price&quot;) / 
                          ac.get(&quot;how_many&quot;)).get([&quot;avg_cost&quot;])</code></pre>
<p>Way 2:</p>
<pre><code>ac = tot.assign(x = tot.get(&quot;price&quot;) / tot.get(&quot;how_many&quot;))
ac = ac.groupby(&quot;address&quot;).sum()
ac = ac.assign(avg_cost = ac.get(&quot;x&quot;).mean()).get([&quot;avg_cost&quot;])</code></pre>
<p>Way 3:</p>
<pre><code>ac = tot.assign(x = tot.get(&quot;price&quot;) / tot.get(&quot;how_many&quot;))
ac = ac.groupby(&quot;address&quot;).sum()
ac = ac.assign(avg_cost = ac.get(&quot;x&quot;) / 
                          ac.get(&quot;how_many&quot;)).get([&quot;avg_cost&quot;])</code></pre>
<p>Way 4:</p>
<pre><code>ac = tot.assign(x = tot.get(&quot;how_many&quot;) * tot.get(&quot;price&quot;))
ac = ac.groupby(&quot;address&quot;).sum()
ac = ac.assign(avg_cost = ac.get(&quot;x&quot;).mean()).get([&quot;avg_cost&quot;])</code></pre>
<p>Way 5:</p>
<pre><code>ac = tot.assign(x = tot.get(&quot;how_many&quot;) * tot.get(&quot;price&quot;))
ac = ac.groupby(&quot;address&quot;).sum()
ac = ac.assign(avg_cost = ac.get(&quot;x&quot;) / 
                          ac.get(&quot;how_many&quot;)).get([&quot;avg_cost&quot;])</code></pre>
<ul class="task-list">
<li><p><input type="checkbox" disabled="" /> Way 1</p></li>
<li><p><input type="checkbox" disabled="" /> Way 2</p></li>
<li><p><input type="checkbox" disabled="" /> Way 3</p></li>
<li><p><input type="checkbox" disabled="" /> Way 4</p></li>
<li><p><input type="checkbox" disabled="" /> Way 5</p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading11">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse11" aria-expanded="true" aria-controls="collapse11">
Click to view the solution.
</button>
</h2>
<div id="collapse11" class="accordion-collapse collapse"
aria-labelledby="heading11" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer</strong>: Option 5</p>
<p>We need the average cost per piece at each house.</p>
<p>The correct formula would be: (total spent on candy) / (total pieces
of candy)</p>
<p>Let’s go through each Way and assess if it is valid or not.</p>
<p><strong>Way 1</strong>: When we sum the “price” column directly,
we’re summing the per-piece prices, not the total spent. This gives
wrong totals. For example, if a house has 30 pieces at $0.20 and 20 at
$0.10, summing prices gives $0.30 instead of $8.00.</p>
<p><strong>Way 2</strong>: This first calculates price/quantity for each
candy type, then takes the mean of these ratios. This is mathematically
incorrect for finding average cost per piece.</p>
<ul>
<li>For Twix: $0.20/30 = $0.00667 per piece</li>
<li>For Laffy Taffy: $0.10/20 = $0.005 per piece</li>
<li>Takes mean: ($0.00667 + $0.005)/2 = $0.00583</li>
<li>This is wrong because it’s taking mean of ratios instead of ratio of
totals</li>
</ul>
<p><strong>Way 3</strong>: Similar to Way 2, but even more problematic
as it divides by quantity twice.</p>
<ul>
<li>For Twix: $0.20/30 = $0.00667</li>
<li>For Laffy Taffy: $0.10/20 = $0.005</li>
<li>Sums these: $0.00667 + $0.005 = $0.01167</li>
<li>Divides by total quantity again: $0.01167/50 = $0.000233</li>
</ul>
<p><strong>Way 4</strong>: Correctly calculates total spent (x =
quantity * price) but then takes the mean of the totals instead of
dividing by total quantity.</p>
<ul>
<li>For Twix: 30 × $0.20 = $6.00</li>
<li>For Laffy Taffy: 20 × $0.10 = $2.00</li>
<li>Takes mean of these totals: ($6.00 + $2.00)/2 = $4.00 (wrong)</li>
<li>This is wrong because it takes mean of totals instead of dividing by
total quantity</li>
</ul>
<p><strong>Way 5</strong>: This is correct because:</p>
<ul>
<li>First calculates total spent on each candy type (quantity * price
per piece)</li>
<li>Groups by address and sums both the total spent and total
quantities</li>
<li>Finally divides total spent by total pieces to get average cost per
piece</li>
</ul>
<p>Using our example:</p>
<ul>
<li>30 Twix at $0.20 = $6.00</li>
<li>20 Laffy Taffy at $0.10 = $2.00</li>
<li>Total spent = $8.00</li>
<li>Total pieces = 50</li>
<li>Average = $8.00/50 = $0.16 per piece, the correct answer.</li>
</ul>
<hr/>
<h5>Difficulty: ⭐️⭐️⭐️</h5>
<p>
</p>
<p>The average score on this problem was 71%.</p>
</div>
</div>
</div>
</div>
<hr />
<h2 id="problem-12">Problem 12</h2>
<div class="meta">
<p><span class="pill pill-lecture" title="Lecture number(s)">Lecture
6</span></div></p>
<p><br></p>
<h3 id="problem-12.1">Problem 12.1</h3>
<p>What would be the best type of plot to visualize the distribution of
<code>"neighborhood"</code> among the houses represented in
<code>treat</code>?</p>
<ul class="task-list">
<li><p><input type="radio" disabled="" /> scatter plot</p></li>
<li><p><input type="radio" disabled="" /> line plot</p></li>
<li><p><input type="radio" disabled="" /> bar chart</p></li>
<li><p><input type="radio" disabled="" /> histogram</p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading12_1">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse12_1" aria-expanded="true" aria-controls="collapse12_1">
Click to view the solution.
</button>
</h2>
<div id="collapse12_1" class="accordion-collapse collapse"
aria-labelledby="heading12_1" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer</strong>: bar chart</p>
<hr/>
<h5>Difficulty: ⭐️⭐️</h5>
<p>
</p>
<p>The average score on this problem was 76%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<h3 id="problem-12.2">Problem 12.2</h3>
<p>Suppose we had access to historical data about the price of fun-sized
candies over time. If we wanted to compare the prices of Milky Way and
Skittles over time, which would be the best type of visualization to
plot?</p>
<ul class="task-list">
<li><p><input type="radio" disabled="" /> overlaid scatter plot</p></li>
<li><p><input type="radio" disabled="" /> overlaid line plot</p></li>
<li><p><input type="radio" disabled="" /> overlaid bar chart</p></li>
<li><p><input type="radio" disabled="" /> overlaid histogram</p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading12_2">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse12_2" aria-expanded="true" aria-controls="collapse12_2">
Click to view the solution.
</button>
</h2>
<div id="collapse12_2" class="accordion-collapse collapse"
aria-labelledby="heading12_2" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer</strong>: overlaid line plot</p>
<hr/>
<h5>Difficulty: ⭐️</h5>
<p>
</p>
<p>The average score on this problem was 90%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<hr />
<h2 id="problem-13">Problem 13</h2>
<div class="meta">
<p><span class="pill pill-lecture" title="Lecture number(s)">Lecture
5</span></div></p>
<p><strong>Extra Credit</strong></p>
<p>Define the variable <code>double</code> as follows.</p>
<p><code>double = treat.groupby("candy").count().groupby("address").count()</code></p>
<p>Now, suppose you know that</p>
<p><code>double.loc[1].get("how_many")</code> evaluates to
<code>5</code>.</p>
<p>Which of the following is a valid interpretation of this information?
Select all that apply.</p>
<ul class="task-list">
<li><p><input type="checkbox" disabled="" /> There are five houses that are each giving out only one type of
candy.</p></li>
<li><p><input type="checkbox" disabled="" /> There are five types of candy that are each being given out by only
one house.</p></li>
<li><p><input type="checkbox" disabled="" /> There is only one house that is giving out five types of candy.</p></li>
<li><p><input type="checkbox" disabled="" /> There is only one type of candy that is being given out by five
houses.</p></li>
<li><p><input type="checkbox" disabled="" /> None of these.</p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading13">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse13" aria-expanded="true" aria-controls="collapse13">
Click to view the solution.
</button>
</h2>
<div id="collapse13" class="accordion-collapse collapse"
aria-labelledby="heading13" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer</strong>: Option 2</p>
<p>Let’s approach this solution by breaking down the line of code into
two intermediate steps, so that we can parse them one at a time:</p>
<ul>
<li><code>intermediate_one = treat.groupby("candy").count()</code></li>
<li><code>double = intermediate_one.groupby("address").count()</code></li>
</ul>
<p><strong>Step 1</strong>:
<code>intermediate_one = treat.groupby("candy").count()</code></p>
<p>The first of our two operations groups the <code>treat</code>
DataFrame by the <code>"candy"</code> column, and aggregates using the
<code>.count()</code> method. This creates an output DataFrame that is
indexed by <code>"candy"</code>, where the values in each column
represent the number of times each candy appeared in the
<code>treat</code> DataFrame.</p>
<p>Remember, in our original DataFrame, each row represents one type of
candy being given out by one house. So, each row in
<code>intermediate_one</code> will contain the <strong>number of houses
giving out each candy</strong>. For example, if the values in the
columns in the row with row label <code>Milky Way</code> were all <span class="math inline">3</span>, it would mean that there are <span class="math inline">3</span> houses giving out Milky Ways.</p>
<p><strong>Step 2</strong>:
<code>double = intermediate_one.groupby("address").count()</code></p>
<p>The second of our two operations groups the
<code>intermediate_one</code> DataFrame by the <code>"address"</code>
column, and aggregates using the <code>.count()</code> method. This
creates an output DataFrame that is indexed by <code>"address"</code>,
where the values in each column represent the number of times that each
value in the address column appeared in the
<code>intermediate_one</code> DataFrame. However, these are more
difficult to interpret, so let’s break down what this means in the
context of our problem.</p>
<p>The values in the <code>intermediate_one</code> DataFrame represent
how many houses are giving out a specific type of candy (this is the
result of our first operation). So, when we group by these values, the
resulting groups will be defined by all candies that are given out by
the same number of houses. For example, if the values in the columns
with row label <code>5</code> were all <span class="math inline">2</span>, it would mean that there are <span class="math inline">2</span> types of candy that are being given out by
<span class="math inline">5</span> houses. More concretely, this would
mean that the value <span class="math inline">5</span> showed up <span class="math inline">2</span> times in the <code>intermediate_one</code>
DataFrame, which means there must have been <span class="math inline">2</span> candies that were being given out by <span class="math inline">5</span> houses (see above).</p>
<p>Combining these two results, we can interpret the output of our
original line of code:</p>
<p><code>double = treat.groupby("candy").count().groupby("address").count()</code>
outputs a DataFrame where the value in each row represents the number of
different candies that are being given out by the same number of
houses.</p>
<p>Now, we can easily interpret this line of code:</p>
<p><code>double.loc[1].get("how_many")</code> evaluates to
<code>5</code>.</p>
<p>This means that there are <span class="math inline">5</span>
different types of candies that are being given out by only <span class="math inline">1</span> house. This corresponds to <strong>Option
2</strong> and only Option <span class="math inline">2</span> in our
answer choices, so <strong>Option 2</strong> is the correct answer.</p>
<hr/>
<h5>Difficulty: ⭐️⭐️⭐️⭐️⭐️</h5>
<p>
</p>
<p>The average score on this problem was 15%.</p>
</div>
</div>
</div>
</div>
<hr />
<h2 id="section"><span class="math display"> </span></h2>
<h4
id="feedback-find-an-error-still-confused-have-a-suggestion-let-us-know-here.">👋
Feedback: Find an error? Still confused? Have a suggestion?
<a href="https://forms.gle/WZ71FchnXU1K154d7">Let us know
here</u></a>.</h4>
<hr />
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</body>
</html>
