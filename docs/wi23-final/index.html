<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Winter 2023 Final Exam</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    /* CSS for syntax highlighting */
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { color: #008000; } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { color: #008000; font-weight: bold; } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="..\assets\theme.css" />
  <script defer=""
  src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <link rel="stylesheet"
  href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">Winter 2023 Final Exam</h1>
</header>
<p><link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-EVSTQN3/azprG1Anm3QDgpJLIm9Nao0Yz1ztcQTwFspd3yD65VohhpuuCOmLASjC" crossorigin="anonymous">
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/js/bootstrap.bundle.min.js" integrity="sha384-MrcW6ZMFYlzcLA8Nl+NtUVF0sA7MsXsP1UyJoMp4YLEuNSfAP+JcXn/tWtIaxVXM" crossorigin="anonymous"></script>
<!-- add after bootstrap.min.css -->
<link rel="stylesheet" href="https://cdn.rawgit.com/afeld/bootstrap-toc/v1.0.1/dist/bootstrap-toc.min.css"/>
<!-- add after bootstrap.min.js or bootstrap.bundle.min.js -->
<script src="https://cdn.rawgit.com/afeld/bootstrap-toc/v1.0.1/dist/bootstrap-toc.min.js"></script></p>
<!-- for difficulty gauges-->
<script src="https://cdn.plot.ly/plotly-2.16.1.min.js"></script>
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-B947E6J6H4"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-B947E6J6H4');
</script>
<p><a href="../index.html">← return to practice.dsc10.com</a></p>
<hr />
<p><strong>Instructor(s):</strong> Janine Tiefenbruck</p>
<p>This exam was administered in-person. The exam was closed-notes,
except students were provided a copy of the
<a href='https://drive.google.com/file/d/1ky0Np67HS2O4LO913P-ing97SJG0j27n/view'>DSC
10 Reference Sheet<a>. No calculators were allowed. Students had
<strong>3 hours</strong> to take this exam.</p>
<hr />
<p>The DataFrame <code>games</code> contains information about a sample
of popular games, including board games, dice games, and card games. The
data comes from Board Game Geek, a popular website and vibrant online
community for game enthusiasts.</p>
<p>The columns of games are as follows.</p>
<ul>
<li><code>"Name"</code> (<code>str</code>): The name of the game.</li>
<li><code>"Mechanics"</code> (<code>str</code>): A sequence of
descriptors for how the game is played. A game can have several
descriptors, each of which is separated by a comma.</li>
<li><code>"Domains"</code> (<code>str</code>): A sequence of domains to
which the game belongs. A game can belong to multiple domains.</li>
<li><code>"Play Time"</code> (<code>int</code>): The average play time
of the game, in minutes, as suggested by the game’s creators.</li>
<li><code>"Complexity"</code> (<code>float</code>): The average
complexity of the game, on a scale of 1 to 5 points, as reported by
Board Game Geek community members.</li>
<li><code>"Rating"</code> (<code>str</code>): The average rating of the
game, on a scale of 1 to 10 points, as rated by Board Game Geek
community members. Note that while this data should be numerical, it is
actually stored as a string, because some entries use a comma in place
of a decimal point. For example 8,79 actually represents the number
8.79.</li>
<li><code>"BGG Rank"</code> (<code>int</code>): The rank of the game in
Board Game Geek’s database. The formula for how this rank is calculated
is not publicly known, but it likely includes many factors, such as
<code>"Rating"</code>, number of registered owners of the game, and
number of reviews.</li>
</ul>
<p>The first few rows of <code>games</code> are shown below (though
<code>games</code> has many more rows thanpictured here).</p>
<center><img src='../assets/images/wi23-final/preview.jpg' width=45%></center>
<p><br></p>
<p>Throughout this exam, we will refer to games repeatedly. Assume that
we have already run <code>import babypandas as bpd</code> and
<code>import numpy as np</code></p>
<hr />
<h2 id="problem-1">Problem 1</h2>
<p><br></p>
<h3 id="problem-1.1">Problem 1.1</h3>
<p>Let’s start by correcting the data in the <code>"Rating"</code>
column. All the values in this column are strings of length 4. In
addition, some strings use commas in place of a dot to represent a
decimal point. Select the options below that evaluate to a Series
containing the values in the <code>"Rating"</code> column, appropriately
changed to floats.</p>
<p><strong>Note:</strong> The Series method <code>.str.replace</code>
uses the string method <code>.replace</code> on every string in a
Series.</p>
<ul class="task-list">
<li><p><input type="checkbox" disabled="" /> <code>float(games.get("Rating").str.replace(",", "."))</code></p></li>
<li><p><input type="checkbox" disabled="" /> <code>games.get("Rating").str.replace(",", ".").apply(float)</code></p></li>
<li><p><input type="checkbox" disabled="" /> <code>games.get("Rating").str.replace(",", "").apply(int)/100</code></p></li>
<li><p><input type="checkbox" disabled="" /> <code>games.get("Rating").str.replace(",", "").apply(float)</code></p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading1_1">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse1_1" aria-expanded="true" aria-controls="collapse1_1">
Click to view the solution.
</button>
</h2>
<div id="collapse1_1" class="accordion-collapse collapse"
aria-labelledby="heading1_1" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer:</strong> Options 2 and 3</p>
<p><strong>Option 1:</strong> Let’s look at the code piece by piece to
understand why this does not work. <code>games.get(“Rating”)</code>
gives you the column <code>“Rating”</code> as a Series. As seen from the
node, <code>.str.replace(“,”, “.”)</code> can be used on a series, and
will replace all commas with periods. Remember, that you cannot cast a
Series to a float with <code>float()</code> because there are many
values. This will cause an error making this option wrong.</p>
<p><strong>Option 2:</strong> Once again we are getting
<code>“Rating”</code> as a Series and replacing the commas with periods.
We then apply <code>float()</code> to the series, which will
successfully convert all of the values into floats.</p>
<p><strong>Option 3:</strong> Following the same logic as above, we are
getting <code>“Rating”</code> as a Series, but change it up by replacing
the commas with an empty string, which is effectively nothing. Notice
this makes the numbers 100 times too big. Since there are no decimals we
can convert the Series’ strings into integers, which is done by doing
<code>.apply(int)</code>. Finally, because the elements inside of
<code>“Rating”</code> are 100 times too large it can be fixed by
dividing them all by 100.</p>
<p><strong>Option 4:</strong> Again, we are getting
<code>“Rating”</code> as a Series and replacing the commas with an empty
string. The values inside of <code>“Rating”</code> are then converted to
floats, which is fine, but remember, that the numbers are 100 times too
big. This means we have altered the actual value inappropriately, which
makes this option incorrect.</p>
<hr/>
<h5>Difficulty: ⭐️</h5>
<p>
</p>
<p>The average score on this problem was 100%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<p><strong>Important!</strong> For the rest of this exam, we will assume
that the values in the <code>"Rating"</code> column have been correctly
changed to floats.</p>
<hr />
<h2 id="problem-2">Problem 2</h2>
<p><br></p>
<h3 id="problem-2.1">Problem 2.1</h3>
<p>You are unsure whether it would make sense to use
<code>"BGG Rank"</code> as the index of the <code>games</code>
DataFrame, because you are unsure whether this column can have duplicate
values. Perhaps, for example, two games are tied and both have a rank of
6.</p>
<p>Select all of the expressions below that evaluate to True when the
<code>"BGG Rank"</code> column could be used as the index (no
duplicates), and False when it could not be used as the index
(duplicates). In other words, these are the expressions that can be used
to detect the presence of duplicate values.</p>
<ul class="task-list">
<li><p><input type="checkbox" disabled="" /> <code>(games.get("BGG Rank") - np.arange(games.shape[0])).max() == 1</code></p></li>
<li><p><input type="checkbox" disabled="" /> <code>games.groupby("BGG Rank").count().get("Name").max() == 1</code></p></li>
<li><p><input type="checkbox" disabled="" /> <code>games.shape[0] - len(np.unique(games.get("BGG Rank"))) == 0</code></p></li>
<li><p><input type="checkbox" disabled="" /> <code>games.get("BGG Rank").max() - games.shape[0] == 0</code></p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading2_1">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse2_1" aria-expanded="true" aria-controls="collapse2_1">
Click to view the solution.
</button>
</h2>
<div id="collapse2_1" class="accordion-collapse collapse"
aria-labelledby="heading2_1" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer:</strong> Options 2 and 3</p>
<p><strong>Option 1:</strong> <code>games.get(“BGG Rank”)</code> will
get you a Series of the <code>“BGG Rank”</code> column.
<code>np.arange(games.shape[0])</code> will create a numpy array that
will go from zero to <code>games.shape[0]</code>, which is the number of
rows in the <code>games</code> DataFrame. So it would look something
like: <code>arr([0, 1, 2, . . ., n])</code>, where <code>n</code> is the
number of rows in <code>games</code>. By doing:
<code>games.get(“BGG Rank”) - np.arange(games.shape[0])</code> one is
decreasing each rank by an increasing factor of one each time. This
essentially gives a Series of numbers, but it doesn’t actually have
anything to do with uniqueness. We are simply finding if the difference
between <code>“BGG Rank”</code> and the numpy array leads to a maximum
of 1. So although the code works it does not tell us if there are
duplicates.</p>
<p><strong>Option 2:</strong>
<code>games.groupby(“BGG Rank”).count()</code> gets all of the unique
<code>“BGG Rank”</code>’s and puts them into the index. Then by using
the aggregate function <code>.count()</code> we are able to turn all the
remaining columns into the number of times each <code>“BGG Rank”</code>
appears. Since all of the columns are the same we just need to get one
of them to access the counts. In this case we get the column “Name” by
doing <code>.get(“Name”)</code>. Finally, when we do
<code>.max() == 1</code> we are checking to see if the maximum count for
the number of unique <code>“BGG Rank”</code>’s is one, which would mean
there are no duplicates.</p>
<p><strong>Option 3:</strong> Let’s work from the inside out for this
line of code: <code>len(np.unique(games.get(“BGG Rank”)))</code>. Like
all the others we are getting a Series of <code>“BGG Rank”</code>.
<code>np.unique()</code> gives us an array with unique elements inside
of the Series. When we do <code>len()</code> we are figuring out how
many unique elements there are inside of <code>“BGG Rank”</code>. Recall
<code>games.shape[0]</code> gets us the number of rows in
<code>games</code>. This means that we are trying to see if the number
of rows is the same as the number of unique elements inside of
<code>“BGG Rank”</code>, and if they are then that means they are all
unique and should equal 0.</p>
<p><strong>Option 4:</strong> <code>games.get(“BGG Rank”).max()</code>
will give us the maximum element inside of <code>“BGG Rank”</code>.
Note, <code>games.shape[0]</code> gets us the number of rows in
<code>games</code>. We should never make assumptions about what is
inside of <code>“BGG Rank”</code>. This means we don’t know if the
values line up nicely like: 1, 2, 3, . . . <code>games.shape[0]</code>,
so the maximum element could be unique, but be bigger than
<code>games.shape[0]</code>. Knowing this, when we do the whole line for
Option 4 it is not guaranteed to be zero when <code>“BGG Rank”</code> is
unique or not, so it does not detect duplicates.</p>
<hr/>
<h5>Difficulty: ⭐️</h5>
<p>
</p>
<p>The average score on this problem was 100%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<p><strong>Note:</strong> We will not set the index of
<code>games</code>, instead we’ll leave it with the default index.</p>
<hr />
<h2 id="problem-3">Problem 3</h2>
<p>Notice that <code>"Strategy Games"</code> and
<code>"Thematic Games"</code> are two of the possible domains, and that
a game can belong to multiple domains.</p>
<p>Define the variables strategy and thematic follows.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>strategy <span class="op">=</span> games.get(<span class="st">&quot;Domains&quot;</span>).<span class="bu">str</span>.contains(<span class="st">&quot;Strategy Games&quot;</span>)</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>thematic <span class="op">=</span> games.get(<span class="st">&quot;Domains&quot;</span>).<span class="bu">str</span>.contains(<span class="st">&quot;Thematic Games&quot;</span>)</span></code></pre></div>
<p><br></p>
<h3 id="problem-3.1">Problem 3.1</h3>
<p>What is the data type of <code>strategy</code>?</p>
<ul class="task-list">
<li><p><input type="radio" disabled="" /> <code>bool</code></p></li>
<li><p><input type="radio" disabled="" /> <code>str</code></p></li>
<li><p><input type="radio" disabled="" /> <code>Series</code></p></li>
<li><p><input type="radio" disabled="" /> <code>DataFrame</code></p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading3_1">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse3_1" aria-expanded="true" aria-controls="collapse3_1">
Click to view the solution.
</button>
</h2>
<div id="collapse3_1" class="accordion-collapse collapse"
aria-labelledby="heading3_1" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer:</strong> <code>Series</code></p>
<p><code>strategy</code> will give you a <code>Series</code>. This is
because <code>games.get(“Domains”)</code> will give you one column, a
<code>Series</code>, and then
<code>.str.contains(“Strategy Games”)</code> will convert those values
to <code>True</code> if it contains that string and <code>False</code>
otherwise, but it will not actually change the <code>Series</code> to a
<code>DataFrame</code>, a <code>bool</code>, or a <code>str</code>.</p>
<hr/>
<h5>Difficulty: ⭐️</h5>
<p>
</p>
<p>The average score on this problem was 100%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<h3 id="problem-3.2">Problem 3.2</h3>
<p>Suppose we randomly select one of the <code>"Strategy Games"</code>
from the <code>games</code> DataFrame.</p>
<p>What is the probability that the randomly selected game is
<strong>not</strong> also one of the <code>"Thematic Games"</code>? In
the space below, write a single line of Python code that evaluates to
this probability, using the variables <code>strategy</code> and
<code>thematic</code> in your solution.</p>
<p><strong>Note:</strong> For this question and others that require one
line of code, it’s fine if you need to write your solution on multiple
lines, as long as it is just one line of Python code. Please do write on
multiple lines to make sure your answer fits within the box
provided.</p>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading3_2">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse3_2" aria-expanded="true" aria-controls="collapse3_2">
Click to view the solution.
</button>
</h2>
<div id="collapse3_2" class="accordion-collapse collapse"
aria-labelledby="heading3_2" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer:</strong>
<code>(games[(strategy == True) &amp; (thematic == False)].shape[0] / games[strategy == True].shape[0])</code>
or
<code>1 - games[strategy &amp; thematic].shape[0] / games[strategy].shape[0]</code></p>
<p>The problem is asking us to find the probability that a selected game
from <code>“Strategy Games”</code> will <strong>not</strong> be in
<code>“Thematic Games”</code>. Recall that this is the probability that
given <code>“Strategy Games”</code> will it not be in
<code>“Thematic Games”</code>, which would look like this:
P(<code>“Thematic Games”</code>
Compliment|<code>“Strategy Games”</code>). This means the formula would
look like: (<code>“Thematic Games”</code> Compliment
<strong>and</strong>
<code>“Strategy Games”</code>)/<code>“Strategy Games”</code></p>
<p>This means one possible solution for this would be:
<code>(games[(strategy == True) &amp; (thematic == False)].shape[0] / games[strategy == True].shape[0]</code>
This solution works because we are following the formula to find the
probability of thematic complement and strategy games over the number of
times <code>“Strategy Games”</code> are <code>True</code>. Doing
<code>games[query_condition]</code> gives us the <code>games</code>
DataFrame where <code>strategy == True</code> and
<code>thematic == False</code>. Another important thing is that for
(baby)pandas we always use the keyword <code>&amp;</code> and not
<code>and</code>. Note that we are using <code>.shape[0]</code> to get
the number of rows or times that <code>True</code> shows up for
<code>“Strategy Games”</code> and the number of rows or times that
<code>False</code> shows up for <code>“Thematic Games”</code>
Compliment.</p>
<p>Another possible strategy would be using the complement rule: Which
would be: P(<code>“Thematic Games”</code> Compliment) = 1 -
P(<code>“Thematic Games”</code>). This would lead you to an answer like:
<code>(1 - games[strategy &amp; thematic].shape[0]) / games[strategy].shape[0]</code>.
<code>games[strategy &amp; thematic].shape[0])</code> finds you the
probability of P(<code>“Thematic Games”</code>), so when plugged into
the equation above we are able to find P(<code>“Thematic Games”</code>
Compliment).</p>
<hr/>
<h5>Difficulty: ⭐️</h5>
<p>
</p>
<p>The average score on this problem was 100%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<h3 id="problem-3.3">Problem 3.3</h3>
<p>Many of the games in the <code>games</code> DataFrame belong to more
than one domain. We want to identify the number of games that belong to
only one domain. Select all of the options below that would correctly
calculate the number of games that belong to only one domain.
<strong>Hint:</strong> Don’t make any assumptions about the possible
domains.</p>
<ul class="task-list">
<li><p><input type="checkbox" disabled="" /> <code>(games.get("Domains").str.split(" ").apply(len) == 2).sum()</code></p></li>
<li><p><input type="checkbox" disabled="" /> <code>(games.get("Domains").apply(len) == 1).sum()</code></p></li>
<li><p><input type="checkbox" disabled="" /> <code>(games[games.get("Domains").str.split(",").apply(len) == 1].groupby("Domains").count().get("Name").sum())</code></p></li>
<li><p><input type="checkbox" disabled="" /> <code>games[games.get("Domains").str.split(",").apply(len) == 1].shape[0]</code></p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading3_3">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse3_3" aria-expanded="true" aria-controls="collapse3_3">
Click to view the solution.
</button>
</h2>
<div id="collapse3_3" class="accordion-collapse collapse"
aria-labelledby="heading3_3" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer:</strong> Options 3 and 4</p>
<p>Let’s take a closer look at why <strong>Option 3</strong> and
<strong>Option 4</strong> are correct.</p>
<p><strong>Option 3</strong>: Option 3 first queries the
<code>games</code> DataFrame to only keep <code>games</code> with one
<code>“Domains”</code>.
<code>games.get(“Domains”).str.split(“,”).apply(len) == 1</code> gets
the <code>“Domains”</code> column and splits all of them if they contain
a comma. If the value does have a comma then it will create a list. For
example let’s say the domain was
<code>“Strategy Games”, “Thematic Games”</code> then after doing
<code>str.split(“,”)</code> we would have the <code>list</code>:
<code>[“Strategy Games”, “Thematic Games”]</code>. Any row with a
<code>list</code> will evaluate to <code>False</code>. This means we are
only keeping values where there is <strong>one</strong> domain. The next
part <code>.groupby(“Domains”).count().get(“Name”).sum()</code> makes a
DataFrame with an index of the unique domains and the number of times
those appear. Note that all the other columns: <code>“Name”</code>,
<code>“Mechanics”</code>, <code>“Play Time”</code>,
<code>“Complexity”</code>, <code>“Rating”</code>, and
<code>“BGG Rank”</code> now evaluate to the same thing, the number of
times a unique domain appears. That means by doing
<code>.get(“Name”).sum()</code> we are adding up all the number of times
a unique domain appears, which would get us the number of games that
belong to only one domain.</p>
<p><strong>Option 4</strong>: Option 4 starts off exactly like Option 3,
but instead of doing <code>.groupby()</code> it gets the number of rows
using <code>.shape[0]</code>, which will give us the number of games
that belong to only one domain.</p>
<p><strong>Option 1:</strong> Let’s step through why Option 1 is
incorrect.
<code>games.get(“Domains”).str.split(“ ”).apply(len) == 2.sum()</code>
gives you a <code>Series</code> of the <code>“Domains”</code> column,
then splits each domain by a space. We then get the length of that
<code>list</code>, check if the length is equal to 2, which would mean
there are two elements in the <code>list</code>, and finally get the sum
of all elements in the list who had two elements because of the split.
Remember that <code>True</code> evaluates to 1 and <code>False</code>
evaluates to 0, so we are getting the number of elements that were split
into two. It does not tell us the number of games that belong to only
one domain.</p>
<p><strong>Option 2:</strong> Let’s step through why Option 2 is also
incorrect. <code>(games.get(“Domains”).apply(len) == 1).sum()</code>
checks to see if each element in the column <code>“Domains”</code> has
only one character. Remember when you apply <code>len()</code> to a
string then we get the number of characters in that string. This is
essentially counting the number of domains that have 1 letter. Thus, it
does not tell us the number of games that belong to only one domain.</p>
<hr/>
<h5>Difficulty: ⭐️</h5>
<p>
</p>
<p>The average score on this problem was 100%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<hr />
<h2 id="problem-4">Problem 4</h2>
<p>We want to create a bootstrapped 95% confidence interval for the
median <code>"Complexity"</code> of all cooperative games, given a
sample of 100 cooperative games.</p>
<p>Suppose <code>coop_sample</code> is a DataFrame containing 100 rows
of games, all of which are cooperative games. We’ll calculate the
endpoints <code>left</code> and <code>right</code> of our bootstrapped
95% confidence interval as follows.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>medians <span class="op">=</span> np.array([])</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> np.arange(<span class="dv">10000</span>):</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    resample <span class="op">=</span> coop_sample.sample(<span class="dv">100</span>, replace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    median <span class="op">=</span> np.median(resample.get(<span class="st">&quot;Complexity&quot;</span>))</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    medians <span class="op">=</span> np.append(medians, median)</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>left <span class="op">=</span> np.percentile(medians, <span class="fl">2.5</span>)</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>right <span class="op">=</span> np.percentile(medians, <span class="fl">97.5</span>)</span></code></pre></div>
<p><br></p>
<h3 id="problem-4.1">Problem 4.1</h3>
<p>Now consider the interval defined by the endpoints
<code>left_2</code> and <code>right_2</code>, calculated as follows.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>medians_2 <span class="op">=</span> np.array([])</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> np.arange(<span class="dv">10000</span>):</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    shuffle <span class="op">=</span> coop_sample.assign(shuffle<span class="op">=</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    np.random.permutation(coop_sample.get(<span class="st">&quot;Complexity&quot;</span>)))</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    resample_2 <span class="op">=</span> shuffle.sample(<span class="dv">100</span>, replace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    median_2 <span class="op">=</span> np.median(resample_2.get(<span class="st">&quot;shuffle&quot;</span>))</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>    medians_2 <span class="op">=</span> np.append(medians_2, median_2)</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>left_2 <span class="op">=</span> np.percentile(medians_2, <span class="fl">2.5</span>)</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>right_2 <span class="op">=</span> np.percentile(medians_2, <span class="fl">97.5</span>)</span></code></pre></div>
<p>Which interval should be wider, <code>[left, right]</code> or
<code>[left_2, right_2]</code>?</p>
<ul class="task-list">
<li><p><input type="radio" disabled="" /> <code>[left, right]</code></p></li>
<li><p><input type="radio" disabled="" /> <code>[left_2, right_2]</code></p></li>
<li><p><input type="radio" disabled="" /> Both about the same.</p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading4_1">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse4_1" aria-expanded="true" aria-controls="collapse4_1">
Click to view the solution.
</button>
</h2>
<div id="collapse4_1" class="accordion-collapse collapse"
aria-labelledby="heading4_1" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer:</strong> Both about the same.</p>
<p>It’s important to understand what each code block above is doing in
order to answer this question. Let’s take a look at the original
<code>medians</code> code. We are sampling from the
<code>coop_sample</code> to create a shuffled <code>coop_sample</code>,
we then get the median of the column “Complexity” and append it to the
<code>medians</code> array. Finally, we find the left and right
percentiles of the <code>medians</code> array.</p>
<p>Now we will look at what <code>medians_2</code> is doing. It looks
like we are adding a new column called <code>“shuffle”</code> to
<code>coop_sample</code>. The column <code>“shuffle”</code> is a
shuffled version of <code>“Complexity”</code>. Then we are taking the
<code>shuffle</code> DataFrame with the <code>“shuffle”</code> column
and sampling from <code>“shuffle”</code> to randomize it again. Then we
get the median of this shuffled column and find its percentiles.</p>
<p>Essentially, both of these blocks of code are taking the
<code>“Complexity”</code> column, shuffling it, finding the median of
the shuffled column, and then finding the confidence interval. Since it
is being done on the same column and in basically the same way both
intervals <code>[left, right]</code> and <code>[left_2, right_2]</code>
are about the same.</p>
<hr/>
<h5>Difficulty: ⭐️</h5>
<p>
</p>
<p>The average score on this problem was 100%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<h3 id="problem-4.2">Problem 4.2</h3>
<p>Now consider the interval defined by the endpoints
<code>left_3</code> and <code>right_3</code>, calculated as follows.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>medians_3 <span class="op">=</span> np.array([])</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> np.arange(<span class="dv">10000</span>):</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    resample_3 <span class="op">=</span> (coop_sample.sample(<span class="dv">100</span>, replace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>        .sample(<span class="dv">100</span>, replace<span class="op">=</span><span class="va">True</span>))</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>    median_3 <span class="op">=</span> np.median(resample_3.get(<span class="st">&quot;Complexity&quot;</span>))</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>    medians_3 <span class="op">=</span> np.append(medians_3, median_3)</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>left_3 <span class="op">=</span> np.percentile(medians_3, <span class="fl">2.5</span>)</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>right_3 <span class="op">=</span> np.percentile(medians_3, <span class="fl">97.5</span>)</span></code></pre></div>
<p>Which interval should be wider, <code>[left, right]</code> or
<code>[left_3, right_3]</code>?</p>
<ul class="task-list">
<li><p><input type="radio" disabled="" /> <code>[left, right]</code></p></li>
<li><p><input type="radio" disabled="" /> <code>[left_3, right_3]</code></p></li>
<li><p><input type="radio" disabled="" /> Both about the same.</p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading4_2">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse4_2" aria-expanded="true" aria-controls="collapse4_2">
Click to view the solution.
</button>
</h2>
<div id="collapse4_2" class="accordion-collapse collapse"
aria-labelledby="heading4_2" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer:</strong> <code>[left, right]</code></p>
<p><code>[left, right]</code> will be wider than
<code>[left_3, right_3]</code> because we are more likely to sample the
same elements in <code>medians_3</code>. When we
<code>.sample(100, replace = True)</code> twice we are more likely to
have elements that are repeating each other, which would make our
percentiles smaller. The rest of the code is similar to
<code>medians</code>.</p>
<hr/>
<h5>Difficulty: ⭐️</h5>
<p>
</p>
<p>The average score on this problem was 100%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<hr />
<h2 id="problem-5">Problem 5</h2>
<p>As in the previous question, let <code>coop_sample</code> be a sample
of 100 rows of games, all corresponding to cooperative games.</p>
<p>Define <code>samp</code> and <code>resamp</code> as follows.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>samp <span class="op">=</span> coop_sample.get(<span class="st">&quot;Complexity&quot;</span>)</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>resamp <span class="op">=</span> coop_sample.sample(<span class="dv">100</span>, replace<span class="op">=</span><span class="va">True</span>).get(<span class="st">&quot;Complexity&quot;</span>)</span></code></pre></div>
<p><br></p>
<h3 id="problem-5.1">Problem 5.1</h3>
<p>Which of the following statements <strong>could</strong> evaluate to
True? Select all that are possible.</p>
<ul class="task-list">
<li><p><input type="checkbox" disabled="" /> <code>len(samp.unique()) &lt; len(resamp.unique())</code></p></li>
<li><p><input type="checkbox" disabled="" /> <code>len(samp.unique()) == len(resamp.unique())</code></p></li>
<li><p><input type="checkbox" disabled="" /> <code>len(samp.unique()) &gt; len(resamp.unique())</code></p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading5_1">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse5_1" aria-expanded="true" aria-controls="collapse5_1">
Click to view the solution.
</button>
</h2>
<div id="collapse5_1" class="accordion-collapse collapse"
aria-labelledby="heading5_1" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer:</strong> Options 2 and 3</p>
<p><strong>Option 1:</strong> The reason that this is incorrect is
because <code>samp.unique()</code> has the most possible unique elements
inside of it. When we shuffle it using
<code>coop_sample.sample(100, replace = True)</code> we could pull the
same value multiple times, making it less unique.</p>
<p><strong>Option 2:</strong> This is correct because it is possible for
<code>resamp</code> to be shuffled in such a way that the number of
unique elements are not the same.</p>
<p><strong>Option 3:</strong> This is correct because it is possible for
<code>resamp</code> to pull the same values more often making it less
unique than <code>samp</code>.</p>
<hr/>
<h5>Difficulty: ⭐️</h5>
<p>
</p>
<p>The average score on this problem was 100%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<h3 id="problem-5.2">Problem 5.2</h3>
<p>Which of the following statements <strong>could</strong> evaluate to
True? Select all that are possible.</p>
<ul class="task-list">
<li><p><input type="checkbox" disabled="" /> <code>np.count nonzero(samp == 1) &lt; np.count nonzero(resamp == 1)</code></p></li>
<li><p><input type="checkbox" disabled="" /> <code>np.count nonzero(samp == 1) == np.count nonzero(resamp == 1)</code></p></li>
<li><p><input type="checkbox" disabled="" /> <code>np.count nonzero(samp == 1) &gt; np.count nonzero(resamp == 1)</code></p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading5_2">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse5_2" aria-expanded="true" aria-controls="collapse5_2">
Click to view the solution.
</button>
</h2>
<div id="collapse5_2" class="accordion-collapse collapse"
aria-labelledby="heading5_2" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer:</strong> Options 1, 2, and 3</p>
<p><strong>Option 1:</strong> It might be helpful to recall what exactly
the column <code>“Complexity”</code> holds. In this case it holds the
average complexity of the game on a scale of 1 to 5. The code is trying
to find if the number of ones in <code>samp</code> and
<code>resamp</code> are different. It is possible that when shuffling
due to <code>replace = True</code> that <code>resamp</code> has more
ones inside of it than <code>samp</code>.</p>
<p><strong>Option 2:</strong> Once again it is possible that when
shuffled <code>resamp</code> has the same number of ones as
<code>samp</code> does.</p>
<p><strong>Option 3:</strong> When we shuffle <code>coop_sample</code>
there is no guarantee that one will sample more ones and instead other
averages could be selected. This means it is possible for the number of
ones in <code>samp</code> can be greater than the number of ones in
<code>resamp</code>.</p>
<hr/>
<h5>Difficulty: ⭐️</h5>
<p>
</p>
<p>The average score on this problem was 100%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<h3 id="problem-5.3">Problem 5.3</h3>
<p>Which of the following statements <strong>could</strong> evaluate to
True? Select all that are possible.</p>
<ul class="task-list">
<li><p><input type="checkbox" disabled="" /> <code>samp.min() &lt; resamp.min()</code></p></li>
<li><p><input type="checkbox" disabled="" /> <code>samp.min() == resamp.min()</code></p></li>
<li><p><input type="checkbox" disabled="" /> <code>samp.min() &gt; resamp.min()</code></p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading5_3">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse5_3" aria-expanded="true" aria-controls="collapse5_3">
Click to view the solution.
</button>
</h2>
<div id="collapse5_3" class="accordion-collapse collapse"
aria-labelledby="heading5_3" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer:</strong> Options 1 and 2</p>
<p><strong>Option 1:</strong> It is possible when shuffled that
<code>samp</code>’s original minimum is never sampled, making
<code>resamp</code>’s minimum to be greater than <code>samp</code>’s
min.</p>
<p><strong>Option 2:</strong>: If <code>samp</code>’s original min is
sampled then it will be the same minimum that appears inside of
<code>resamp</code>.</p>
<p><strong>Option 3:</strong> It is impossible for <code>resamp</code>’s
minimum to be less than <code>samp</code>’s minimum. This is because all
of <code>resamp</code>’s values come from <code>samp</code>. That means
there cannot be a smaller average inside of <code>resamp</code> that
never appears in <code>samp</code>.</p>
<hr/>
<h5>Difficulty: ⭐️</h5>
<p>
</p>
<p>The average score on this problem was 100%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<h3 id="problem-5.4">Problem 5.4</h3>
<p>Which of the following statements <strong>could</strong> evaluate to
True? Select all that are possible.</p>
<ul class="task-list">
<li><p><input type="checkbox" disabled="" /> <code>np.std(samp) &lt; np.std(resamp)</code></p></li>
<li><p><input type="checkbox" disabled="" /> <code>np.std(samp) == np.std(resamp)</code></p></li>
<li><p><input type="checkbox" disabled="" /> <code>np.std(samp) &gt; np.std(resamp)</code></p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading5_4">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse5_4" aria-expanded="true" aria-controls="collapse5_4">
Click to view the solution.
</button>
</h2>
<div id="collapse5_4" class="accordion-collapse collapse"
aria-labelledby="heading5_4" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer:</strong> Options 1, 2, and 3</p>
<p><strong>Option 1:</strong> <code>np.std()</code> gives us the
standard deviation of the array we give it. When we do
<code>np.std(samp)</code> we are finding the standard deviation of
<code>“Complexity”</code>. When we do <code>np.std(resamp)</code> we are
finding the standard deviation of <code>“Complexity”</code>, which may
grab values multiple times. Since we are grabbing values multiple times
it is possible to have a standard deviation become smaller if we
continuously grab smaller values.</p>
<p><strong>Option 2:</strong> If the <code>resamp</code> gets us the
same values as <code>samp</code> we would end up with the same standard
deviation, which would make
<code>np.std(samp) == np.std(resamp)</code>.</p>
<p><strong>Option 3:</strong> Similar to Option 1, we may grab many
values which are on the larger end, which could increase our standard
deviation.</p>
<hr/>
<h5>Difficulty: ⭐️</h5>
<p>
</p>
<p>The average score on this problem was 100%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<hr />
<h2 id="problem-6">Problem 6</h2>
<p>Choose the best tool to answer each of the following questions. Note
the following:</p>
<ul>
<li>By “hypothesis testing,” we mean “standard” hypothesis testing,
i.e. hypothesis testing that <strong>doesn’t</strong> involve
permutation testing or bootstrapping.</li>
<li>By “bootstrapping,” we mean bootstrapping that
<strong>doesn’t</strong> involve hypothesis testing.</li>
</ul>
<p><br></p>
<h3 id="problem-6.1">Problem 6.1</h3>
<p>Are strategy games rated higher than non-strategy games?</p>
<ul class="task-list">
<li><p><input type="radio" disabled="" /> Hypothesis testing</p></li>
<li><p><input type="radio" disabled="" /> Permutation testing</p></li>
<li><p><input type="radio" disabled="" /> Bootstrapping</p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading6_1">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse6_1" aria-expanded="true" aria-controls="collapse6_1">
Click to view the solution.
</button>
</h2>
<div id="collapse6_1" class="accordion-collapse collapse"
aria-labelledby="heading6_1" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer:</strong> Permutation testing</p>
<p>Recall that we use a permutation test when we want to determine if
two samples are from the same population. The question is asking if
“strategy games” are rated higher than “non-strategy games” meaning we
have two samples and want to know if they come from the same or
different rating populations.</p>
<p><strong>NOT DONE</strong></p>
<hr/>
<h5>Difficulty: ⭐️</h5>
<p>
</p>
<p>The average score on this problem was 100%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<h3 id="problem-6.2">Problem 6.2</h3>
<p>What is the mean complexity of all games?</p>
<ul class="task-list">
<li><p><input type="radio" disabled="" /> Hypothesis testing</p></li>
<li><p><input type="radio" disabled="" /> Permutation testing</p></li>
<li><p><input type="radio" disabled="" /> Bootstrapping</p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading6_2">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse6_2" aria-expanded="true" aria-controls="collapse6_2">
Click to view the solution.
</button>
</h2>
<div id="collapse6_2" class="accordion-collapse collapse"
aria-labelledby="heading6_2" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer:</strong> Bootstrapping</p>
<p>Bootstrapping is the act of resampling from a sample. We use
bootstrapping because the original sample looks like the population, so
by resampling the sample we are able to quantify our uncertainty. We can
use bootstrapping to approximate the distribution of the sample
statistic.</p>
<p><strong>NOT DONE</strong></p>
<hr/>
<h5>Difficulty: ⭐️</h5>
<p>
</p>
<p>The average score on this problem was 100%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<h3 id="problem-6.3">Problem 6.3</h3>
<p>Are there an equal number of cooperative and non-cooperative
games?</p>
<ul class="task-list">
<li><p><input type="radio" disabled="" /> Hypothesis testing</p></li>
<li><p><input type="radio" disabled="" /> Permutation testing</p></li>
<li><p><input type="radio" disabled="" /> Bootstrapping</p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading6_3">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse6_3" aria-expanded="true" aria-controls="collapse6_3">
Click to view the solution.
</button>
</h2>
<div id="collapse6_3" class="accordion-collapse collapse"
aria-labelledby="heading6_3" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer:</strong> Hypothesis Testing</p>
<p>Recall hypothesis tests quantify how “weird” a result is. We use it
when we have a population distribution and one sample and we are trying
to see if that sample was drawn from the population. In this instance we
are trying to find if there are an equal number of cooperative and
non-cooperative games. The population distribution is our DataFrame and
we are trying to see if the cooperative games and non-cooperative games
in our sample come from the same population.</p>
<p><strong>NOT DONE</strong></p>
<hr/>
<h5>Difficulty: ⭐️</h5>
<p>
</p>
<p>The average score on this problem was 100%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<h3 id="problem-6.4">Problem 6.4</h3>
<p>Are games with more than one domain more complex than games with one
domain?</p>
<ul class="task-list">
<li><p><input type="radio" disabled="" /> Hypothesis testing</p></li>
<li><p><input type="radio" disabled="" /> Permutation testing</p></li>
<li><p><input type="radio" disabled="" /> Bootstrapping</p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading6_4">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse6_4" aria-expanded="true" aria-controls="collapse6_4">
Click to view the solution.
</button>
</h2>
<div id="collapse6_4" class="accordion-collapse collapse"
aria-labelledby="heading6_4" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer:</strong> Permutation testing</p>
<p>Once again we would use permutation testing to solve this problem
because we have two samples: games with more than one domain and games
with one domain. We do not know the population distribution.</p>
<p><strong>NOT DONE</strong></p>
<hr/>
<h5>Difficulty: ⭐️</h5>
<p>
</p>
<p>The average score on this problem was 100%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<hr />
<h2 id="problem-7">Problem 7</h2>
<p>We use the regression line to predict a game’s <code>"Rating"</code>
based on its <code>"Complexity"</code>. We find that for the game
<em>Wingspan</em>, which has a <code>"Complexity"</code> that is 2
points higher than the average, the predicted <code>"Rating"</code> is 3
points higher than the average</p>
<p><br></p>
<h3 id="problem-7.1">Problem 7.1</h3>
<p>What can you conclude about the correlation coefficient r?</p>
<ul class="task-list">
<li><p><input type="radio" disabled="" /> <em>r</em> &lt; 0&gt;</p></li>
<li><p><input type="radio" disabled="" /> <em>r</em> = 0</p></li>
<li><p><input type="radio" disabled="" /> <em>r</em> &gt; 0</p></li>
<li><p><input type="radio" disabled="" /> We cannot make any conclusions about the value of <em>r</em> based on
this information alone.</p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading7_1">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse7_1" aria-expanded="true" aria-controls="collapse7_1">
Click to view the solution.
</button>
</h2>
<div id="collapse7_1" class="accordion-collapse collapse"
aria-labelledby="heading7_1" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer:</strong> <em>r</em> &gt; 0</p>
<p><strong>NOT DONE</strong></p>
<hr/>
<h5>Difficulty: ⭐️</h5>
<p>
</p>
<p>The average score on this problem was 100%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<h3 id="problem-7.2">Problem 7.2</h3>
<p>What can you conclude about the standard deviations of “Complexity”
and “Rating”?</p>
<ul class="task-list">
<li><p><input type="radio" disabled="" /> SD of <code>"Complexity"</code> &lt; SD of <code>"Rating"</code></p></li>
<li><p><input type="radio" disabled="" /> SD of <code>"Complexity"</code> = SD of <code>"Rating"</code></p></li>
<li><p><input type="radio" disabled="" /> SD of <code>"Complexity"</code> &gt; SD of <code>"Rating"</code></p></li>
<li><p><input type="radio" disabled="" /> We cannot make any conclusions about the relationship between these
two standard deviations based on this information alone.</p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading7_2">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse7_2" aria-expanded="true" aria-controls="collapse7_2">
Click to view the solution.
</button>
</h2>
<div id="collapse7_2" class="accordion-collapse collapse"
aria-labelledby="heading7_2" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer:</strong> SD of <code>"Complexity"</code> &lt; SD of
<code>"Rating"</code></p>
<p><strong>NOT DONE</strong></p>
<hr/>
<h5>Difficulty: ⭐️</h5>
<p>
</p>
<p>The average score on this problem was 100%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<hr />
<h2 id="problem-8">Problem 8</h2>
<p><br></p>
<h3 id="problem-8.1">Problem 8.1</h3>
<p>Suppose that for children’s games, <code>"Play Time"</code> and
<code>"Rating"</code> are negatively linearly associated due to children
having short attention spans. Suppose that for children’s games, the
standard deviation of <code>"Play Time"</code> is twice the standard
deviation of <code>"Rating"</code>, and the average
<code>"Play Time"</code> is 10 minutes. We use linear regression to
predict the <code>"Rating"</code> of a children’s game based on its
<code>"Play Time"</code>. The regression line predicts that <em>Don’t
Break the Ice</em>, a children’s game with a <code>"Play Time"</code> of
8 minutes will have a <code>"Rating"</code> of 4. Which of the following
could be the average <code>"Rating"</code> for children’s games?</p>
<ul class="task-list">
<li><p><input type="radio" disabled="" /> 2</p></li>
<li><p><input type="radio" disabled="" /> 2.8</p></li>
<li><p><input type="radio" disabled="" /> 3.1</p></li>
<li><p><input type="radio" disabled="" /> 4</p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading8_1">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse8_1" aria-expanded="true" aria-controls="collapse8_1">
Click to view the solution.
</button>
</h2>
<div id="collapse8_1" class="accordion-collapse collapse"
aria-labelledby="heading8_1" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer:</strong> 3.1.</p>
<p><strong>NOT DONE</strong></p>
<hr/>
<h5>Difficulty: ⭐️</h5>
<p>
</p>
<p>The average score on this problem was 100%.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<hr />
<h2 id="section"><span class="math display"> </span></h2>
<h4
id="feedback-find-an-error-still-confused-have-a-suggestion-let-us-know-here.">👋
Feedback: Find an error? Still confused? Have a suggestion?
<a href="https://forms.gle/WZ71FchnXU1K154d7">Let us know
here</u></a>.</h4>
<hr />
</body>
</html>
