# BEGIN PROB

# BEGIN SUBPROB

Nate's favorite number is 5. He calls a number "lucky\" if it's greater
than 500 or if it contains a 5 anywhere in its representation. For
example, `1000.04` and `5.23` are both lucky numbers.

Complete the implementation of the function `check_lucky`, which takes
in a number as a float and returns `True` if it is lucky and `False`
otherwise. Then, add a column named `"is_lucky"` to `txn` that contains
`True` for lucky transaction amounts and `False` for all other
transaction amounts, and save the resulting DataFrame to the variable
`luck`.

        def check_lucky(x):
            return __(a)__

        luck = txn.assign(is_lucky = __(b)__)

1.  What goes in blank (a)?


2.  What goes in blank (b)?


# BEGIN SOLUTION
a: `x > 500 or "5" in str(x)`
b: `txn.get("amount").apply(check_lucky)`
# END SOLUTION

# END SUBPROB

# BEGIN SUBPROB

Fill in the blanks below so that `lucky_prop` evaluates to the
proportion of fraudulent `"visa"` card transactions whose transaction
amounts are lucky.

    visa_fraud = __(a)__
    lucky_prop = visa_fraud.__(b)__.mean()

1.  What goes in blank (a)?

2.  What goes in blank (b)?

# BEGIN SOLUTION

b: `get("is_lucky")`
a: `luck[(luck.get("card")=="visa") &`\
    `(luck.get("is_fraud"))]`    
# END SOLUTION

# END SUBPROB

# BEGIN SUBPROB

Fill in the blanks below so that `lucky_prop` is one value in the Series
`many_props`.

    many_props = luck.groupby(__(a)__).mean().get(__(b)__)

1.  What goes in blank (a)?

2.  What goes in blank (b)?

# BEGIN SOLUTION
a: `["is_fraud", "method"]` or `["method", "is_fraud"]`
b: `"is_lucky"`

# END SOLUTION

# END SUBPROB

# END PROB