# BEGIN PROB

Fill in the blanks below so that the expression evaluates to the most
unread emails of any student that has 0 Instagram followers.

```py
survey[__(a)__].__(b)__
```

# BEGIN SUBPROB

What goes in blank (a)?

# BEGIN SOLUTION

**Answer**: `survey.get("IG Followers") == 0`

`survey.get("IG Followers")` is a Series containing the values in the `"IG Followers"` column. `survey.get("IG Followers") == 0`, then, is a Series of `True`s and `False`s, containing `True` for rows where the number of `"IG Followers"` is 0 and `False` for all other rows.

Put together, `survey[survey.get("IG Followers") == 0]` evaluates to a new DataFrame, which only has the rows in `survey` where the student's number of `"IG Followers"` is `0`.

# END SOLUTION

# END SUBPROB


# BEGIN SUBPROB

What goes in blank (b)? Select all valid answers.

[ ] `get("Unread Emails").apply(max)`
[ ] `get("Unread Emails").max()`
[ ] `sort_values("Unread Emails", ascending=False).get("Unread Emails").iloc[0]`
[ ] `sort_values("Unread Emails", ascending=False).get("Unread Emails").iloc[-1]`
[ ] None of the above

# BEGIN SOLUTION

**Answer**: Options 2 and 3

Let's look at each option.
- **Option 1**: `get("Unread Emails").apply(max)` This option is invalid because the `apply(max)` is used to apply a function across the elements of an axis, which isnâ€™t suitable for obtaining the maximum value of a column. The `max()` function, in this case, doesn't produce the intended outcome because it is applied to each individual element rather than the column as a whole.
- **Option 2**: `get("Unread Emails").max()` This option is valid because it directly fetches the `"Unread Emails"` column and utilizes the `max()` function to retrieve the highest value within it, aligning with the goal of identifying the most unread emails.
- **Option 3**: `sort_values("Unread Emails", ascending=False).get("Unread Emails").iloc[0]` This option is valid. The `sort_values("Unread Emails", ascending=False)` part sorts the `"Unread Emails"` column in descending order. Following this, `.get("Unread Emails")` retrieves the sorted column, and `.iloc[0]` selects the first element, which, given the sorting, represents the maximum number of unread emails.
- **Option 4**: `sort_values("Unread Emails", ascending=False).get("Unread Emails").iloc[-1]` This option is invalid because, although it sorts the `"Unread Emails"` column in descending order, it selects the last element with `.iloc[-1]`, which represents the smallest number of unread emails due to the descending sort order.

# END SOLUTION

# END SUBPROB


Now, consider the following block of code.

```py
temp = survey.groupby(["IG Followers", "College"]).max().reset_index()
revellian = temp[__(c)__].get("Unread Emails").__(d)__
```

Fill in the blanks below so that `revellian` is equal to the most unread
emails of any student in Revelle, among those with 0 Instagram
followers.

# BEGIN SUBPROB

What goes in blank (c)?

# BEGIN SOLUTION

**Answers**: `(temp.get("College") == "Revelle") & (temp.get("IG Followers") == 0)`

TODO add explanation

# END SOLUTION

# END SUBPROB


# BEGIN SUBPROB

What goes in blank (d)?

# BEGIN SOLUTION

**Answer**: `iloc[0]`, `iloc[-1]`, `sum()`, `max()`, or `mean()`.

TODO add explanation

# END SOLUTION

# END SUBPROB


# BEGIN SUBPROB

The student in Revelle with the most unread emails, among those with 0
Instagram followers, is a `"HI25"` (History) major.
Is the value `"HI25"` guaranteed to appear at least once within
`temp.get("Major")`?

( ) Yes
( ) No

# BEGIN SOLUTION

**Answer**: No

TODO add explanation

# END SOLUTION

# END SUBPROB

# END PROB