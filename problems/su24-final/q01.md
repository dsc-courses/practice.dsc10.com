# BEGIN PROB

# BEGIN SUBPROB

Fill in the blanks so that the expression below evaluates to the
*proportion* of stages won by the country with the most stage wins.

```py
    stages.groupby(__(i)__).__(ii)__.get("Type").__(iii)__ / stages.shape[0]
```

# BEGIN SOLUTION

# END SOLUTION

# END SUBPROB

# BEGIN SUBPROB

The distance of a stage alone does not encapsulate its difficulty, as riders feel more tired as the tour goes on. Because of this, we want to consider "real distance" a measurement of the length of a stage that takes into account how far into the tour the riders are. The "real distance" is calculated with the following process:

(i) Add one to the stage number.

(ii) Take the square root of the result of (i).

(iii) Multiply the result of (ii) by the raw distance of the stage.

Complete the implementation of the function `real_distance`, which takes in `stages` (a DataFrame), `stage` (a string, the name of the column containing stage numbers), and `distance` (a string, the name of the column containing stage distances). `real_distance` returns a Series containing all of the "real distances" of the stages, as calculated above.

```py
    def real_distance(stages, stage, distance):
         ________
```

# BEGIN SOLUTION
**Solution:** `return stages.get(distance) * np.sqrt(stages.get(stage) + 1)`

# END SOLUTION

# END SUBPROB

# BEGIN SUBPROB

Sometimes, stages are repeated in different editions of the Tour de France, meaning that there are some pairs of `"Origin"` and `"Destination"` that appear more than once in `stages`. Fill in the blanks so that the expression below evaluates how often the most common `"Origin"` and `"Destination"` pair in the `stages` DataFrame appears.

```py
stages.groupby(__(i)__).__(ii)__.sort_values(by = "Date").get("Type").iloc[__(iii)__]
```

# BEGIN SOLUTION

# END SOLUTION

# END SUBPROB

# BEGIN SUBPROB

Fill in the blanks so that the value of `mystery_three` is the `"Destination"` of the longest stage before Stage 12.

```py
    mystery = stages[stages.get(__(i)__) < 12]
    mystery_two = mystery.sort_values(by = "Distance", ascending = __(ii)__)
    mystery_three = mystery_two.get(__(iii)__).iloc[-1]
```

# BEGIN SOLUTION

# END SOLUTION

# END SUBPROB

# END PROB