# BEGIN PROB

Suppose we have access to another DataFrame called `orders`, containing
all student dining hall orders from the past three years. `orders`
includes the following columns, among others:

1.  `"Dining Hall"` (`str`): The dining hall where the order was placed.

2.  `"Start"` (`str`): The time the order was placed.

3.  `"End"` (`str`): The time the order was completed.

All times are expressed in 24-hour military time format (HH:MM). For
example, `"13:15"` indicates 1:15 PM. All orders were completed on the
same day as they were placed, and `"End"` is always after `"Start"`.

# BEGIN SUBPROB

Fill in the blanks in the function `to_minutes` below. The function
takes in a string representing a time in 24-hour military time format
(HH:MM) and returns an int representing the number of minutes that have
elapsed since midnight. Example behavior is given below.

```py
    >>> to_minutes("02:35")
    155

    >>> to_minutes("13:15")
    795

    def to_minutes(time):
        separate = time.__(a)__
        hour = __(b)__
        minute = __(c)__
        return __(d)__
```

# BEGIN SOLUTION

**Answer (a):** `split(':')`

<average>84</average>

**Answer (b):** `separate[0]`

<average>73</average>

**Answer (c):** `separate[1]`

<average>73</average>

**Answer (d):** `int(hour) * 60 + int(minute)`

<average>73</average>

# END SOLUTION

# END SUBPROB

# BEGIN SUBPROB

Fill in the blanks below to add a new column called `"Wait"` to
`orders`, which contains the number of minutes elapsed between when an
order is placed and when it is completed. Note that the first two blanks
both say `(e)` because they should be filled in with the same value.

```py
    start_min = orders.get("Start").__(e)__
    end_min = orders.get("End").__(e)__
    orders = orders.assign(Wait = __(f)__)
```

# BEGIN SOLUTION

**Answer (e):** `apply(to_minutes)`

<average>87</average>

**Answer (f):** `end_min - start_min`

<average>87</average>

# END SOLUTION

# END SUBPROB

# BEGIN SUBPROB

You were told that `"End"` is always after `"Start"` in `orders`, but
you want to verify if this is correct. Fill the blank below so that the
result is `True` if `"End"` is indeed always after `"Start"`, and
`False` otherwise.

```py
    (orders.get("Wait") >= 0).sum() == __(g)__
```

# BEGIN SOLUTION

**Answer (g):** `orders.shape[0]`

<average>36</average>

# END SOLUTION

# END SUBPROB

# BEGIN SUBPROB

Fill in the blanks below so that `ranked` evaluates to an array
containing the names of the dining halls in `orders`, sorted in
descending order by **average wait time**.

```py
    ranked = np.array(orders.__(h)__
                             .sort_values(by="Wait", ascending=False)
                             .__(i)__)
```

# BEGIN SOLUTION

**Answer (h):** `groupby('Dining Hall').mean()`

<average>62</average>

**Answer (i):** `index` or `reset_index().get('Dining Hall')`

<average>43</average>

# END SOLUTION

# END SUBPROB

# BEGIN SUBPROB

What would be the most appropriate type of data visualization to compare
dining halls by average wait time?

( ) scatter plot
( ) line plot
( ) bar chart
( ) histogram
( ) overlaid plot

# BEGIN SOLUTION

**Answer:** bar chart

<average>89</average>

# END SOLUTION

# END SUBPROB

# END PROB