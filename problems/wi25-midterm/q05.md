# BEGIN PROB

It's the grand opening of UCSD's newest dining attraction: The Bread
Basket! As a hardcore bread enthusiast, you celebrate by eating as much
bread as possible. There are only a few menu items at The Bread Basket,
shown with their costs in the table below:

    **Bread**    **Cost**
  ------------- ----------
    Sourdough       2
   Whole Wheat      3
   Multigrain       4

Suppose you are given an array `eaten` containing the names of each type
of bread you ate.

For example, `eaten` could be defined as follows:

```py
    eaten = np.array(["Whole Wheat", "Sourdough", "Whole Wheat", 
                      "Sourdough", "Sourdough"])
```

In this example, `eaten` represents five slices of bread that you ate,
for a total cost of $\$12$. Pricey!

In this problem, you'll calculate the total cost of your bread-eating
extravaganza in various ways. In all cases, your code must calculate the
total cost for an arbitrary `eaten` array, which might not be exactly
the same as the example shown above.

# BEGIN SUBPROB

One way to calculate the total cost of the bread in the `eaten`
array is outlined below. Fill in the missing code.

```py
    breads = ["Sourdough", "Whole Wheat", "Multigrain"]
    prices = [2, 3, 4]
    total_cost = 0
    for i in __(a)__:
        total_cost = (total_cost + 
                     np.count_nonzero(eaten == __(b)__) * __(c)__)
```

# BEGIN SOLUTION

**Answer (a):** `[0, 1, 2]` or `np.arange(len(bread))` or `range(3)` or equivalent

<average>58</average>

**Answer (b):** `breads[i]`

<average>61</average>

**Answer (c):** `prices[i]`

<average>61</average>

Let's develop answers from intuition. 

1. We have a for loop. What are we looping over? 

2. `total_cost = (total_cost + __(a)__)`. We are adding something to the total price every time. **What are we adding?** Would it be adding for each bread in eaten or each type of bread? It can be a million things. 

3. `np.count_nonzero(array)` gives the number of non-zero elements in an array. **What exactly are we counting?** 

4. `eaten == __(b)__` is used inside `np.count_nonzero`. `eaten` is a numpy array, and the python syntax `some_np_array == [something]` is an assertions statement that returns a boolean array of whether or not certain elements in the array is equal to the statement on the right. For example, `arr = np.array([1,2,3])`, `print(arr == 1)` gives `[True False False]`.

5. We are multiplying the statement inside the `np.count_nonzero` by something. What could this be doing? 

We can infer the code is doing the following: for each type of the bread, we multiply the number of breads with the price and accumulate to get the total price. Let's start filling the blanks. 

- The for loop header should loop over the number of types of breads, in order to use the index `i` to access all types of bread in the breads array. So blank **(a)** is either `range(len(bread))`, `range(len(price))` or `[0,1,2]`. 

- Now we look at the loop body. Starting from the easiest, to access the price of each type of bread, we use `price[i]` for **(c)**. Finally, to get the number of each type of bread, we use `bread[i]` for **(b)**. This way, `eaten == bread[i]` will return an array of trues and falses for each index inside `eaten`, and since the boolean values `True` is equal to 1 and `False` is 0, `np.count_nonzero(eaten == bread[i])` will return the number of `True`s for each bread type. So `total + np.count_nonzero(eaten == bread[i]) * price[i]` accumulates the bread `number * price`. 

Bravo! We have everything ww want, the code block is now complete. 
# END SOLUTION

# END SUBPROB

# BEGIN SUBPROB

A third way to calculate the total cost of the bread in the `eaten`
array uses the `merge` method. Fill in the missing code below.

```py
    available = bpd.DataFrame().assign(Type = ["Sourdough", 
                "Whole Wheat", "Multigrain"]).assign(Cost = [2, 3, 4])
    consumed = bpd.DataFrame().assign(Eaten = eaten)
    combined = available.merge(consumed, left_on = __(d)__, 
                               right_on = __(e)__)   
    total_cost = combined.__(f)__
```

# BEGIN SOLUTION

**Answer (d):** `'Type'`

<average>81</average>

**Answer (e):** `'Eaten'`

<average>80</average>

**Answer (f):** `get('Cost').sum()`

<average>70</average>

It always helps to sketch out the dataframes. 
<center><img src="../assets/images/wi25-midterm/q5-2.png" width=300></center>

Let's first develope some intuition based on the keywords.  

1. We create two dataframes as seen above, and we perform a **merge** operation. [Recall how merge works.](https://dsc-courses.github.io/bpd-reference/docs/documentation/building-organizing/df.merge())   We want to fill in what columns we merge on. It should be easy to see that **(e)** would be the `Eaten` column in consumed, so let's fill that in. (This will also make sense later on.)

2. We are getting total_cost from the combined dataframe in some way. If we want the total amount of something, what aggregation function might we use? 

We have done similar questions in the past. [Quiz 2 Problem 2](https://practice.dsc10.com/wi25-quiz2/index.html) showed us what would have happend if we merged dataframes on columns with repeating entries. In general, if we have `df_left.merge(df_right, left_on=col_left, right_on=col_right)`, assuming all entries are non-empty, the combination process is to look at individual entries from the left and grab all entries from the right that matches the entry content. Based on this, we can infer that the `combine` dataframe will be a long list of all the breads we have and their prices. The final two blanks are settled: we can get the list of all beads by merging on `Type` in `available` to match with `Eaten` for blank **(d)**, and we can use `combined.get('Cost').sum()` to get the total price of all the bread in the list for blank **(f)**. 
# END SOLUTION

# END SUBPROB

# END PROB
