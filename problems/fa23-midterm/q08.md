# BEGIN PROB

After the family reunion, Family Y gets together with nine other
families to play a game. All ten families (which we'll number 1 through
10) have a composition of `"2a3c"`. Within each family, the three
children are labeled `"oldest"`, `"middle"`, or `"youngest"`.

In this game, the numbers 1 through 10, representing the ten families,
are placed into a hat. Then, **five times**, they draw a number from the
hat, write it down on a piece of paper, and place it back into the hat.
If a family's number is written down on the paper at least twice, then
two of the three children in that family are randomly selected to win a
prize. The same child cannot be selected to win a prize twice.

Chiachan is the middle child in Family 4. He writes a simulation, which
is partially provided on the next page. Fill in the blanks so that after
running the simulation,

-   `np.count_nonzero(outcomes == "Outcome Q") / repetitions` gives an
    estimate of the probability that Chiachan wins a prize.

-   `np.count_nonzero(outcomes == "Outcome R") / repetitions` gives an
    estimate of the probability that both of Chiachan's siblings win a
    prize, but Chiachan does not.

-   `np.count_nonzero(outcomes == "Outcome S") / repetitions` gives an
    estimate of the probability that nobody from Chiachan's family wins
    a prize.

```{=html}
<!-- -->
```
    ages = np.array(["oldest", "middle", "youngest"])
    outcomes = np.array([])
    repetitions = 10000
    for i in np.arange(repetitions):
        fams = np.random.choice(np.arange(1, 11), 5, ____(a)____)
        if ____(b)____:
            children = np.random.choice(ages, 2, ____(c)____)
            if not "middle" in children:
                outcomes = np.append(outcomes, ____(d)____)
            else:
                outcomes = np.append(outcomes, ____(e)____)
        else:
            outcomes = np.append(outcomes, ____(f)____)

# BEGIN SUBPROB

What goes in blank (a)?

( ) `replace=True`
( ) `replace=False`

# BEGIN SOLUTION

**Answer:** `replace=True`

A family can be selected more than once to be initialized in the
`fams` array, therefore we use `replace=True`. When we use this argument 
we sample with replacement, which corresponds to 'placing the number back into
the hat' in the problem statement as we placing the number back into the hat is emulated by replacing the sampled value with that same exact value.

<average>88</average>

# END SOLUTION

# END SUBPROB

# BEGIN SUBPROB

What goes in blank (b)?

# BEGIN SOLUTION

**Answer:** `np.count_nonzero(fams == 4) >= 2` or equivalent

We want to separate the conditions of what outcomes to append to the outcomes array. 
To do this we can condition on checking how many elements in the fams array equal 4, representing the case that Chiachan's family is chosen. To do this, we can use `np.count_nonzero(fams == 4) >= 2`; this corresponds to Chiachan's family being chosen two or more times as `np.count_nonzero(fams == 4)` evaluates to an array of Truthy/Falsey values (0's and 1's) and each 1 / True value represents family 4, Chiachan's family being chosen. Then as long as there are 2 `Trues` in this array, we know Chiachan's family has been chosen, and therefore the condition becomes true, leading to the following indented line to be executed, where 2 children are selected randomly from Chiachan's family, which could only happen if family 4 is selected at least twice.

<average>17</average>

# END SOLUTION

# END SUBPROB

# BEGIN SUBPROB

What goes in blank (c)?

( ) `replace=True`
( ) `replace=False`

# BEGIN SOLUTION

**Answer:** `replace=False`

A child cannot win a prize twice, so we remove them from the pool 
after being selected.

<average>86</average>

# END SOLUTION

# END SUBPROB

# BEGIN SUBPROB

What goes in blank (d)?

( ) `"Outcome Q"`
( ) `"Outcome R"`
( ) `"Outcome S"`

# BEGIN SOLUTION

**Answer:** `Outcome R` 

Chiachan is the middle child in the family, and recall that each outcome 
corresponds to either Chiachan winning, his family members winning, or none of them winning.
This condition checks the negation of the middle child being selected, so we append `Outcome R`
which corresponds to one of his siblings being selected.

<average>76</average>

# END SOLUTION

# END SUBPROB

# BEGIN SUBPROB

What goes in blank (e)?

( ) `"Outcome Q"`
( ) `"Outcome R"`
( ) `"Outcome S"`

# BEGIN SOLUTION

**Answer:** `Outcome Q` 

Chiachan is the middle child in the family, and recall that each outcome 
corresponds to either Chiachan winning, his family members winning, or none of them winning.
When the middle child is selected, we append `Outcome Q`, representing the corresponding situation where Chichan does win a prize.

<average>75</average>

# END SOLUTION

# END SUBPROB

# BEGIN SUBPROB

What goes in blank (f)?

( ) `"Outcome Q"`
( ) `"Outcome R"`
( ) `"Outcome S"`

# BEGIN SOLUTION

**Answer:** `Outcome S` 

In the case that no one in Chiachan's family is selected, 
we append the corresponding `Outcome S` where neither Chiachan nor anyone 
of the siblings win the prize. We can see these two cases of Chiachan/a sibling
winning and not Chiachan/nor a sibling winning a prize if we look at the inside 
of the for loop wholistically, with these two cases being an under their own `if`
and `else` statements.

<average>80</average>

# END SOLUTION

# END SUBPROB

# END PROB