# BEGIN PROB

Fill in the blanks below to estimate the probability that a randomly
generated three-letter lowercase sequence forms a real English word
represented in the `words` DataFrame.

    letters = __(a)__
    for letter in "abcdefghijklmnopqrstuvwxyz":
        letters = np.append(letters, letter)

    repetitions = 10000
    found = 0

    for i in np.arange(repetitions):
        seq = "".join(np.random.choice(__(b)__, 3, replace=True))
        if __(c)__:
            found = found + 1

    prob_real_word = __(d)__
    prob_real_word


# BEGIN SOLUTION

`(a)`: `np.array([])`

Both arrays and lists are appendable, meaning we can keep adding ele-
ments one by one. We start with an empty container so that in the for
loop, each letter from `”abcdefghijklmnopqrstuvwxyz”` can be added into it.
We need this container (letters) so that by the end of the loop,
we have a full collection of all lowercase letters. Later, we’ll
use this collection as the pool to randomly pick letters from.
So whether we start with an empty array `(np.array([]))` or an empty list
`([])`, the purpose is the same to store all 26 lowercase letters that the pro-
gram will later draw from when generating random three-letter words.

`(b)`: `letters`

The function `np.random.choice()` randomly selects elements from a given ar-
ray. We want to generate a random 3-letter sequence from the alphabet.
`np.random.choice(letters, 3, replace=True)` means “randomly choose
3 letters from the letters array, allowing repetition.” We use `re-
place=True` because letters can repeat (e.g., “mom”, “dad”).
The result is something like [’m’, ’o’, ’m’].
Then `””.join(...)` combines them into ”mom”.

`(c)`: `seq in words.index`

After generating a random sequence like ”mom”, we need to check
if it’s a real English word. The problem says that the real En-
glish words are represented in the index of the DataFrame words.
So we use: if seq in words.index: This condition is True when the
randomly generated sequence matches a word stored in the dataset.
Every time that happens, we increment the counter found by 1.

`(d)`: `found / repetitions`

Finally, we estimate the probability. The logic is: Probability = (Number of
successful outcomes) / (Total trials). In this case, a “successful outcome” is
when the randomly generated three-letter sequence that forms an English word
appears in the words DataFrame (index). Since we repeated the experiment
10,000 times, prob real world=found/repetitions gives the estimated probability.

<average>65</average>

# END SOLUTION

# END PROB