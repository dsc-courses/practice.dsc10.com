# BEGIN PROB

Suppose we have a function `classify_difficulty` that takes as input the
number of students that marked a word difficult, and returns a
difficulty rating of the word: `"easy"`, `"moderate"`, or `"hard"`.
Define the DataFrame `grouped` as follows. Note that this uses the
`classify_length` function from the previous problem.

    grouped = (words.assign( diff_category = 
                            words.get("diff").apply(classify_difficulty),
                            length_category = 
                            words.get("length").apply(classify_length)
                            )
                    .groupby(["diff_category", "length_category"])
                    .count()
                    .reset_index()
               )

Suppose there is **at least one word** with every possible pair of
values for `"diff_category"` and `"length_category"`.

# BEGIN SUBPROB

How many rows does `grouped` have? Give your answer as an integer.


# BEGIN SOLUTION

**Answer**: `9`

The code groups the dataframe by two columns, so the number of
rows will be the number of combinations between the two rows. So the two
columns are 'diff_category': (\"easy\", \"moderate\", \"hard\") and
'length_category': (\"short\", \"medium\", \"long\"), and 3 columns x 3
columns = `9 columns`.

<average>77</average>

# END SOLUTION

# END SUBPROB 

# BEGIN SUBPROB

Fill in the blank to set `num` to the number of words whose
`"diff_category"` is `"hard"` and whose `"length_category"` is
`"short"`. Recall that `.groupby` arranges the rows of its output in
alphabetical order.

    num = grouped.get("ps").iloc[__(a)__]


# BEGIN SOLUTION

`(a)`: `5`

As stated in the last answer, the options for the two indicies are ’diff category’:
(”easy”, ”moderate”, ”hard”) and ’length category’: (”short”, ”medium”,
”long”), with ’diff category’ coming first then ’length category’. We want to
find the row that is “hard” and ”short”. If we sort each index alphabetically,
we get (”easy”, ”hard”, ”moderate”) and (”medium”, ”long”, ”short”).
Then, the dataframe looks like ”easy” difficulty for indices 0-2, ”hard” dif-
ficulty for 3-5, and medium for 6-8, with each difficulty’s first row being
”medium”, second being ”long”, and last being ”short”. Since we want the
hard, short word, we go hard → indices 3-5, then hard and short → index 5.

<average>52</average>

# END SOLUTION

# END SUBPROB 

# BEGIN SUBPROB

We want to determine the proportion of `"short"` words that are
`"hard"`. Fill in the blanks in the code below such that `prop`
evaluates to this proportion.

    denom = grouped[__(b)__].get("freq").__(c)__
    prop = num / denom

# BEGIN SOLUTION

`(b)`: `grouped.get("length category") == short`

We want the proportion of short words that are hard. Remember, proportions
are usually a part of the data divided by the whole sample space. We already
have the row that is the part of the data, which we did in part b. Therefore,
the denom should be the whole sample space, which in this case is the total
amount of short words. So, when we query, we want only the short words,
which we get by querying with `grouped.get("length category") == short`.

`(c)`: `.sum()`

Once we get the `freq` column, we’re left with one row indexed by `"short"`
with three subentries for each difficulty, so we need to use` .sum()`

<average>38</average>

# END SOLUTION

# END SUBPROB

# END PROB