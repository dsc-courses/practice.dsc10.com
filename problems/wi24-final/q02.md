# BEGIN PROB

Frank X. Kugler has Olympic medals in three sports (wrestling,
weightlifting, and tug of war), which is more sports than any other
Olympic medalist. Furthermore, his medals for all three of these sports
are included in the `olympians` DataFrame. Fill in the blanks below so
that the expression below evaluates to `"Frank X. Kugler"`.

```py
                (olympians.groupby(__(a)__).__(b)__
                          .reset_index()
                          .groupby(__(c)__).__(d)__
                          .sort_values(by="Age", ascending=False)
                          .index[0])
``` 


# BEGIN SUBPROB
What goes in blank (a)?

# BEGIN SOLUTION

**Answer:** `['Name', 'Sport']` or `['Sport', 'Name']`

The question wants us to find the name (Frank X. Kugler) who has records that correspond to three distinct sports. However, we know that the same athlete might have multiple records not because they participated in different sports but because they participated in the same sport for multiple years. Therefore, first, we groupby 'Name' and 'Sport' to create a dataframe with unique Name-Sport pairs. This is a dataframe that contains the athletes and their sports (for each athlete, their corresponding sports are distinct). 

<average>75</average>

# END SOLUTION

# END SUBPROB

# BEGIN SUBPROB
What goes in blank (b)?

# BEGIN SOLUTION

**Answer:** `.sum()` or `.mean()` or `.min()`, etc. 

Any aggregation methods applied on `DataFrame.groupby()`. Because we donâ€™t care about the aggregated numeric value, we just want to remove cases which the same athlete participates in the same sport for multiple years, and get unique name-sport pairs. Notice `.unique()` is not correct because it is not an aggregation method used on dataframe after grouping by. If you use `.unique()`, it will give you "AttributeError: 'DataFrameGroupBy' object has no attribute 'unique'". However, `.unique()` can be used after `Series.groupby()`. For more info: <https://pandas.pydata.org/docs/reference/api/pandas.core.groupby.SeriesGroupBy.unique.html>.

<average>96</average>

# END SOLUTION

# END SUBPROB

# BEGIN SUBPROB
What goes in blank (c)?

# BEGIN SOLUTION

**Answer:** `'Name'`

Now after reset_index, we have `'Name'` and `'Sport'` columns containing unique name-sport pairs. The objective is to count how many different sports each Olympian has medals in. To do that, we groupby `'Name'` and later use the `.count()` method. This would, in effect, give a new DataFrame that has a count of how many times each name shows up in our previous DataFrame with unique name-sport pairs.

<average>81</average>

# END SOLUTION

# END SUBPROB

# BEGIN SUBPROB
What goes in blank (d)?

# BEGIN SOLUTION

**Answer:** `.count()`

The `.count()` method is applied to each group. In this context, `.count()` will get the number of entries for each Olympian across different sports. Since the previous steps ensured each sport per Olympian is uniquely listed (due to the initial groupby on both `'Name'` and `'Sport'`). It does not matter what we sort_values by, because the `.groupby('Name').count()` method will just put a count of each `'Name'` in all of the columns, regardless of the column name or what value was originally in it.

<average>64</average>

# END SOLUTION

# END SUBPROB

# END PROB