# BEGIN PROB

After you graduate, you are hired by TritonCard! On your new work computer, you install `numpy`, but something goes wrong with the installation — your copy of `numpy` doesn’t come with `np.random.multinomial`. To demonstrate your resourcefulness to your new employer, you decide to implement your own version of `np.random.multinomial`.

Below, complete the implementation of the function `manual_multinomial` so that `manual_multinomial(n, p)` works the same way as `np.random.multinomial(n, p)`. That is, `manual_multinomial` should take in an integer `n` and an array of probabilities `p`. It should return an array containing the counts in each category when we randomly draw `n` items from a categorical distribution where the probabilities of drawing an item from each category are given in the array `p`. The array returned by `manual_multinomial(n, p)` should have a length of `len(p)` and a sum of `n`.

For instance, to simulate flipping a coin five times, we could call `manual_multinomial(5, np.array([0.5, 0.5]))`, and the output might look like `array([2, 3])`.

``` py
def manual_multinomial(n, p):
    values = np.arange(len(p))
    choices = np.random.choice(values, size=__(a)__, replace=__(b)__, p=p)
    value_counts = np.array([])
    for value in values:
        value_count = __(c)__
        value_counts = np.append(value_counts, value_count)
    return value_counts
```

# BEGIN SUBPROB
What goes in blank (a)?

# BEGIN SOLUTION

**Answer:** `n`

The size argument in `np.random.choice` provides the number of samples we draw. In the `manual_multinomial` function, we randomly draw `n` items, and so the size should be `n`. 
# END SOLUTION
# END SUBPROB

# BEGIN SUBPROB
What goes in blank (b)?

# BEGIN SOLUTION

**Answer:** True

Here, we are using `np.random.choice` to simulate picking `n` elements from `values`. We draw with replacement since each sample that we take is independent from one another. In the given example where we simulate flipping a coin five times, each flip of the coin is independent from every other flip of the coin. Because of this, we sample with replacement.
# END SOLUTION
# END SUBPROB

# BEGIN SUBPROB
What goes in blank \(c\)?

# BEGIN SOLUTION

**Answer:** `np.count_nonzero(choices == value)`

The `choices` variable contains an array of the `n` randomly drawn values selected from `values`. In each iteration of the for-loop, where we are iterating through each possible `value` that could have been drawn from `values`, we want to count the number of elements in `choices` that equal to `value`. To do this, we can use `np.count_nonzero(choices == value)`.

# END SOLUTION
# END SUBPROB
# END PROB
