# BEGIN PROB

For each application in apps, we want to assign an age category based on the value in the
"age" column, according to the table below.

(insert table here)

```py
cat_names = ["young adult", "middle aged", "older adult", "elderly"]

def age_to_bin(one_age):
    '''Returns the age category corresponding to one_age.'''
    one_age = __(a)__
    bin_pos = __(b)__
    return cat_names[bin_pos]

binned_ages = __(c)__
apps_cat = apps.assign(age_category = binned_ages)
```
# BEGIN SUBPROB

Which of the following is a correct way to fill in blanks (a) and (b)?

(insert table)

( ) Option 1
( ) Option 2
( ) Option 3
( ) Option 4
( ) Option 5

# BEGIN SOLUTION

**Answer: ** Option 4

What this code is doing is taking in a number and returning the category that
corresponds to it. `min(75,one_age)` would take in the age and then either leave
it as is, or set it equal to 75 if the age was higher as thats the highest bin 
we have. From the return statement, we know we need our value for bin_pos to be
either 0, 1 ,2 or 3 or else it would be outside the index. Therefore the answer
must be an integer which is achieved by int(one_age/25)


# END SOLUTION

# END SUBPROB


# BEGIN SUBPROB

Which of the following is a correct way to fill in blank (c)?

( ) `age to bin(apps.get("age"))`
( ) `apps.get("age").apply(age to bin)`
( ) `apps.get("age").age to bin()`
( ) `apps.get("age").apply(age to bin(one age))`

# BEGIN SOLUTION

**Answer: ** `apps.get("age").apply(age to bin)`

We want our result to be series because the next line in the code assigns it to
a DataFrame. We also need to use the `.apply()` method to apply our function to
the entirety of the age column. The `.apply()` method only takes in the name of 
a function and not its variables, as it treats the entries of the column as the 
variables directly.

# END SOLUTION

# END SUBPROB


# BEGIN SUBPROB

Which of the following is a correct alternate implementation of the age to bin
function? Select all that apply.

Option 1: 
```py
def age_to_bin(one_age):
    bin_pos = 3
    if one_age < 25:
        bin_pos = 0
    if one_age < 50:
        bin_pos = 1
    if one_age < 75:
        bin_pos = 2
    return cat_names[bin_pos]
```

Option 2: 
```py
def age_to_bin(one_age):
    bin_pos = 3
    if one_age < 75:
        bin_pos = 2
    if one_age < 50:
        bin_pos = 1
    if one_age < 25:
        bin_pos = 0
    return cat_names[bin_pos]
```


Option 3: 
```py
def age_to_bin(one_age):
    bin_pos = 0
    for cutoff in np.arange(25, 100, 25):
        if one_age >= cutoff:
            bin_pos = bin_pos + 1 
    return cat_names[bin_pos]
```



Option 4: 
```py
def age_to_bin(one_age):
    bin_pos = -1
    for cutoff in np.arange(0, 100, 25):
        if one_age >= cutoff:
            bin_pos = bin_pos + 1 
        return cat_names[bin_pos]
```



[ ] Option 1
[ ] Option 2
[ ] Option 3
[ ] Option 4
[ ] None of the above.

# BEGIN SOLUTION

**Answer: ** Option 2 and Option 3

The reason option 1 doesn't work is suppose we have an age of 10. Then every if
condition gets entered, since 10<25, 10<50 and 10<75, making bin_pos = 2 when we 
want it to be 0. 

Option 2 reverses this order which ensures that even when a number enters many 
if conditions, the last one it enters is the correct one. (27 would enter the 
first 2 but would not enter the last one.)

In option 3, `np.arange(25, 100, 25)` produces an array with `[25,50,75]` as its
values. The if condition checks the age in steps, is the age greater or equal to
25, then 50, then 75. For every time that it is, it moves on to the next bin 
position. If the age isnt greater or equal to one of them, then it remains at 
its current bin position.

Option 4 is equivalent to option 3 except the return is inside the for loop 
which will cause it to stop running after 1 if condition has been checked.
(Ex : if the age was 55, we check 55>= 0, add +1 to bin pos then return
  catnames[0] ) 

# END SOLUTION

# END SUBPROB
