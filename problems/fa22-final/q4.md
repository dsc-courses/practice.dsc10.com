# BEGIN PROB

Question goes here



# BEGIN SUBPROB

In our implementation of this permutation test, we followed the procedure outlined in lecture to draw new pairs of samples under the null hypothesis and compute test statistics --- that is, we randomly assigned each row to a group (approved or denied) by shuffling one of the columns in \texttt{apps}, then computed the test statistic on this random pair of samples.

Let's now explore an alternative solution to drawing pairs of samples under the null hypothesis and computing test statistics. Here’s the approach:

1. Shuffle, i.e. re-order, the rows of the DataFrame.
2. Use the values at the top of the resulting `"dependents"` column as the new "denied" sample, and the values at the at the bottom of the resulting `"dependents"` column as the new "approved" sample. Note that we don’t necessarily split the DataFrame exactly in half --- the sizes of these new samples depend on the number of "denied" and "approved" values in the original DataFrame!

Once we generate our pair of random samples in this way, we'll compute the test statistic on the random pair, as usual. Here, we'll use as our test statistic the difference between the mean number of dependents for denied and approved applicants, in the order **denied minus approved**.

**Fill in the blanks to complete the simulation below.**

*Hint:* `np.random.permutation` shouldn't appear anywhere in your code.

<center><img src='../assets/images/fa22-final/q4_code.png' width=60%></center>

# BEGIN SOLUTION
**Anwser: **

Blank A: `df.sample(df.shape[0])`

Blank B: `df.take(np.arange(denied))`

Blank C: `df.take(np.arange(denied+1, df.shape[0]))`

**For the blank A**, the function wants to return a DataFrame with the same number of rows (the size of our sample), but wants 
these rows reordered. Note that the actual rows will be the same, so we want to sample without replacement (having only one
instance of each row in the old dataframe in the new dataframe). Baby Pandas provides the `.sample` method for this question.
`.sample` will sample dataframe rows where the first argument is the amount of samples, and the second (optional) argument is whether
or not we want to conduct sampling with replacement. As mentioned previously, we want the same number of rows which we can find using
`df.shape[0]` and do this sampling without replacement (the default behavior so we do not have to specify). 

**For blank B**, when we want to conduct a permutation test, the idea is to shuffle and combine the values
in two different groups. In this function the `denied` variable is the number of dependents values we need to take for our new sample of “denied” applicants.
To find the mean number of denied, we want to use `df.take(np.arange(denied))` to get the correct number
of denied applicants while also conducting shuffling.

**For blank C**, the logic falls similar to the logic mentioned above. Instead of denied applicants,
we are now looking at the approved applicants. To account for the number of approved applicants, we can use 
`df.take(np.arange(denied+1, df.shape[0]))` which accounts for the number of approved applicants (while also considering shuffling)
since it starts at `denied+1` to the end of the dataframe (which is found using `df.shape[0]`).


# END SOLUTION

# END SUBPROB

# END PROB
