# BEGIN PROB

Professor Severus Snape is rumored
to display favoritism toward certain students. Specifically, some
believe that he awards more house points to students from **wizarding
families** (those with at least one wizarding parent) than students from
**muggle families** (those without wizarding parents).

To investigate this claim, you will perform a **permutation test** with
these hypotheses:

-   **Null Hypothesis:** Snape awards house points **independently of a
    student's family background** (wizarding family vs. muggle family).
    Any observed difference is due to chance.

-   **Alternative Hypothesis:** Snape awards **more** house points to
    students from wizarding families, on average.

The DataFrame `snape` is indexed by `"Student"` and contains information
on each student's family background (`"Family"`) and the number of house
points awarded by Snape (`"Points"`). The first few rows of `snape` are
shown below.

<center><img src='../assets/images/wi25-final/snape.jpg' width=400></center>

# BEGIN SUBPROB

Which of the following is the most appropriate test statistic for our
permutation test?

( ) The total number of house points awarded to students from wizarding families minus the total number of house points awarded to students from muggle families.
( ) The mean number of house points awarded to students from wizarding families minus the mean number of house points awarded to students from muggle families.
( ) The number of students from wizarding families minus the number of students from muggle families.
( ) The absolute difference between the mean number of house points awarded to students from wizarding families and the mean number of house points awarded to students from muggle families.

# BEGIN SOLUTION

# END SOLUTION

# END SUBPROB

# BEGIN SUBPROB

Fill in the blanks in the function `one_stat`, which calculates one
value of the test statistic you chose in part (a), based on the data in
`df`, which will have columns called `"Family"` and `"Points"`.

        def one_stat(df):
            grouped = df.groupby(__(a)__).__(b)__
            return __(c)__



# BEGIN SOLUTION

# END SOLUTION

# END SUBPROB

# BEGIN SUBPROB

Fill in the blanks in the function `calculate_stats`, which calculates
1000 simulated values of the test statistic you chose in part (a), under
the assumptions of the null hypothesis. As before, `df` will have
columns called `"Family"` and `"Points"`.

        def calculate_stats(df)
            statistics = np.array([])
            
            for i in np.arange(1000):
                shuffled = df.assign(Points = __(d)__)
                stat = one_stat(__(e)__)
                statistics = __(f)__
        
            return statistics


# BEGIN SOLUTION

# END SOLUTION

# END SUBPROB

# BEGIN SUBPROB

Fill in the blanks to calculate the p-value of the permutation test,
based on the data in `snape`.

        observed = __(g)__
        simulated = __(h)__
        p_value = (simulated __(i)__ observed).mean()



# BEGIN SOLUTION

# END SOLUTION

# END SUBPROB

# BEGIN SUBPROB

Define `mini_snape = snape.take(np.arange(3))` as shown below.



<center><img src='../assets/images/wi25-final/snape.jpg' width=400></center>


Determine the value of the following expression.

        len(calculate_stats(mini_snape))

::: center
:::

# BEGIN SOLUTION

# END SOLUTION

# END SUBPROB

# BEGIN SUBPROB

With `mini_snape` defined as above, there will be at most three unique
values in `calculate_stats(mini_snape)`. What are those three values?
Put the **smallest value on the left and the largest on the right**.

::: center
:::

# BEGIN SOLUTION

# END SOLUTION

# END SUBPROB

# END PROB