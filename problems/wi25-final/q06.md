# BEGIN PROB

Professor Severus Snape is rumored
to display favoritism toward certain students. Specifically, some
believe that he awards more house points to students from **wizarding
families** (those with at least one wizarding parent) than students from
**muggle families** (those without wizarding parents).

To investigate this claim, you will perform a **permutation test** with
these hypotheses:

-   **Null Hypothesis:** Snape awards house points **independently of a
    student's family background** (wizarding family vs. muggle family).
    Any observed difference is due to chance.

-   **Alternative Hypothesis:** Snape awards **more** house points to
    students from wizarding families, on average.

The DataFrame `snape` is indexed by `"Student"` and contains information
on each student's family background (`"Family"`) and the number of house
points awarded by Snape (`"Points"`). The first few rows of `snape` are
shown below.

<center><img src='../assets/images/wi25-final/snape.jpg' width=400></center>

# BEGIN SUBPROB

Which of the following is the most appropriate test statistic for our
permutation test?

( ) The total number of house points awarded to students from wizarding families minus the total number of house points awarded to students from muggle families.
( ) The mean number of house points awarded to students from wizarding families minus the mean number of house points awarded to students from muggle families.
( ) The number of students from wizarding families minus the number of students from muggle families.
( ) The absolute difference between the mean number of house points awarded to students from wizarding families and the mean number of house points awarded to students from muggle families.

# BEGIN SOLUTION

# END SOLUTION

# END SUBPROB

# BEGIN SUBPROB

Fill in the blanks in the function `one_stat`, which calculates one
value of the test statistic you chose in part (a), based on the data in
`df`, which will have columns called `"Family"` and `"Points"`.

        def one_stat(df):
            grouped = df.groupby(__(a)__).__(b)__
            return __(c)__



# BEGIN SOLUTION

# END SOLUTION

# END SUBPROB

# BEGIN SUBPROB

Fill in the blanks in the function `calculate_stats`, which calculates
1000 simulated values of the test statistic you chose in part (a), under
the assumptions of the null hypothesis. As before, `df` will have
columns called `"Family"` and `"Points"`.

        def calculate_stats(df)
            statistics = np.array([])
            
            for i in np.arange(1000):
                shuffled = df.assign(Points = __(d)__)
                stat = one_stat(__(e)__)
                statistics = __(f)__
        
            return statistics


# BEGIN SOLUTION

# END SOLUTION

# END SUBPROB

# BEGIN SUBPROB

Fill in the blanks to calculate the p-value of the permutation test, based on the data in `snape`.

```py
    observed = __(g)__
    simulated = __(h)__
    p_value = (simulated __(i)__ observed).mean()
```

# BEGIN SOLUTION

**Answer:**

- **\(g\):** `one_stat(snape)` or `snape.groupby("Family").mean().get("Points").loc["Wizarding"] -  snape.groupby("Family").mean().get("Points").loc["Muggle"]` or `snape.groupby("Family").mean().get("Points").iloc[1] -  snape.groupby("Family").mean().get("Points").iloc[0]`
- **\(h\):** `calculate_stats(snape)`
- **\(i\):** `>=`

Our observed is going to be the test statistic we obtain from the initial observed data. We already created a function to calculate the test statistic — `one_stat`—, so we just need to apply it to our observed data —`snape`—, giving `one_state(snape)` in blank g. You can also manually calculate the observed test statistic by applying the logic in the formula giving either: `snape.groupby("Family").mean().get("Points").loc["Wizarding"] - snape.groupby("Family").mean().get("Points").loc["Muggle"]` or `snape.groupby("Family").mean().get("Points").iloc[1] - snape.groupby("Family").mean().get("Points").iloc[0]`.

The simulated variable is simply the array of simulated test statistics. We already created a function to run the simulation called `calculate_stats`, so we just need to call it with our data giving `calculate_stats(snape)` in blank h.

Finally, the p-value is the probability of observing a result as extreme or even more extreme than our observed. The alternative hypothesis states that Snape awards more points to students from wizarding families, and the test statistic is the mean points of wizarding families minus the mean points from muggle families. Thus, in this case, a more extreme result, would be the simulated statistics being larger than the observed value. Thus, we use the `>=` operator in blank i to calculate the the number of simulated statistics that are equal to or greater than the observed value. Calculating the mean of this boolean series will output this proportion of seeing a result as extreme or even more extreme than the observed.

<average>80</average>
<average>80</average>
<average>81</average>

# END SOLUTION

# END SUBPROB

# BEGIN SUBPROB

Define `mini_snape = snape.take(np.arange(3))` as shown below.



<center><img src='../assets/images/wi25-final/snape.jpg' width=400></center>


Determine the value of the following expression.

```py
len(calculate_stats(mini_snape))
```


# BEGIN SOLUTION

**Answer:** 1000

This problem is trying to find the length of the `calculate_stats(snape)` array. Looking at `calculate_stats`, we know that it calculates a simulated test statistic and appends it to the output array 1000 times as indicated in the for loop. Thus, the output of the function is an array of size 1000.

<average>78</average>

# END SOLUTION

# END SUBPROB

# BEGIN SUBPROB

With `mini_snape` defined as above, there will be at most three unique values in `calculate_stats(mini_snape)`. What are those three values? Put the **smallest value on the left and the largest on the right**.

# BEGIN SOLUTION

**Answer:** -5, -2, and 7

We are trying to find the three unique values outputted by `calculate_stats(mini_snape)`. The function shuffles the `'Points'` column, thus assigning new points to either the 'Wizarding' or 'Muggle' label. We know that there is one 'Muggle' label and two 'Wizarding' labels, so with each iteration, the 'Wizarding' label will have two items and the 'Muggle' label will only have one item. There are only three unique values that can be calculated from this because there are only three unique groups of two and one that can be made using the data. For example, if the data was A,B,C, then the only three unique groups of two and one we can create are AC and B, AB and C, and BC and A. Thus, we can now just run through all the combinations of groups to find our three unique values. We can do this by forming each scenario of groupings and calculating the test statistic by finding the mean number of points for 'Wizarding' and then subtracting by the value of 'Muggle' as dictated by the test statistic (Note: we do not need to take a mean for 'Muggle' since there is only one value assigned here):

Scenario 1:

- Wizarding: 15, 7
- Muggle: 13

$$
\begin{align*}
\frac{15+7}{2} = 11 \\ 
11 -13 = -2
\end{align*}
$$


Scenario 2:

- Wizarding: 13, 7
- Muggle: 15
$$
\begin{align*}
\frac{13+7}{2} = 10 \\ 
10 -15 = -5
\end{align*}
$$


Scenario 3: 

- Wizarding: 13, 15
- Muggle: 7

$$
\begin{align*}
\frac{13+15}{2} = 24 \\
14 - 7 = 7
\end{align*}
$$


Thus, our answer from least to greatest is -5, -2, and 7.

<average>66</average>

# END SOLUTION

# END SUBPROB

# END PROB